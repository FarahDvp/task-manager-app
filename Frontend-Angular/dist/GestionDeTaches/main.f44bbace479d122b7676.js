(self.webpackChunkgestion_de_taches = self.webpackChunkgestion_de_taches || []).push([[179], { 255: t => { function e(t) { return Promise.resolve().then(() => { var e = new Error("Cannot find module '" + t + "'"); throw e.code = "MODULE_NOT_FOUND", e }) } e.keys = () => [], e.resolve = e, e.id = 255, t.exports = e }, 823: (t, e, i) => { "use strict"; function n(t) { return "function" == typeof t } let s = !1; const r = { Promise: void 0, set useDeprecatedSynchronousErrorHandling(t) { if (t) { const t = new Error; console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n" + t.stack) } else s && console.log("RxJS: Back to a better error behavior. Thank you. <3"); s = t }, get useDeprecatedSynchronousErrorHandling() { return s } }; function o(t) { setTimeout(() => { throw t }, 0) } const a = { closed: !0, next(t) { }, error(t) { if (r.useDeprecatedSynchronousErrorHandling) throw t; o(t) }, complete() { } }, l = (() => Array.isArray || (t => t && "number" == typeof t.length))(); function c(t) { return null !== t && "object" == typeof t } const h = (() => { function t(t) { return Error.call(this), this.message = t ? `${t.length} errors occurred during unsubscription:\n${t.map((t, e) => `${e + 1}) ${t.toString()}`).join("\n  ")}` : "", this.name = "UnsubscriptionError", this.errors = t, this } return t.prototype = Object.create(Error.prototype), t })(); let u = (() => { class t { constructor(t) { this.closed = !1, this._parentOrParents = null, this._subscriptions = null, t && (this._ctorUnsubscribe = !0, this._unsubscribe = t) } unsubscribe() { let e; if (this.closed) return; let { _parentOrParents: i, _ctorUnsubscribe: s, _unsubscribe: r, _subscriptions: o } = this; if (this.closed = !0, this._parentOrParents = null, this._subscriptions = null, i instanceof t) i.remove(this); else if (null !== i) for (let t = 0; t < i.length; ++t)i[t].remove(this); if (n(r)) { s && (this._unsubscribe = void 0); try { r.call(this) } catch (a) { e = a instanceof h ? d(a.errors) : [a] } } if (l(o)) { let t = -1, i = o.length; for (; ++t < i;) { const i = o[t]; if (c(i)) try { i.unsubscribe() } catch (a) { e = e || [], a instanceof h ? e = e.concat(d(a.errors)) : e.push(a) } } } if (e) throw new h(e) } add(e) { let i = e; if (!e) return t.EMPTY; switch (typeof e) { case "function": i = new t(e); case "object": if (i === this || i.closed || "function" != typeof i.unsubscribe) return i; if (this.closed) return i.unsubscribe(), i; if (!(i instanceof t)) { const e = i; i = new t, i._subscriptions = [e] } break; default: throw new Error("unrecognized teardown " + e + " added to Subscription.") }let { _parentOrParents: n } = i; if (null === n) i._parentOrParents = this; else if (n instanceof t) { if (n === this) return i; i._parentOrParents = [n, this] } else { if (-1 !== n.indexOf(this)) return i; n.push(this) } const s = this._subscriptions; return null === s ? this._subscriptions = [i] : s.push(i), i } remove(t) { const e = this._subscriptions; if (e) { const i = e.indexOf(t); -1 !== i && e.splice(i, 1) } } } return t.EMPTY = function (t) { return t.closed = !0, t }(new t), t })(); function d(t) { return t.reduce((t, e) => t.concat(e instanceof h ? e.errors : e), []) } const p = (() => "function" == typeof Symbol ? Symbol("rxSubscriber") : "@@rxSubscriber_" + Math.random())(); class f extends u { constructor(t, e, i) { switch (super(), this.syncErrorValue = null, this.syncErrorThrown = !1, this.syncErrorThrowable = !1, this.isStopped = !1, arguments.length) { case 0: this.destination = a; break; case 1: if (!t) { this.destination = a; break } if ("object" == typeof t) { t instanceof f ? (this.syncErrorThrowable = t.syncErrorThrowable, this.destination = t, t.add(this)) : (this.syncErrorThrowable = !0, this.destination = new g(this, t)); break } default: this.syncErrorThrowable = !0, this.destination = new g(this, t, e, i) } } [p]() { return this } static create(t, e, i) { const n = new f(t, e, i); return n.syncErrorThrowable = !1, n } next(t) { this.isStopped || this._next(t) } error(t) { this.isStopped || (this.isStopped = !0, this._error(t)) } complete() { this.isStopped || (this.isStopped = !0, this._complete()) } unsubscribe() { this.closed || (this.isStopped = !0, super.unsubscribe()) } _next(t) { this.destination.next(t) } _error(t) { this.destination.error(t), this.unsubscribe() } _complete() { this.destination.complete(), this.unsubscribe() } _unsubscribeAndRecycle() { const { _parentOrParents: t } = this; return this._parentOrParents = null, this.unsubscribe(), this.closed = !1, this.isStopped = !1, this._parentOrParents = t, this } } class g extends f { constructor(t, e, i, s) { let r; super(), this._parentSubscriber = t; let o = this; n(e) ? r = e : e && (r = e.next, i = e.error, s = e.complete, e !== a && (o = Object.create(e), n(o.unsubscribe) && this.add(o.unsubscribe.bind(o)), o.unsubscribe = this.unsubscribe.bind(this))), this._context = o, this._next = r, this._error = i, this._complete = s } next(t) { if (!this.isStopped && this._next) { const { _parentSubscriber: e } = this; r.useDeprecatedSynchronousErrorHandling && e.syncErrorThrowable ? this.__tryOrSetError(e, this._next, t) && this.unsubscribe() : this.__tryOrUnsub(this._next, t) } } error(t) { if (!this.isStopped) { const { _parentSubscriber: e } = this, { useDeprecatedSynchronousErrorHandling: i } = r; if (this._error) i && e.syncErrorThrowable ? (this.__tryOrSetError(e, this._error, t), this.unsubscribe()) : (this.__tryOrUnsub(this._error, t), this.unsubscribe()); else if (e.syncErrorThrowable) i ? (e.syncErrorValue = t, e.syncErrorThrown = !0) : o(t), this.unsubscribe(); else { if (this.unsubscribe(), i) throw t; o(t) } } } complete() { if (!this.isStopped) { const { _parentSubscriber: t } = this; if (this._complete) { const e = () => this._complete.call(this._context); r.useDeprecatedSynchronousErrorHandling && t.syncErrorThrowable ? (this.__tryOrSetError(t, e), this.unsubscribe()) : (this.__tryOrUnsub(e), this.unsubscribe()) } else this.unsubscribe() } } __tryOrUnsub(t, e) { try { t.call(this._context, e) } catch (i) { if (this.unsubscribe(), r.useDeprecatedSynchronousErrorHandling) throw i; o(i) } } __tryOrSetError(t, e, i) { if (!r.useDeprecatedSynchronousErrorHandling) throw new Error("bad call"); try { e.call(this._context, i) } catch (n) { return r.useDeprecatedSynchronousErrorHandling ? (t.syncErrorValue = n, t.syncErrorThrown = !0, !0) : (o(n), !0) } return !1 } _unsubscribe() { const { _parentSubscriber: t } = this; this._context = null, this._parentSubscriber = null, t.unsubscribe() } } const m = (() => "function" == typeof Symbol && Symbol.observable || "@@observable")(); function _(t) { return t } let v = (() => { class t { constructor(t) { this._isScalar = !1, t && (this._subscribe = t) } lift(e) { const i = new t; return i.source = this, i.operator = e, i } subscribe(t, e, i) { const { operator: n } = this, s = function (t, e, i) { if (t) { if (t instanceof f) return t; if (t[p]) return t[p]() } return t || e || i ? new f(t, e, i) : new f(a) }(t, e, i); if (s.add(n ? n.call(s, this.source) : this.source || r.useDeprecatedSynchronousErrorHandling && !s.syncErrorThrowable ? this._subscribe(s) : this._trySubscribe(s)), r.useDeprecatedSynchronousErrorHandling && s.syncErrorThrowable && (s.syncErrorThrowable = !1, s.syncErrorThrown)) throw s.syncErrorValue; return s } _trySubscribe(t) { try { return this._subscribe(t) } catch (e) { r.useDeprecatedSynchronousErrorHandling && (t.syncErrorThrown = !0, t.syncErrorValue = e), function (t) { for (; t;) { const { closed: e, destination: i, isStopped: n } = t; if (e || n) return !1; t = i && i instanceof f ? i : null } return !0 }(t) ? t.error(e) : console.warn(e) } } forEach(t, e) { return new (e = y(e))((e, i) => { let n; n = this.subscribe(e => { try { t(e) } catch (s) { i(s), n && n.unsubscribe() } }, i, e) }) } _subscribe(t) { const { source: e } = this; return e && e.subscribe(t) } [m]() { return this } pipe(...t) { return 0 === t.length ? this : (0 === (e = t).length ? _ : 1 === e.length ? e[0] : function (t) { return e.reduce((t, e) => e(t), t) })(this); var e } toPromise(t) { return new (t = y(t))((t, e) => { let i; this.subscribe(t => i = t, t => e(t), () => t(i)) }) } } return t.create = e => new t(e), t })(); function y(t) { if (t || (t = r.Promise || Promise), !t) throw new Error("no Promise impl found"); return t } const b = (() => { function t() { return Error.call(this), this.message = "object unsubscribed", this.name = "ObjectUnsubscribedError", this } return t.prototype = Object.create(Error.prototype), t })(); class w extends u { constructor(t, e) { super(), this.subject = t, this.subscriber = e, this.closed = !1 } unsubscribe() { if (this.closed) return; this.closed = !0; const t = this.subject, e = t.observers; if (this.subject = null, !e || 0 === e.length || t.isStopped || t.closed) return; const i = e.indexOf(this.subscriber); -1 !== i && e.splice(i, 1) } } class x extends f { constructor(t) { super(t), this.destination = t } } let S = (() => { class t extends v { constructor() { super(), this.observers = [], this.closed = !1, this.isStopped = !1, this.hasError = !1, this.thrownError = null } [p]() { return new x(this) } lift(t) { const e = new k(this, this); return e.operator = t, e } next(t) { if (this.closed) throw new b; if (!this.isStopped) { const { observers: e } = this, i = e.length, n = e.slice(); for (let s = 0; s < i; s++)n[s].next(t) } } error(t) { if (this.closed) throw new b; this.hasError = !0, this.thrownError = t, this.isStopped = !0; const { observers: e } = this, i = e.length, n = e.slice(); for (let s = 0; s < i; s++)n[s].error(t); this.observers.length = 0 } complete() { if (this.closed) throw new b; this.isStopped = !0; const { observers: t } = this, e = t.length, i = t.slice(); for (let n = 0; n < e; n++)i[n].complete(); this.observers.length = 0 } unsubscribe() { this.isStopped = !0, this.closed = !0, this.observers = null } _trySubscribe(t) { if (this.closed) throw new b; return super._trySubscribe(t) } _subscribe(t) { if (this.closed) throw new b; return this.hasError ? (t.error(this.thrownError), u.EMPTY) : this.isStopped ? (t.complete(), u.EMPTY) : (this.observers.push(t), new w(this, t)) } asObservable() { const t = new v; return t.source = this, t } } return t.create = (t, e) => new k(t, e), t })(); class k extends S { constructor(t, e) { super(), this.destination = t, this.source = e } next(t) { const { destination: e } = this; e && e.next && e.next(t) } error(t) { const { destination: e } = this; e && e.error && this.destination.error(t) } complete() { const { destination: t } = this; t && t.complete && this.destination.complete() } _subscribe(t) { const { source: e } = this; return e ? this.source.subscribe(t) : u.EMPTY } } function C(t) { return t && "function" == typeof t.schedule } function E(t, e) { return function (i) { if ("function" != typeof t) throw new TypeError("argument is not a function. Are you looking for `mapTo()`?"); return i.lift(new T(t, e)) } } class T { constructor(t, e) { this.project = t, this.thisArg = e } call(t, e) { return e.subscribe(new P(t, this.project, this.thisArg)) } } class P extends f { constructor(t, e, i) { super(t), this.project = e, this.count = 0, this.thisArg = i || this } _next(t) { let e; try { e = this.project.call(this.thisArg, t, this.count++) } catch (i) { return void this.destination.error(i) } this.destination.next(e) } } const D = t => e => { for (let i = 0, n = t.length; i < n && !e.closed; i++)e.next(t[i]); e.complete() }; function A() { return "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator" } const O = A(), R = t => t && "number" == typeof t.length && "function" != typeof t; function M(t) { return !!t && "function" != typeof t.subscribe && "function" == typeof t.then } const I = t => { if (t && "function" == typeof t[m]) return i = t, t => { const e = i[m](); if ("function" != typeof e.subscribe) throw new TypeError("Provided object does not correctly implement Symbol.observable"); return e.subscribe(t) }; if (R(t)) return D(t); if (M(t)) return (t => e => (t.then(t => { e.closed || (e.next(t), e.complete()) }, t => e.error(t)).then(null, o), e))(t); if (t && "function" == typeof t[O]) return e = t, t => { const i = e[O](); for (; ;) { let e; try { e = i.next() } catch (n) { return t.error(n), t } if (e.done) { t.complete(); break } if (t.next(e.value), t.closed) break } return "function" == typeof i.return && t.add(() => { i.return && i.return() }), t }; { const e = c(t) ? "an invalid object" : `'${t}'`; throw new TypeError(`You provided ${e} where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.`) } var e, i }; function L(t, e) { return new v(i => { const n = new u; let s = 0; return n.add(e.schedule(function () { s !== t.length ? (i.next(t[s++]), i.closed || n.add(this.schedule())) : i.complete() })), n }) } function F(t, e) { return e ? function (t, e) { if (null != t) { if (function (t) { return t && "function" == typeof t[m] }(t)) return function (t, e) { return new v(i => { const n = new u; return n.add(e.schedule(() => { const s = t[m](); n.add(s.subscribe({ next(t) { n.add(e.schedule(() => i.next(t))) }, error(t) { n.add(e.schedule(() => i.error(t))) }, complete() { n.add(e.schedule(() => i.complete())) } })) })), n }) }(t, e); if (M(t)) return function (t, e) { return new v(i => { const n = new u; return n.add(e.schedule(() => t.then(t => { n.add(e.schedule(() => { i.next(t), n.add(e.schedule(() => i.complete())) })) }, t => { n.add(e.schedule(() => i.error(t))) }))), n }) }(t, e); if (R(t)) return L(t, e); if (function (t) { return t && "function" == typeof t[O] }(t) || "string" == typeof t) return function (t, e) { if (!t) throw new Error("Iterable cannot be null"); return new v(i => { const n = new u; let s; return n.add(() => { s && "function" == typeof s.return && s.return() }), n.add(e.schedule(() => { s = t[O](), n.add(e.schedule(function () { if (i.closed) return; let t, e; try { const i = s.next(); t = i.value, e = i.done } catch (n) { return void i.error(n) } e ? i.complete() : (i.next(t), this.schedule()) })) })), n }) }(t, e) } throw new TypeError((null !== t && typeof t || t) + " is not observable") }(t, e) : t instanceof v ? t : new v(I(t)) } class N extends f { constructor(t) { super(), this.parent = t } _next(t) { this.parent.notifyNext(t) } _error(t) { this.parent.notifyError(t), this.unsubscribe() } _complete() { this.parent.notifyComplete(), this.unsubscribe() } } class j extends f { notifyNext(t) { this.destination.next(t) } notifyError(t) { this.destination.error(t) } notifyComplete() { this.destination.complete() } } function V(t, e) { if (e.closed) return; if (t instanceof v) return t.subscribe(e); let i; try { i = I(t)(e) } catch (n) { e.error(n) } return i } function B(t, e, i = Number.POSITIVE_INFINITY) { return "function" == typeof e ? n => n.pipe(B((i, n) => F(t(i, n)).pipe(E((t, s) => e(i, t, n, s))), i)) : ("number" == typeof e && (i = e), e => e.lift(new H(t, i))) } class H { constructor(t, e = Number.POSITIVE_INFINITY) { this.project = t, this.concurrent = e } call(t, e) { return e.subscribe(new z(t, this.project, this.concurrent)) } } class z extends j { constructor(t, e, i = Number.POSITIVE_INFINITY) { super(t), this.project = e, this.concurrent = i, this.hasCompleted = !1, this.buffer = [], this.active = 0, this.index = 0 } _next(t) { this.active < this.concurrent ? this._tryNext(t) : this.buffer.push(t) } _tryNext(t) { let e; const i = this.index++; try { e = this.project(t, i) } catch (n) { return void this.destination.error(n) } this.active++, this._innerSub(e) } _innerSub(t) { const e = new N(this), i = this.destination; i.add(e); const n = V(t, e); n !== e && i.add(n) } _complete() { this.hasCompleted = !0, 0 === this.active && 0 === this.buffer.length && this.destination.complete(), this.unsubscribe() } notifyNext(t) { this.destination.next(t) } notifyComplete() { const t = this.buffer; this.active--, t.length > 0 ? this._next(t.shift()) : 0 === this.active && this.hasCompleted && this.destination.complete() } } function U(t = Number.POSITIVE_INFINITY) { return B(_, t) } function W(t, e) { return e ? L(t, e) : new v(D(t)) } function q(...t) { let e = Number.POSITIVE_INFINITY, i = null, n = t[t.length - 1]; return C(n) ? (i = t.pop(), t.length > 1 && "number" == typeof t[t.length - 1] && (e = t.pop())) : "number" == typeof n && (e = t.pop()), null === i && 1 === t.length && t[0] instanceof v ? t[0] : U(e)(W(t, i)) } function G() { return function (t) { return t.lift(new Z(t)) } } class Z { constructor(t) { this.connectable = t } call(t, e) { const { connectable: i } = this; i._refCount++; const n = new K(t, i), s = e.subscribe(n); return n.closed || (n.connection = i.connect()), s } } class K extends f { constructor(t, e) { super(t), this.connectable = e } _unsubscribe() { const { connectable: t } = this; if (!t) return void (this.connection = null); this.connectable = null; const e = t._refCount; if (e <= 0) return void (this.connection = null); if (t._refCount = e - 1, e > 1) return void (this.connection = null); const { connection: i } = this, n = t._connection; this.connection = null, !n || i && n !== i || n.unsubscribe() } } class Y extends v { constructor(t, e) { super(), this.source = t, this.subjectFactory = e, this._refCount = 0, this._isComplete = !1 } _subscribe(t) { return this.getSubject().subscribe(t) } getSubject() { const t = this._subject; return t && !t.isStopped || (this._subject = this.subjectFactory()), this._subject } connect() { let t = this._connection; return t || (this._isComplete = !1, t = this._connection = new u, t.add(this.source.subscribe(new X(this.getSubject(), this))), t.closed && (this._connection = null, t = u.EMPTY)), t } refCount() { return G()(this) } } const Q = (() => { const t = Y.prototype; return { operator: { value: null }, _refCount: { value: 0, writable: !0 }, _subject: { value: null, writable: !0 }, _connection: { value: null, writable: !0 }, _subscribe: { value: t._subscribe }, _isComplete: { value: t._isComplete, writable: !0 }, getSubject: { value: t.getSubject }, connect: { value: t.connect }, refCount: { value: t.refCount } } })(); class X extends x { constructor(t, e) { super(t), this.connectable = e } _error(t) { this._unsubscribe(), super._error(t) } _complete() { this.connectable._isComplete = !0, this._unsubscribe(), super._complete() } _unsubscribe() { const t = this.connectable; if (t) { this.connectable = null; const e = t._connection; t._refCount = 0, t._subject = null, t._connection = null, e && e.unsubscribe() } } } function J() { return new S } function tt(t) { for (let e in t) if (t[e] === tt) return e; throw Error("Could not find renamed property on target object.") } function et(t, e) { for (const i in e) e.hasOwnProperty(i) && !t.hasOwnProperty(i) && (t[i] = e[i]) } function it(t) { if ("string" == typeof t) return t; if (Array.isArray(t)) return "[" + t.map(it).join(", ") + "]"; if (null == t) return "" + t; if (t.overriddenName) return `${t.overriddenName}`; if (t.name) return `${t.name}`; const e = t.toString(); if (null == e) return "" + e; const i = e.indexOf("\n"); return -1 === i ? e : e.substring(0, i) } function nt(t, e) { return null == t || "" === t ? null === e ? "" : e : null == e || "" === e ? t : t + " " + e } const st = tt({ __forward_ref__: tt }); function rt(t) { return t.__forward_ref__ = rt, t.toString = function () { return it(this()) }, t } function ot(t) { return at(t) ? t() : t } function at(t) { return "function" == typeof t && t.hasOwnProperty(st) && t.__forward_ref__ === rt } class lt extends Error { constructor(t, e) { super(function (t, e) { return `${t ? `NG0${t}: ` : ""}${e}` }(t, e)), this.code = t } } function ct(t) { return "string" == typeof t ? t : null == t ? "" : String(t) } function ht(t) { return "function" == typeof t ? t.name || t.toString() : "object" == typeof t && null != t && "function" == typeof t.type ? t.type.name || t.type.toString() : ct(t) } function ut(t, e) { const i = e ? ` in ${e}` : ""; throw new lt("201", `No provider for ${ht(t)} found${i}`) } function dt(t) { return { token: t.token, providedIn: t.providedIn || null, factory: t.factory, value: void 0 } } function pt(t) { return { providers: t.providers || [], imports: t.imports || [] } } function ft(t) { return gt(t, _t) || gt(t, yt) } function gt(t, e) { return t.hasOwnProperty(e) ? t[e] : null } function mt(t) { return t && (t.hasOwnProperty(vt) || t.hasOwnProperty(bt)) ? t[vt] : null } const _t = tt({ "\u0275prov": tt }), vt = tt({ "\u0275inj": tt }), yt = tt({ ngInjectableDef: tt }), bt = tt({ ngInjectorDef: tt }); var wt = function (t) { return t[t.Default = 0] = "Default", t[t.Host = 1] = "Host", t[t.Self = 2] = "Self", t[t.SkipSelf = 4] = "SkipSelf", t[t.Optional = 8] = "Optional", t }({}); let xt; function St(t) { const e = xt; return xt = t, e } function kt(t, e, i) { const n = ft(t); return n && "root" == n.providedIn ? void 0 === n.value ? n.value = n.factory() : n.value : i & wt.Optional ? null : void 0 !== e ? e : void ut(it(t), "Injector") } function Ct(t) { return { toString: t }.toString() } var Et = function (t) { return t[t.OnPush = 0] = "OnPush", t[t.Default = 1] = "Default", t }({}), Tt = function (t) { return t[t.Emulated = 0] = "Emulated", t[t.None = 2] = "None", t[t.ShadowDom = 3] = "ShadowDom", t }({}); const Pt = "undefined" != typeof globalThis && globalThis, Dt = "undefined" != typeof window && window, At = "undefined" != typeof self && "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && self, Ot = "undefined" != typeof global && global, Rt = Pt || Ot || Dt || At, Mt = {}, It = [], Lt = tt({ "\u0275cmp": tt }), Ft = tt({ "\u0275dir": tt }), Nt = tt({ "\u0275pipe": tt }), jt = tt({ "\u0275mod": tt }), Vt = tt({ "\u0275loc": tt }), Bt = tt({ "\u0275fac": tt }), Ht = tt({ __NG_ELEMENT_ID__: tt }); let zt = 0; function $t(t) { return Ct(() => { const e = {}, i = { type: t.type, providersResolver: null, decls: t.decls, vars: t.vars, factory: null, template: t.template || null, consts: t.consts || null, ngContentSelectors: t.ngContentSelectors, hostBindings: t.hostBindings || null, hostVars: t.hostVars || 0, hostAttrs: t.hostAttrs || null, contentQueries: t.contentQueries || null, declaredInputs: e, inputs: null, outputs: null, exportAs: t.exportAs || null, onPush: t.changeDetection === Et.OnPush, directiveDefs: null, pipeDefs: null, selectors: t.selectors || It, viewQuery: t.viewQuery || null, features: t.features || null, data: t.data || {}, encapsulation: t.encapsulation || Tt.Emulated, id: "c", styles: t.styles || It, _: null, setInput: null, schemas: t.schemas || null, tView: null }, n = t.directives, s = t.features, r = t.pipes; return i.id += zt++, i.inputs = Zt(t.inputs, e), i.outputs = Zt(t.outputs), s && s.forEach(t => t(i)), i.directiveDefs = n ? () => ("function" == typeof n ? n() : n).map(Ut) : null, i.pipeDefs = r ? () => ("function" == typeof r ? r() : r).map(Wt) : null, i }) } function Ut(t) { return Yt(t) || function (t) { return t[Ft] || null }(t) } function Wt(t) { return function (t) { return t[Nt] || null }(t) } const qt = {}; function Gt(t) { return Ct(() => { const e = { type: t.type, bootstrap: t.bootstrap || It, declarations: t.declarations || It, imports: t.imports || It, exports: t.exports || It, transitiveCompileScopes: null, schemas: t.schemas || null, id: t.id || null }; return null != t.id && (qt[t.id] = t.type), e }) } function Zt(t, e) { if (null == t) return Mt; const i = {}; for (const n in t) if (t.hasOwnProperty(n)) { let s = t[n], r = s; Array.isArray(s) && (r = s[1], s = s[0]), i[s] = n, e && (e[s] = r) } return i } const Kt = $t; function Yt(t) { return t[Lt] || null } function Qt(t, e) { const i = t[jt] || null; if (!i && !0 === e) throw new Error(`Type ${it(t)} does not have '\u0275mod' property.`); return i } const Xt = 20, Jt = 10; function te(t) { return Array.isArray(t) && "object" == typeof t[1] } function ee(t) { return Array.isArray(t) && !0 === t[1] } function ie(t) { return 0 != (8 & t.flags) } function ne(t) { return 2 == (2 & t.flags) } function se(t) { return 1 == (1 & t.flags) } function re(t) { return null !== t.template } function oe(t, e) { return t.hasOwnProperty(Bt) ? t[Bt] : null } class ae { constructor(t, e, i) { this.previousValue = t, this.currentValue = e, this.firstChange = i } isFirstChange() { return this.firstChange } } function le() { return ce } function ce(t) { return t.type.prototype.ngOnChanges && (t.setInput = ue), he } function he() { const t = de(this), e = null == t ? void 0 : t.current; if (e) { const i = t.previous; if (i === Mt) t.previous = e; else for (let t in e) i[t] = e[t]; t.current = null, this.ngOnChanges(e) } } function ue(t, e, i, n) { const s = de(t) || function (t, e) { return t.__ngSimpleChanges__ = e }(t, { previous: Mt, current: null }), r = s.current || (s.current = {}), o = s.previous, a = this.declaredInputs[i], l = o[a]; r[a] = new ae(l && l.currentValue, e, o === Mt), t[n] = e } function de(t) { return t.__ngSimpleChanges__ || null } le.ngInherit = !0; const pe = "http://www.w3.org/2000/svg"; let fe; function ge(t) { return !!t.listen } const me = { createRenderer: (t, e) => void 0 !== fe ? fe : "undefined" != typeof document ? document : void 0 }; function _e(t) { for (; Array.isArray(t);)t = t[0]; return t } function ve(t, e) { return _e(e[t]) } function ye(t, e) { return _e(e[t.index]) } function be(t, e) { return t.data[e] } function we(t, e) { const i = e[t]; return te(i) ? i : i[0] } function xe(t) { return 4 == (4 & t[2]) } function Se(t) { return 128 == (128 & t[2]) } function ke(t, e) { return null == e ? null : t[e] } function Ce(t) { t[18] = 0 } function Ee(t, e) { t[5] += e; let i = t, n = t[3]; for (; null !== n && (1 === e && 1 === i[5] || -1 === e && 0 === i[5]);)n[5] += e, i = n, n = n[3] } const Te = { lFrame: Qe(null), bindingsEnabled: !0, isInCheckNoChangesMode: !1 }; function Pe() { return Te.bindingsEnabled } function De() { return Te.lFrame.lView } function Ae() { return Te.lFrame.tView } function Oe(t) { return Te.lFrame.contextLView = t, t[8] } function Re() { let t = Me(); for (; null !== t && 64 === t.type;)t = t.parent; return t } function Me() { return Te.lFrame.currentTNode } function Ie(t, e) { const i = Te.lFrame; i.currentTNode = t, i.isParent = e } function Le() { return Te.lFrame.isParent } function Fe() { Te.lFrame.isParent = !1 } function Ne() { return Te.isInCheckNoChangesMode } function je(t) { Te.isInCheckNoChangesMode = t } function Ve() { const t = Te.lFrame; let e = t.bindingRootIndex; return -1 === e && (e = t.bindingRootIndex = t.tView.bindingStartIndex), e } function Be() { return Te.lFrame.bindingIndex++ } function He(t) { const e = Te.lFrame, i = e.bindingIndex; return e.bindingIndex = e.bindingIndex + t, i } function ze(t, e) { const i = Te.lFrame; i.bindingIndex = i.bindingRootIndex = t, $e(e) } function $e(t) { Te.lFrame.currentDirectiveIndex = t } function Ue(t) { const e = Te.lFrame.currentDirectiveIndex; return -1 === e ? null : t[e] } function We() { return Te.lFrame.currentQueryIndex } function qe(t) { Te.lFrame.currentQueryIndex = t } function Ge(t) { const e = t[1]; return 2 === e.type ? e.declTNode : 1 === e.type ? t[6] : null } function Ze(t, e, i) { if (i & wt.SkipSelf) { let n = e, s = t; for (; n = n.parent, !(null !== n || i & wt.Host || (n = Ge(s), null === n) || (s = s[15], 10 & n.type));); if (null === n) return !1; e = n, t = s } const n = Te.lFrame = Ye(); return n.currentTNode = e, n.lView = t, !0 } function Ke(t) { const e = Ye(), i = t[1]; Te.lFrame = e, e.currentTNode = i.firstChild, e.lView = t, e.tView = i, e.contextLView = t, e.bindingIndex = i.bindingStartIndex, e.inI18n = !1 } function Ye() { const t = Te.lFrame, e = null === t ? null : t.child; return null === e ? Qe(t) : e } function Qe(t) { const e = { currentTNode: null, isParent: !0, lView: null, tView: null, selectedIndex: -1, contextLView: null, elementDepthCount: 0, currentNamespace: null, currentDirectiveIndex: -1, bindingRootIndex: -1, bindingIndex: -1, currentQueryIndex: 0, parent: t, child: null, inI18n: !1 }; return null !== t && (t.child = e), e } function Xe() { const t = Te.lFrame; return Te.lFrame = t.parent, t.currentTNode = null, t.lView = null, t } const Je = Xe; function ti() { const t = Xe(); t.isParent = !0, t.tView = null, t.selectedIndex = -1, t.contextLView = null, t.elementDepthCount = 0, t.currentDirectiveIndex = -1, t.currentNamespace = null, t.bindingRootIndex = -1, t.bindingIndex = -1, t.currentQueryIndex = 0 } function ei() { return Te.lFrame.selectedIndex } function ii(t) { Te.lFrame.selectedIndex = t } function ni() { const t = Te.lFrame; return be(t.tView, t.selectedIndex) } function si() { Te.lFrame.currentNamespace = pe } function ri() { Te.lFrame.currentNamespace = null } function oi(t, e) { for (let i = e.directiveStart, n = e.directiveEnd; i < n; i++) { const e = t.data[i].type.prototype, { ngAfterContentInit: n, ngAfterContentChecked: s, ngAfterViewInit: r, ngAfterViewChecked: o, ngOnDestroy: a } = e; n && (t.contentHooks || (t.contentHooks = [])).push(-i, n), s && ((t.contentHooks || (t.contentHooks = [])).push(i, s), (t.contentCheckHooks || (t.contentCheckHooks = [])).push(i, s)), r && (t.viewHooks || (t.viewHooks = [])).push(-i, r), o && ((t.viewHooks || (t.viewHooks = [])).push(i, o), (t.viewCheckHooks || (t.viewCheckHooks = [])).push(i, o)), null != a && (t.destroyHooks || (t.destroyHooks = [])).push(i, a) } } function ai(t, e, i) { hi(t, e, 3, i) } function li(t, e, i, n) { (3 & t[2]) === i && hi(t, e, i, n) } function ci(t, e) { let i = t[2]; (3 & i) === e && (i &= 2047, i += 1, t[2] = i) } function hi(t, e, i, n) { const s = null != n ? n : -1, r = e.length - 1; let o = 0; for (let a = void 0 !== n ? 65535 & t[18] : 0; a < r; a++)if ("number" == typeof e[a + 1]) { if (o = e[a], null != n && o >= n) break } else e[a] < 0 && (t[18] += 65536), (o < s || -1 == s) && (ui(t, i, e, a), t[18] = (4294901760 & t[18]) + a + 2), a++ } function ui(t, e, i, n) { const s = i[n] < 0, r = i[n + 1], o = t[s ? -i[n] : i[n]]; if (s) { if (t[2] >> 11 < t[18] >> 16 && (3 & t[2]) === e) { t[2] += 2048; try { r.call(o) } finally { } } } else try { r.call(o) } finally { } } const di = -1; class pi { constructor(t, e, i) { this.factory = t, this.resolving = !1, this.canSeeViewProviders = e, this.injectImpl = i } } function fi(t, e, i) { const n = ge(t); let s = 0; for (; s < i.length;) { const r = i[s]; if ("number" == typeof r) { if (0 !== r) break; s++; const o = i[s++], a = i[s++], l = i[s++]; n ? t.setAttribute(e, a, l, o) : e.setAttributeNS(o, a, l) } else { const o = r, a = i[++s]; mi(o) ? n && t.setProperty(e, o, a) : n ? t.setAttribute(e, o, a) : e.setAttribute(o, a), s++ } } return s } function gi(t) { return 3 === t || 4 === t || 6 === t } function mi(t) { return 64 === t.charCodeAt(0) } function _i(t, e) { if (null === e || 0 === e.length); else if (null === t || 0 === t.length) t = e.slice(); else { let i = -1; for (let n = 0; n < e.length; n++) { const s = e[n]; "number" == typeof s ? i = s : 0 === i || vi(t, i, s, null, -1 === i || 2 === i ? e[++n] : null) } } return t } function vi(t, e, i, n, s) { let r = 0, o = t.length; if (-1 === e) o = -1; else for (; r < t.length;) { const i = t[r++]; if ("number" == typeof i) { if (i === e) { o = -1; break } if (i > e) { o = r - 1; break } } } for (; r < t.length;) { const e = t[r]; if ("number" == typeof e) break; if (e === i) { if (null === n) return void (null !== s && (t[r + 1] = s)); if (n === t[r + 1]) return void (t[r + 2] = s) } r++, null !== n && r++, null !== s && r++ } -1 !== o && (t.splice(o, 0, e), r = o + 1), t.splice(r++, 0, i), null !== n && t.splice(r++, 0, n), null !== s && t.splice(r++, 0, s) } function yi(t) { return t !== di } function bi(t) { return 32767 & t } function wi(t, e) { let i = t >> 16, n = e; for (; i > 0;)n = n[15], i--; return n } let xi = !0; function Si(t) { const e = xi; return xi = t, e } let ki = 0; function Ci(t, e) { const i = Ti(t, e); if (-1 !== i) return i; const n = e[1]; n.firstCreatePass && (t.injectorIndex = e.length, Ei(n.data, t), Ei(e, null), Ei(n.blueprint, null)); const s = Pi(t, e), r = t.injectorIndex; if (yi(s)) { const t = bi(s), i = wi(s, e), n = i[1].data; for (let s = 0; s < 8; s++)e[r + s] = i[t + s] | n[t + s] } return e[r + 8] = s, r } function Ei(t, e) { t.push(0, 0, 0, 0, 0, 0, 0, 0, e) } function Ti(t, e) { return -1 === t.injectorIndex || t.parent && t.parent.injectorIndex === t.injectorIndex || null === e[t.injectorIndex + 8] ? -1 : t.injectorIndex } function Pi(t, e) { if (t.parent && -1 !== t.parent.injectorIndex) return t.parent.injectorIndex; let i = 0, n = null, s = e; for (; null !== s;) { const t = s[1], e = t.type; if (n = 2 === e ? t.declTNode : 1 === e ? s[6] : null, null === n) return di; if (i++, s = s[15], -1 !== n.injectorIndex) return n.injectorIndex | i << 16 } return di } function Di(t, e, i) { !function (t, e, i) { let n; "string" == typeof i ? n = i.charCodeAt(0) || 0 : i.hasOwnProperty(Ht) && (n = i[Ht]), null == n && (n = i[Ht] = ki++); const s = 255 & n; e.data[t + (s >> 5)] |= 1 << s }(t, e, i) } function Ai(t, e, i) { if (i & wt.Optional) return t; ut(e, "NodeInjector") } function Oi(t, e, i, n) { if (i & wt.Optional && void 0 === n && (n = null), 0 == (i & (wt.Self | wt.Host))) { const s = t[9], r = St(void 0); try { return s ? s.get(e, n, i & wt.Optional) : kt(e, n, i & wt.Optional) } finally { St(r) } } return Ai(n, e, i) } function Ri(t, e, i, n = wt.Default, s) { if (null !== t) { const r = function (t) { if ("string" == typeof t) return t.charCodeAt(0) || 0; const e = t.hasOwnProperty(Ht) ? t[Ht] : void 0; return "number" == typeof e ? e >= 0 ? 255 & e : Ii : e }(i); if ("function" == typeof r) { if (!Ze(e, t, n)) return n & wt.Host ? Ai(s, i, n) : Oi(e, i, n, s); try { const t = r(n); if (null != t || n & wt.Optional) return t; ut(i) } finally { Je() } } else if ("number" == typeof r) { let s = null, o = Ti(t, e), a = di, l = n & wt.Host ? e[16][6] : null; for ((-1 === o || n & wt.SkipSelf) && (a = -1 === o ? Pi(t, e) : e[o + 8], a !== di && Vi(n, !1) ? (s = e[1], o = bi(a), e = wi(a, e)) : o = -1); -1 !== o;) { const t = e[1]; if (ji(r, o, t.data)) { const t = Li(o, e, i, s, n, l); if (t !== Mi) return t } a = e[o + 8], a !== di && Vi(n, e[1].data[o + 8] === l) && ji(r, o, e) ? (s = t, o = bi(a), e = wi(a, e)) : o = -1 } } } return Oi(e, i, n, s) } const Mi = {}; function Ii() { return new Bi(Re(), De()) } function Li(t, e, i, n, s, r) { const o = e[1], a = o.data[t + 8], l = Fi(a, o, i, null == n ? ne(a) && xi : n != o && 0 != (3 & a.type), s & wt.Host && r === a); return null !== l ? Ni(e, o, l, a) : Mi } function Fi(t, e, i, n, s) { const r = t.providerIndexes, o = e.data, a = 1048575 & r, l = t.directiveStart, c = r >> 20, h = s ? a + c : t.directiveEnd; for (let u = n ? a : a + c; u < h; u++) { const t = o[u]; if (u < l && i === t || u >= l && t.type === i) return u } if (s) { const t = o[l]; if (t && re(t) && t.type === i) return l } return null } function Ni(t, e, i, n) { let s = t[i]; const r = e.data; if (s instanceof pi) { const o = s; o.resolving && function (t, e) { throw new lt("200", `Circular dependency in DI detected for ${t}`) }(ht(r[i])); const a = Si(o.canSeeViewProviders); o.resolving = !0; const l = o.injectImpl ? St(o.injectImpl) : null; Ze(t, n, wt.Default); try { s = t[i] = o.factory(void 0, r, t, n), e.firstCreatePass && i >= n.directiveStart && function (t, e, i) { const { ngOnChanges: n, ngOnInit: s, ngDoCheck: r } = e.type.prototype; if (n) { const n = ce(e); (i.preOrderHooks || (i.preOrderHooks = [])).push(t, n), (i.preOrderCheckHooks || (i.preOrderCheckHooks = [])).push(t, n) } s && (i.preOrderHooks || (i.preOrderHooks = [])).push(0 - t, s), r && ((i.preOrderHooks || (i.preOrderHooks = [])).push(t, r), (i.preOrderCheckHooks || (i.preOrderCheckHooks = [])).push(t, r)) }(i, r[i], e) } finally { null !== l && St(l), Si(a), o.resolving = !1, Je() } } return s } function ji(t, e, i) { return !!(i[e + (t >> 5)] & 1 << t) } function Vi(t, e) { return !(t & wt.Self || t & wt.Host && e) } class Bi { constructor(t, e) { this._tNode = t, this._lView = e } get(t, e) { return Ri(this._tNode, this._lView, t, void 0, e) } } function Hi(t) { return Ct(() => { const e = t.prototype.constructor, i = e[Bt] || zi(e), n = Object.prototype; let s = Object.getPrototypeOf(t.prototype).constructor; for (; s && s !== n;) { const t = s[Bt] || zi(s); if (t && t !== i) return t; s = Object.getPrototypeOf(s) } return t => new t }) } function zi(t) { return at(t) ? () => { const e = zi(ot(t)); return e && e() } : oe(t) } const $i = "__parameters__"; function Ui(t, e, i) { return Ct(() => { const n = function (t) { return function (...e) { if (t) { const i = t(...e); for (const t in i) this[t] = i[t] } } }(e); function s(...t) { if (this instanceof s) return n.apply(this, t), this; const e = new s(...t); return i.annotation = e, i; function i(t, i, n) { const s = t.hasOwnProperty($i) ? t[$i] : Object.defineProperty(t, $i, { value: [] })[$i]; for (; s.length <= n;)s.push(null); return (s[n] = s[n] || []).push(e), t } } return i && (s.prototype = Object.create(i.prototype)), s.prototype.ngMetadataName = t, s.annotationCls = s, s }) } class Wi { constructor(t, e) { this._desc = t, this.ngMetadataName = "InjectionToken", this.\u0275prov = void 0, "number" == typeof e ? this.__NG_ELEMENT_ID__ = e : void 0 !== e && (this.\u0275prov = dt({ token: this, providedIn: e.providedIn || "root", factory: e.factory })) } toString() { return `InjectionToken ${this._desc}` } } const qi = new Wi("AnalyzeForEntryComponents"), Gi = Function; function Zi(t, e) { void 0 === e && (e = t); for (let i = 0; i < t.length; i++) { let n = t[i]; Array.isArray(n) ? (e === t && (e = t.slice(0, i)), Zi(n, e)) : e !== t && e.push(n) } return e } function Ki(t, e) { t.forEach(t => Array.isArray(t) ? Ki(t, e) : e(t)) } function Yi(t, e, i) { e >= t.length ? t.push(i) : t.splice(e, 0, i) } function Qi(t, e) { return e >= t.length - 1 ? t.pop() : t.splice(e, 1)[0] } function Xi(t, e) { const i = []; for (let n = 0; n < t; n++)i.push(e); return i } function Ji(t, e, i) { let n = en(t, e); return n >= 0 ? t[1 | n] = i : (n = ~n, function (t, e, i, n) { let s = t.length; if (s == e) t.push(i, n); else if (1 === s) t.push(n, t[0]), t[0] = i; else { for (s--, t.push(t[s - 1], t[s]); s > e;)t[s] = t[s - 2], s--; t[e] = i, t[e + 1] = n } }(t, n, e, i)), n } function tn(t, e) { const i = en(t, e); if (i >= 0) return t[1 | i] } function en(t, e) { return function (t, e, i) { let n = 0, s = t.length >> 1; for (; s !== n;) { const i = n + (s - n >> 1), r = t[i << 1]; if (e === r) return i << 1; r > e ? s = i : n = i + 1 } return ~(s << 1) }(t, e) } const nn = {}, sn = /\n/gm, rn = "__source", on = tt({ provide: String, useValue: tt }); let an; function ln(t) { const e = an; return an = t, e } function cn(t, e = wt.Default) { if (void 0 === an) throw new Error("inject() must be called from an injection context"); return null === an ? kt(t, void 0, e) : an.get(t, e & wt.Optional ? null : void 0, e) } function hn(t, e = wt.Default) { return (xt || cn)(ot(t), e) } const un = hn; function dn(t) { const e = []; for (let i = 0; i < t.length; i++) { const n = ot(t[i]); if (Array.isArray(n)) { if (0 === n.length) throw new Error("Arguments array must have arguments."); let t, i = wt.Default; for (let e = 0; e < n.length; e++) { const s = n[e], r = s.__NG_DI_FLAG__; "number" == typeof r ? -1 === r ? t = s.token : i |= r : t = s } e.push(hn(t, i)) } else e.push(hn(n)) } return e } function pn(t, e) { return t.__NG_DI_FLAG__ = e, t.prototype.__NG_DI_FLAG__ = e, t } const fn = pn(Ui("Inject", t => ({ token: t })), -1), gn = pn(Ui("Optional"), 8), mn = pn(Ui("SkipSelf"), 4); class _n { constructor(t) { this.changingThisBreaksApplicationSecurity = t } toString() { return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)` } } function vn(t) { return t instanceof _n ? t.changingThisBreaksApplicationSecurity : t } const yn = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi, bn = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i; var wn = function (t) { return t[t.NONE = 0] = "NONE", t[t.HTML = 1] = "HTML", t[t.STYLE = 2] = "STYLE", t[t.SCRIPT = 3] = "SCRIPT", t[t.URL = 4] = "URL", t[t.RESOURCE_URL = 5] = "RESOURCE_URL", t }({}); function xn(t) { const e = function () { const t = De(); return t && t[12] }(); return e ? e.sanitize(wn.URL, t) || "" : function (t, e) { const i = function (t) { return t instanceof _n && t.getTypeName() || null }(t); if (null != i && i !== e) { if ("ResourceURL" === i && "URL" === e) return !0; throw new Error(`Required a safe ${e}, got a ${i} (see https://g.co/ng/security#xss)`) } return i === e }(t, "URL") ? vn(t) : function (t) { return (t = String(t)).match(yn) || t.match(bn) ? t : "unsafe:" + t }(ct(t)) } function Sn(t, e) { t.__ngContext__ = e } function kn(t) { const e = function (t) { return t.__ngContext__ || null }(t); return e ? Array.isArray(e) ? e : e.lView : null } function Cn(t) { return t.ngDebugContext } function En(t) { return t.ngOriginalError } function Tn(t, ...e) { t.error(...e) } class Pn { constructor() { this._console = console } handleError(t) { const e = this._findOriginalError(t), i = this._findContext(t), n = function (t) { return t.ngErrorLogger || Tn }(t); n(this._console, "ERROR", t), e && n(this._console, "ORIGINAL ERROR", e), i && n(this._console, "ERROR CONTEXT", i) } _findContext(t) { return t ? Cn(t) ? Cn(t) : this._findContext(En(t)) : null } _findOriginalError(t) { let e = En(t); for (; e && En(e);)e = En(e); return e } } const Dn = (() => ("undefined" != typeof requestAnimationFrame && requestAnimationFrame || setTimeout).bind(Rt))(); function An(t) { return t.ownerDocument.defaultView } function On(t) { return t instanceof Function ? t() : t } var Rn = function (t) { return t[t.Important = 1] = "Important", t[t.DashCase = 2] = "DashCase", t }({}); function Mn(t, e) { return (void 0)(t, e) } function In(t) { const e = t[3]; return ee(e) ? e[3] : e } function Ln(t) { return Nn(t[13]) } function Fn(t) { return Nn(t[4]) } function Nn(t) { for (; null !== t && !ee(t);)t = t[4]; return t } function jn(t, e, i, n, s) { if (null != n) { let r, o = !1; ee(n) ? r = n : te(n) && (o = !0, n = n[0]); const a = _e(n); 0 === t && null !== i ? null == s ? qn(e, i, a) : Wn(e, i, a, s || null, !0) : 1 === t && null !== i ? Wn(e, i, a, s || null, !0) : 2 === t ? function (t, e, i) { const n = Zn(t, e); n && function (t, e, i, n) { ge(t) ? t.removeChild(e, i, n) : e.removeChild(i) }(t, n, e, i) }(e, a, o) : 3 === t && e.destroyNode(a), null != r && function (t, e, i, n, s) { const r = i[7]; r !== _e(i) && jn(e, t, n, r, s); for (let o = Jt; o < i.length; o++) { const s = i[o]; is(s[1], s, t, e, n, r) } }(e, t, r, i, s) } } function Vn(t, e, i) { return ge(t) ? t.createElement(e, i) : null === i ? t.createElement(e) : t.createElementNS(i, e) } function Bn(t, e) { const i = t[9], n = i.indexOf(e), s = e[3]; 1024 & e[2] && (e[2] &= -1025, Ee(s, -1)), i.splice(n, 1) } function Hn(t, e) { if (t.length <= Jt) return; const i = Jt + e, n = t[i]; if (n) { const r = n[17]; null !== r && r !== t && Bn(r, n), e > 0 && (t[i - 1][4] = n[4]); const o = Qi(t, Jt + e); is(n[1], s = n, s[11], 2, null, null), s[0] = null, s[6] = null; const a = o[19]; null !== a && a.detachView(o[1]), n[3] = null, n[4] = null, n[2] &= -129 } var s; return n } function zn(t, e) { if (!(256 & e[2])) { const i = e[11]; ge(i) && i.destroyNode && is(t, e, i, 3, null, null), function (t) { let e = t[13]; if (!e) return $n(t[1], t); for (; e;) { let i = null; if (te(e)) i = e[13]; else { const t = e[10]; t && (i = t) } if (!i) { for (; e && !e[4] && e !== t;)te(e) && $n(e[1], e), e = e[3]; null === e && (e = t), te(e) && $n(e[1], e), i = e && e[4] } e = i } }(e) } } function $n(t, e) { if (!(256 & e[2])) { e[2] &= -129, e[2] |= 256, function (t, e) { let i; if (null != t && null != (i = t.destroyHooks)) for (let n = 0; n < i.length; n += 2) { const t = e[i[n]]; if (!(t instanceof pi)) { const e = i[n + 1]; if (Array.isArray(e)) for (let i = 0; i < e.length; i += 2) { const n = t[e[i]], s = e[i + 1]; try { s.call(n) } finally { } } else try { e.call(t) } finally { } } } }(t, e), function (t, e) { const i = t.cleanup, n = e[7]; let s = -1; if (null !== i) for (let r = 0; r < i.length - 1; r += 2)if ("string" == typeof i[r]) { const t = i[r + 1], o = "function" == typeof t ? t(e) : _e(e[t]), a = n[s = i[r + 2]], l = i[r + 3]; "boolean" == typeof l ? o.removeEventListener(i[r], a, l) : l >= 0 ? n[s = l]() : n[s = -l].unsubscribe(), r += 2 } else { const t = n[s = i[r + 1]]; i[r].call(t) } if (null !== n) { for (let t = s + 1; t < n.length; t++)(0, n[t])(); e[7] = null } }(t, e), 1 === e[1].type && ge(e[11]) && e[11].destroy(); const i = e[17]; if (null !== i && ee(e[3])) { i !== e[3] && Bn(i, e); const n = e[19]; null !== n && n.detachView(t) } } } function Un(t, e, i) { return function (t, e, i) { let n = e; for (; null !== n && 40 & n.type;)n = (e = n).parent; if (null === n) return i[0]; if (2 & n.flags) { const e = t.data[n.directiveStart].encapsulation; if (e === Tt.None || e === Tt.Emulated) return null } return ye(n, i) }(t, e.parent, i) } function Wn(t, e, i, n, s) { ge(t) ? t.insertBefore(e, i, n, s) : e.insertBefore(i, n, s) } function qn(t, e, i) { ge(t) ? t.appendChild(e, i) : e.appendChild(i) } function Gn(t, e, i, n, s) { null !== n ? Wn(t, e, i, n, s) : qn(t, e, i) } function Zn(t, e) { return ge(t) ? t.parentNode(e) : e.parentNode } function Kn(t, e, i) { return Yn(t, e, i) } let Yn = function (t, e, i) { return 40 & t.type ? ye(t, i) : null }; function Qn(t, e, i, n) { const s = Un(t, n, e), r = e[11], o = Kn(n.parent || e[6], n, e); if (null != s) if (Array.isArray(i)) for (let a = 0; a < i.length; a++)Gn(r, s, i[a], o, !1); else Gn(r, s, i, o, !1) } function Xn(t, e) { if (null !== e) { const i = e.type; if (3 & i) return ye(e, t); if (4 & i) return ts(-1, t[e.index]); if (8 & i) { const i = e.child; if (null !== i) return Xn(t, i); { const i = t[e.index]; return ee(i) ? ts(-1, i) : _e(i) } } if (32 & i) return Mn(e, t)() || _e(t[e.index]); { const i = Jn(t, e); return null !== i ? Array.isArray(i) ? i[0] : Xn(In(t[16]), i) : Xn(t, e.next) } } return null } function Jn(t, e) { return null !== e ? t[16][6].projection[e.projection] : null } function ts(t, e) { const i = Jt + t + 1; if (i < e.length) { const t = e[i], n = t[1].firstChild; if (null !== n) return Xn(t, n) } return e[7] } function es(t, e, i, n, s, r, o) { for (; null != i;) { const a = n[i.index], l = i.type; if (o && 0 === e && (a && Sn(_e(a), n), i.flags |= 4), 64 != (64 & i.flags)) if (8 & l) es(t, e, i.child, n, s, r, !1), jn(e, t, s, a, r); else if (32 & l) { const o = Mn(i, n); let l; for (; l = o();)jn(e, t, s, l, r); jn(e, t, s, a, r) } else 16 & l ? ns(t, e, n, i, s, r) : jn(e, t, s, a, r); i = o ? i.projectionNext : i.next } } function is(t, e, i, n, s, r) { es(i, n, t.firstChild, e, s, r, !1) } function ns(t, e, i, n, s, r) { const o = i[16], a = o[6].projection[n.projection]; if (Array.isArray(a)) for (let l = 0; l < a.length; l++)jn(e, t, s, a[l], r); else es(t, e, a, o[3], s, r, !0) } function ss(t, e, i) { ge(t) ? t.setAttribute(e, "style", i) : e.style.cssText = i } function rs(t, e, i) { ge(t) ? "" === i ? t.removeAttribute(e, "class") : t.setAttribute(e, "class", i) : e.className = i } function os(t, e, i) { let n = t.length; for (; ;) { const s = t.indexOf(e, i); if (-1 === s) return s; if (0 === s || t.charCodeAt(s - 1) <= 32) { const i = e.length; if (s + i === n || t.charCodeAt(s + i) <= 32) return s } i = s + 1 } } const as = "ng-template"; function ls(t, e, i) { let n = 0; for (; n < t.length;) { let s = t[n++]; if (i && "class" === s) { if (s = t[n], -1 !== os(s.toLowerCase(), e, 0)) return !0 } else if (1 === s) { for (; n < t.length && "string" == typeof (s = t[n++]);)if (s.toLowerCase() === e) return !0; return !1 } } return !1 } function cs(t) { return 4 === t.type && t.value !== as } function hs(t, e, i) { return e === (4 !== t.type || i ? t.value : as) } function us(t, e, i) { let n = 4; const s = t.attrs || [], r = function (t) { for (let e = 0; e < t.length; e++)if (gi(t[e])) return e; return t.length }(s); let o = !1; for (let a = 0; a < e.length; a++) { const l = e[a]; if ("number" != typeof l) { if (!o) if (4 & n) { if (n = 2 | 1 & n, "" !== l && !hs(t, l, i) || "" === l && 1 === e.length) { if (ds(n)) return !1; o = !0 } } else { const c = 8 & n ? l : e[++a]; if (8 & n && null !== t.attrs) { if (!ls(t.attrs, c, i)) { if (ds(n)) return !1; o = !0 } continue } const h = ps(8 & n ? "class" : l, s, cs(t), i); if (-1 === h) { if (ds(n)) return !1; o = !0; continue } if ("" !== c) { let t; t = h > r ? "" : s[h + 1].toLowerCase(); const e = 8 & n ? t : null; if (e && -1 !== os(e, c, 0) || 2 & n && c !== t) { if (ds(n)) return !1; o = !0 } } } } else { if (!o && !ds(n) && !ds(l)) return !1; if (o && ds(l)) continue; o = !1, n = l | 1 & n } } return ds(n) || o } function ds(t) { return 0 == (1 & t) } function ps(t, e, i, n) { if (null === e) return -1; let s = 0; if (n || !i) { let i = !1; for (; s < e.length;) { const n = e[s]; if (n === t) return s; if (3 === n || 6 === n) i = !0; else { if (1 === n || 2 === n) { let t = e[++s]; for (; "string" == typeof t;)t = e[++s]; continue } if (4 === n) break; if (0 === n) { s += 4; continue } } s += i ? 1 : 2 } return -1 } return function (t, e) { let i = t.indexOf(4); if (i > -1) for (i++; i < t.length;) { const n = t[i]; if ("number" == typeof n) return -1; if (n === e) return i; i++ } return -1 }(e, t) } function fs(t, e, i = !1) { for (let n = 0; n < e.length; n++)if (us(t, e[n], i)) return !0; return !1 } function gs(t, e) { return t ? ":not(" + e.trim() + ")" : e } function ms(t) { let e = t[0], i = 1, n = 2, s = "", r = !1; for (; i < t.length;) { let o = t[i]; if ("string" == typeof o) if (2 & n) { const e = t[++i]; s += "[" + o + (e.length > 0 ? '="' + e + '"' : "") + "]" } else 8 & n ? s += "." + o : 4 & n && (s += " " + o); else "" === s || ds(o) || (e += gs(r, s), s = ""), n = o, r = r || !ds(n); i++ } return "" !== s && (e += gs(r, s)), e } const _s = {}; function vs(t) { ys(Ae(), De(), ei() + t, Ne()) } function ys(t, e, i, n) { if (!n) if (3 == (3 & e[2])) { const n = t.preOrderCheckHooks; null !== n && ai(e, n, i) } else { const n = t.preOrderHooks; null !== n && li(e, n, 0, i) } ii(i) } function bs(t, e) { return t << 17 | e << 2 } function ws(t) { return t >> 17 & 32767 } function xs(t) { return 2 | t } function Ss(t) { return (131068 & t) >> 2 } function ks(t, e) { return -131069 & t | e << 2 } function Cs(t) { return 1 | t } function Es(t, e) { const i = t.contentQueries; if (null !== i) for (let n = 0; n < i.length; n += 2) { const s = i[n], r = i[n + 1]; if (-1 !== r) { const i = t.data[r]; qe(s), i.contentQueries(2, e[r], r) } } } function Ts(t, e, i, n, s, r, o, a, l, c) { const h = e.blueprint.slice(); return h[0] = s, h[2] = 140 | n, Ce(h), h[3] = h[15] = t, h[8] = i, h[10] = o || t && t[10], h[11] = a || t && t[11], h[12] = l || t && t[12] || null, h[9] = c || t && t[9] || null, h[6] = r, h[16] = 2 == e.type ? t[16] : h, h } function Ps(t, e, i, n, s) { let r = t.data[e]; if (null === r) r = function (t, e, i, n, s) { const r = Me(), o = Le(), a = t.data[e] = function (t, e, i, n, s, r) { return { type: i, index: n, insertBeforeIndex: null, injectorIndex: e ? e.injectorIndex : -1, directiveStart: -1, directiveEnd: -1, directiveStylingLast: -1, propertyBindings: null, flags: 0, providerIndexes: 0, value: s, attrs: r, mergedAttrs: null, localNames: null, initialInputs: void 0, inputs: null, outputs: null, tViews: null, next: null, projectionNext: null, child: null, parent: e, projection: null, styles: null, stylesWithoutHost: null, residualStyles: void 0, classes: null, classesWithoutHost: null, residualClasses: void 0, classBindings: 0, styleBindings: 0 } }(0, o ? r : r && r.parent, i, e, n, s); return null === t.firstChild && (t.firstChild = a), null !== r && (o ? null == r.child && null !== a.parent && (r.child = a) : null === r.next && (r.next = a)), a }(t, e, i, n, s), Te.lFrame.inI18n && (r.flags |= 64); else if (64 & r.type) { r.type = i, r.value = n, r.attrs = s; const t = function () { const t = Te.lFrame, e = t.currentTNode; return t.isParent ? e : e.parent }(); r.injectorIndex = null === t ? -1 : t.injectorIndex } return Ie(r, !0), r } function Ds(t, e, i, n) { if (0 === i) return -1; const s = e.length; for (let r = 0; r < i; r++)e.push(n), t.blueprint.push(n), t.data.push(null); return s } function As(t, e, i) { Ke(e); try { const n = t.viewQuery; null !== n && rr(1, n, i); const s = t.template; null !== s && Ms(t, e, s, 1, i), t.firstCreatePass && (t.firstCreatePass = !1), t.staticContentQueries && Es(t, e), t.staticViewQueries && rr(2, t.viewQuery, i); const r = t.components; null !== r && function (t, e) { for (let i = 0; i < e.length; i++)tr(t, e[i]) }(e, r) } catch (n) { throw t.firstCreatePass && (t.incompleteFirstPass = !0), n } finally { e[2] &= -5, ti() } } function Os(t, e, i, n) { const s = e[2]; if (256 == (256 & s)) return; Ke(e); const r = Ne(); try { Ce(e), Te.lFrame.bindingIndex = t.bindingStartIndex, null !== i && Ms(t, e, i, 2, n); const o = 3 == (3 & s); if (!r) if (o) { const i = t.preOrderCheckHooks; null !== i && ai(e, i, null) } else { const i = t.preOrderHooks; null !== i && li(e, i, 0, null), ci(e, 0) } if (function (t) { for (let e = Ln(t); null !== e; e = Fn(e)) { if (!e[2]) continue; const t = e[9]; for (let e = 0; e < t.length; e++) { const i = t[e], n = i[3]; 0 == (1024 & i[2]) && Ee(n, 1), i[2] |= 1024 } } }(e), function (t) { for (let e = Ln(t); null !== e; e = Fn(e))for (let t = Jt; t < e.length; t++) { const i = e[t], n = i[1]; Se(i) && Os(n, i, n.template, i[8]) } }(e), null !== t.contentQueries && Es(t, e), !r) if (o) { const i = t.contentCheckHooks; null !== i && ai(e, i) } else { const i = t.contentHooks; null !== i && li(e, i, 1), ci(e, 1) } !function (t, e) { const i = t.hostBindingOpCodes; if (null !== i) try { for (let t = 0; t < i.length; t++) { const n = i[t]; if (n < 0) ii(~n); else { const s = n, r = i[++t], o = i[++t]; ze(r, s), o(2, e[s]) } } } finally { ii(-1) } }(t, e); const a = t.components; null !== a && function (t, e) { for (let i = 0; i < e.length; i++)Xs(t, e[i]) }(e, a); const l = t.viewQuery; if (null !== l && rr(2, l, n), !r) if (o) { const i = t.viewCheckHooks; null !== i && ai(e, i) } else { const i = t.viewHooks; null !== i && li(e, i, 2), ci(e, 2) } !0 === t.firstUpdatePass && (t.firstUpdatePass = !1), r || (e[2] &= -73), 1024 & e[2] && (e[2] &= -1025, Ee(e[3], -1)) } finally { ti() } } function Rs(t, e, i, n) { const s = e[10], r = !Ne(), o = xe(e); try { r && !o && s.begin && s.begin(), o && As(t, e, n), Os(t, e, i, n) } finally { r && !o && s.end && s.end() } } function Ms(t, e, i, n, s) { const r = ei(), o = 2 & n; try { ii(-1), o && e.length > Xt && ys(t, e, Xt, Ne()), i(n, s) } finally { ii(r) } } function Is(t, e, i) { Pe() && (function (t, e, i, n) { const s = i.directiveStart, r = i.directiveEnd; t.firstCreatePass || Ci(i, e), Sn(n, e); const o = i.initialInputs; for (let a = s; a < r; a++) { const n = t.data[a], r = re(n); r && Zs(e, i, n); const l = Ni(e, t, a, i); Sn(l, e), null !== o && Ks(0, a - s, l, n, 0, o), r && (we(i.index, e)[8] = l) } }(t, e, i, ye(i, e)), 128 == (128 & i.flags) && function (t, e, i) { const n = i.directiveStart, s = i.directiveEnd, r = i.index, o = Te.lFrame.currentDirectiveIndex; try { ii(r); for (let i = n; i < s; i++) { const n = t.data[i], s = e[i]; $e(i), null === n.hostBindings && 0 === n.hostVars && null === n.hostAttrs || $s(n, s) } } finally { ii(-1), $e(o) } }(t, e, i)) } function Ls(t, e, i = ye) { const n = e.localNames; if (null !== n) { let s = e.index + 1; for (let r = 0; r < n.length; r += 2) { const o = n[r + 1], a = -1 === o ? i(e, t) : t[o]; t[s++] = a } } } function Fs(t) { const e = t.tView; return null === e || e.incompleteFirstPass ? t.tView = Ns(1, null, t.template, t.decls, t.vars, t.directiveDefs, t.pipeDefs, t.viewQuery, t.schemas, t.consts) : e } function Ns(t, e, i, n, s, r, o, a, l, c) { const h = Xt + n, u = h + s, d = function (t, e) { const i = []; for (let n = 0; n < e; n++)i.push(n < t ? null : _s); return i }(h, u), p = "function" == typeof c ? c() : c; return d[1] = { type: t, blueprint: d, template: i, queries: null, viewQuery: a, declTNode: e, data: d.slice().fill(null, h), bindingStartIndex: h, expandoStartIndex: u, hostBindingOpCodes: null, firstCreatePass: !0, firstUpdatePass: !0, staticViewQueries: !1, staticContentQueries: !1, preOrderHooks: null, preOrderCheckHooks: null, contentHooks: null, contentCheckHooks: null, viewHooks: null, viewCheckHooks: null, destroyHooks: null, cleanup: null, contentQueries: null, components: null, directiveRegistry: "function" == typeof r ? r() : r, pipeRegistry: "function" == typeof o ? o() : o, firstChild: null, schemas: l, consts: p, incompleteFirstPass: !1 } } function js(t, e, i, n) { const s = ar(e); null === i ? s.push(n) : (s.push(i), t.firstCreatePass && lr(t).push(n, s.length - 1)) } function Vs(t, e, i) { for (let n in t) if (t.hasOwnProperty(n)) { const s = t[n]; (i = null === i ? {} : i).hasOwnProperty(n) ? i[n].push(e, s) : i[n] = [e, s] } return i } function Bs(t, e, i, n, s, r, o, a) { const l = ye(e, i); let c, h = e.inputs; var u; !a && null != h && (c = h[n]) ? (ur(t, i, c, n, s), ne(e) && function (t, e) { const i = we(e, t); 16 & i[2] || (i[2] |= 64) }(i, e.index)) : 3 & e.type && (n = "class" === (u = n) ? "className" : "for" === u ? "htmlFor" : "formaction" === u ? "formAction" : "innerHtml" === u ? "innerHTML" : "readonly" === u ? "readOnly" : "tabindex" === u ? "tabIndex" : u, s = null != o ? o(s, e.value || "", n) : s, ge(r) ? r.setProperty(l, n, s) : mi(n) || (l.setProperty ? l.setProperty(n, s) : l[n] = s)) } function Hs(t, e, i, n) { let s = !1; if (Pe()) { const r = function (t, e, i) { const n = t.directiveRegistry; let s = null; if (n) for (let r = 0; r < n.length; r++) { const o = n[r]; fs(i, o.selectors, !1) && (s || (s = []), Di(Ci(i, e), t, o.type), re(o) ? (Us(t, i), s.unshift(o)) : s.push(o)) } return s }(t, e, i), o = null === n ? null : { "": -1 }; if (null !== r) { s = !0, qs(i, t.data.length, r.length); for (let t = 0; t < r.length; t++) { const e = r[t]; e.providersResolver && e.providersResolver(e) } let n = !1, a = !1, l = Ds(t, e, r.length, null); for (let s = 0; s < r.length; s++) { const c = r[s]; i.mergedAttrs = _i(i.mergedAttrs, c.hostAttrs), Gs(t, i, e, l, c), Ws(l, c, o), null !== c.contentQueries && (i.flags |= 8), null === c.hostBindings && null === c.hostAttrs && 0 === c.hostVars || (i.flags |= 128); const h = c.type.prototype; !n && (h.ngOnChanges || h.ngOnInit || h.ngDoCheck) && ((t.preOrderHooks || (t.preOrderHooks = [])).push(i.index), n = !0), a || !h.ngOnChanges && !h.ngDoCheck || ((t.preOrderCheckHooks || (t.preOrderCheckHooks = [])).push(i.index), a = !0), l++ } !function (t, e) { const i = e.directiveEnd, n = t.data, s = e.attrs, r = []; let o = null, a = null; for (let l = e.directiveStart; l < i; l++) { const t = n[l], i = t.inputs, c = null === s || cs(e) ? null : Ys(i, s); r.push(c), o = Vs(i, l, o), a = Vs(t.outputs, l, a) } null !== o && (o.hasOwnProperty("class") && (e.flags |= 16), o.hasOwnProperty("style") && (e.flags |= 32)), e.initialInputs = r, e.inputs = o, e.outputs = a }(t, i) } o && function (t, e, i) { if (e) { const n = t.localNames = []; for (let t = 0; t < e.length; t += 2) { const s = i[e[t + 1]]; if (null == s) throw new lt("301", `Export of name '${e[t + 1]}' not found!`); n.push(e[t], s) } } }(i, n, o) } return i.mergedAttrs = _i(i.mergedAttrs, i.attrs), s } function zs(t, e, i, n, s, r) { const o = r.hostBindings; if (o) { let i = t.hostBindingOpCodes; null === i && (i = t.hostBindingOpCodes = []); const r = ~e.index; (function (t) { let e = t.length; for (; e > 0;) { const i = t[--e]; if ("number" == typeof i && i < 0) return i } return 0 })(i) != r && i.push(r), i.push(n, s, o) } } function $s(t, e) { null !== t.hostBindings && t.hostBindings(1, e) } function Us(t, e) { e.flags |= 2, (t.components || (t.components = [])).push(e.index) } function Ws(t, e, i) { if (i) { if (e.exportAs) for (let n = 0; n < e.exportAs.length; n++)i[e.exportAs[n]] = t; re(e) && (i[""] = t) } } function qs(t, e, i) { t.flags |= 1, t.directiveStart = e, t.directiveEnd = e + i, t.providerIndexes = e } function Gs(t, e, i, n, s) { t.data[n] = s; const r = s.factory || (s.factory = oe(s.type)), o = new pi(r, re(s), null); t.blueprint[n] = o, i[n] = o, zs(t, e, 0, n, Ds(t, i, s.hostVars, _s), s) } function Zs(t, e, i) { const n = ye(e, t), s = Fs(i), r = t[10], o = er(t, Ts(t, s, null, i.onPush ? 64 : 16, n, e, r, r.createRenderer(n, i), null, null)); t[e.index] = o } function Ks(t, e, i, n, s, r) { const o = r[e]; if (null !== o) { const t = n.setInput; for (let e = 0; e < o.length;) { const s = o[e++], r = o[e++], a = o[e++]; null !== t ? n.setInput(i, a, s, r) : i[r] = a } } } function Ys(t, e) { let i = null, n = 0; for (; n < e.length;) { const s = e[n]; if (0 !== s) if (5 !== s) { if ("number" == typeof s) break; t.hasOwnProperty(s) && (null === i && (i = []), i.push(s, t[s], e[n + 1])), n += 2 } else n += 2; else n += 4 } return i } function Qs(t, e, i, n) { return new Array(t, !0, !1, e, null, 0, n, i, null, null) } function Xs(t, e) { const i = we(e, t); if (Se(i)) { const t = i[1]; 80 & i[2] ? Os(t, i, t.template, i[8]) : i[5] > 0 && Js(i) } } function Js(t) { for (let i = Ln(t); null !== i; i = Fn(i))for (let t = Jt; t < i.length; t++) { const e = i[t]; if (1024 & e[2]) { const t = e[1]; Os(t, e, t.template, e[8]) } else e[5] > 0 && Js(e) } const e = t[1].components; if (null !== e) for (let i = 0; i < e.length; i++) { const n = we(e[i], t); Se(n) && n[5] > 0 && Js(n) } } function tr(t, e) { const i = we(e, t), n = i[1]; !function (t, e) { for (let i = e.length; i < t.blueprint.length; i++)e.push(t.blueprint[i]) }(n, i), As(n, i, i[8]) } function er(t, e) { return t[13] ? t[14][4] = e : t[13] = e, t[14] = e, e } function ir(t) { for (; t;) { t[2] |= 64; const e = In(t); if (0 != (512 & t[2]) && !e) return t; t = e } return null } function nr(t, e, i) { const n = e[10]; n.begin && n.begin(); try { Os(t, e, t.template, i) } catch (s) { throw hr(e, s), s } finally { n.end && n.end() } } function sr(t) { !function (t) { for (let e = 0; e < t.components.length; e++) { const i = t.components[e], n = kn(i), s = n[1]; Rs(s, n, s.template, i) } }(t[8]) } function rr(t, e, i) { qe(0), e(t, i) } const or = (() => Promise.resolve(null))(); function ar(t) { return t[7] || (t[7] = []) } function lr(t) { return t.cleanup || (t.cleanup = []) } function cr(t, e, i) { return (null === t || re(t)) && (i = function (t) { for (; Array.isArray(t);) { if ("object" == typeof t[1]) return t; t = t[0] } return null }(i[e.index])), i[11] } function hr(t, e) { const i = t[9], n = i ? i.get(Pn, null) : null; n && n.handleError(e) } function ur(t, e, i, n, s) { for (let r = 0; r < i.length;) { const o = i[r++], a = i[r++], l = e[o], c = t.data[o]; null !== c.setInput ? c.setInput(l, s, n, a) : l[a] = s } } function dr(t, e, i) { let n = i ? t.styles : null, s = i ? t.classes : null, r = 0; if (null !== e) for (let o = 0; o < e.length; o++) { const t = e[o]; "number" == typeof t ? r = t : 1 == r ? s = nt(s, t) : 2 == r && (n = nt(n, t + ": " + e[++o] + ";")) } i ? t.styles = n : t.stylesWithoutHost = n, i ? t.classes = s : t.classesWithoutHost = s } const pr = new Wi("INJECTOR", -1); class fr { get(t, e = nn) { if (e === nn) { const e = new Error(`NullInjectorError: No provider for ${it(t)}!`); throw e.name = "NullInjectorError", e } return e } } const gr = new Wi("Set Injector scope."), mr = {}, _r = {}; let vr; function yr() { return void 0 === vr && (vr = new fr), vr } function br(t, e = null, i = null, n) { return new wr(t, i, e || yr(), n) } class wr { constructor(t, e, i, n = null) { this.parent = i, this.records = new Map, this.injectorDefTypes = new Set, this.onDestroy = new Set, this._destroyed = !1; const s = []; e && Ki(e, i => this.processProvider(i, t, e)), Ki([t], t => this.processInjectorType(t, [], s)), this.records.set(pr, kr(void 0, this)); const r = this.records.get(gr); this.scope = null != r ? r.value : null, this.source = n || ("object" == typeof t ? null : it(t)) } get destroyed() { return this._destroyed } destroy() { this.assertNotDestroyed(), this._destroyed = !0; try { this.onDestroy.forEach(t => t.ngOnDestroy()) } finally { this.records.clear(), this.onDestroy.clear(), this.injectorDefTypes.clear() } } get(t, e = nn, i = wt.Default) { this.assertNotDestroyed(); const n = ln(this); try { if (!(i & wt.SkipSelf)) { let e = this.records.get(t); if (void 0 === e) { const i = ("function" == typeof (s = t) || "object" == typeof s && s instanceof Wi) && ft(t); e = i && this.injectableDefInScope(i) ? kr(xr(t), mr) : null, this.records.set(t, e) } if (null != e) return this.hydrate(t, e) } return (i & wt.Self ? yr() : this.parent).get(t, e = i & wt.Optional && e === nn ? null : e) } catch (r) { if ("NullInjectorError" === r.name) { if ((r.ngTempTokenPath = r.ngTempTokenPath || []).unshift(it(t)), n) throw r; return function (t, e, i, n) { const s = t.ngTempTokenPath; throw e[rn] && s.unshift(e[rn]), t.message = function (t, e, i, n = null) { t = t && "\n" === t.charAt(0) && "\u0275" == t.charAt(1) ? t.substr(2) : t; let s = it(e); if (Array.isArray(e)) s = e.map(it).join(" -> "); else if ("object" == typeof e) { let t = []; for (let i in e) if (e.hasOwnProperty(i)) { let n = e[i]; t.push(i + ":" + ("string" == typeof n ? JSON.stringify(n) : it(n))) } s = `{${t.join(", ")}}` } return `${i}${n ? "(" + n + ")" : ""}[${s}]: ${t.replace(sn, "\n  ")}` }("\n" + t.message, s, i, n), t.ngTokenPath = s, t.ngTempTokenPath = null, t }(r, t, "R3InjectorError", this.source) } throw r } finally { ln(n) } var s } _resolveInjectorDefTypes() { this.injectorDefTypes.forEach(t => this.get(t)) } toString() { const t = []; return this.records.forEach((e, i) => t.push(it(i))), `R3Injector[${t.join(", ")}]` } assertNotDestroyed() { if (this._destroyed) throw new Error("Injector has already been destroyed.") } processInjectorType(t, e, i) { if (!(t = ot(t))) return !1; let n = mt(t); const s = null == n && t.ngModule || void 0, r = void 0 === s ? t : s, o = -1 !== i.indexOf(r); if (void 0 !== s && (n = mt(s)), null == n) return !1; if (null != n.imports && !o) { let t; i.push(r); try { Ki(n.imports, n => { this.processInjectorType(n, e, i) && (void 0 === t && (t = []), t.push(n)) }) } finally { } if (void 0 !== t) for (let e = 0; e < t.length; e++) { const { ngModule: i, providers: n } = t[e]; Ki(n, t => this.processProvider(t, i, n || It)) } } this.injectorDefTypes.add(r); const a = oe(r) || (() => new r); this.records.set(r, kr(a, mr)); const l = n.providers; if (null != l && !o) { const e = t; Ki(l, t => this.processProvider(t, e, l)) } return void 0 !== s && void 0 !== t.providers } processProvider(t, e, i) { let n = Er(t = ot(t)) ? t : ot(t && t.provide); const s = function (t, e, i) { return Cr(t) ? kr(void 0, t.useValue) : kr(Sr(t), mr) }(t); if (Er(t) || !0 !== t.multi) this.records.get(n); else { let e = this.records.get(n); e || (e = kr(void 0, mr, !0), e.factory = () => dn(e.multi), this.records.set(n, e)), n = t, e.multi.push(t) } this.records.set(n, s) } hydrate(t, e) { var i; return e.value === mr && (e.value = _r, e.value = e.factory()), "object" == typeof e.value && e.value && null !== (i = e.value) && "object" == typeof i && "function" == typeof i.ngOnDestroy && this.onDestroy.add(e.value), e.value } injectableDefInScope(t) { if (!t.providedIn) return !1; const e = ot(t.providedIn); return "string" == typeof e ? "any" === e || e === this.scope : this.injectorDefTypes.has(e) } } function xr(t) { const e = ft(t), i = null !== e ? e.factory : oe(t); if (null !== i) return i; if (t instanceof Wi) throw new Error(`Token ${it(t)} is missing a \u0275prov definition.`); if (t instanceof Function) return function (t) { const e = t.length; if (e > 0) { const i = Xi(e, "?"); throw new Error(`Can't resolve all parameters for ${it(t)}: (${i.join(", ")}).`) } const i = function (t) { const e = t && (t[_t] || t[yt]); if (e) { const i = function (t) { if (t.hasOwnProperty("name")) return t.name; const e = ("" + t).match(/^function\s*([^\s(]+)/); return null === e ? "" : e[1] }(t); return console.warn(`DEPRECATED: DI is instantiating a token "${i}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${i}" class.`), e } return null }(t); return null !== i ? () => i.factory(t) : () => new t }(t); throw new Error("unreachable") } function Sr(t, e, i) { let n; if (Er(t)) { const e = ot(t); return oe(e) || xr(e) } if (Cr(t)) n = () => ot(t.useValue); else if ((s = t) && s.useFactory) n = () => t.useFactory(...dn(t.deps || [])); else if (function (t) { return !(!t || !t.useExisting) }(t)) n = () => hn(ot(t.useExisting)); else { const e = ot(t && (t.useClass || t.provide)); if (!function (t) { return !!t.deps }(t)) return oe(e) || xr(e); n = () => new e(...dn(t.deps)) } var s; return n } function kr(t, e, i = !1) { return { factory: t, value: e, multi: i ? [] : void 0 } } function Cr(t) { return null !== t && "object" == typeof t && on in t } function Er(t) { return "function" == typeof t } const Tr = function (t, e, i) { return function (t, e = null, i = null, n) { const s = br(t, e, i, n); return s._resolveInjectorDefTypes(), s }({ name: i }, e, t, i) }; let Pr = (() => { class t { static create(t, e) { return Array.isArray(t) ? Tr(t, e, "") : Tr(t.providers, t.parent, t.name || "") } } return t.THROW_IF_NOT_FOUND = nn, t.NULL = new fr, t.\u0275prov = dt({ token: t, providedIn: "any", factory: () => hn(pr) }), t.__NG_ELEMENT_ID__ = -1, t })(); function Dr(t, e) { oi(kn(t)[1], Re()) } function Ar(t) { let e = Object.getPrototypeOf(t.type.prototype).constructor, i = !0; const n = [t]; for (; e;) { let s; if (re(t)) s = e.\u0275cmp || e.\u0275dir; else { if (e.\u0275cmp) throw new Error("Directives cannot inherit Components"); s = e.\u0275dir } if (s) { if (i) { n.push(s); const e = t; e.inputs = Or(t.inputs), e.declaredInputs = Or(t.declaredInputs), e.outputs = Or(t.outputs); const i = s.hostBindings; i && Ir(t, i); const r = s.viewQuery, o = s.contentQueries; if (r && Rr(t, r), o && Mr(t, o), et(t.inputs, s.inputs), et(t.declaredInputs, s.declaredInputs), et(t.outputs, s.outputs), re(s) && s.data.animation) { const e = t.data; e.animation = (e.animation || []).concat(s.data.animation) } } const e = s.features; if (e) for (let n = 0; n < e.length; n++) { const s = e[n]; s && s.ngInherit && s(t), s === Ar && (i = !1) } } e = Object.getPrototypeOf(e) } !function (t) { let e = 0, i = null; for (let n = t.length - 1; n >= 0; n--) { const s = t[n]; s.hostVars = e += s.hostVars, s.hostAttrs = _i(s.hostAttrs, i = _i(i, s.hostAttrs)) } }(n) } function Or(t) { return t === Mt ? {} : t === It ? [] : t } function Rr(t, e) { const i = t.viewQuery; t.viewQuery = i ? (t, n) => { e(t, n), i(t, n) } : e } function Mr(t, e) { const i = t.contentQueries; t.contentQueries = i ? (t, n, s) => { e(t, n, s), i(t, n, s) } : e } function Ir(t, e) { const i = t.hostBindings; t.hostBindings = i ? (t, n) => { e(t, n), i(t, n) } : e } let Lr = null; function Fr() { if (!Lr) { const t = Rt.Symbol; if (t && t.iterator) Lr = t.iterator; else { const t = Object.getOwnPropertyNames(Map.prototype); for (let e = 0; e < t.length; ++e) { const i = t[e]; "entries" !== i && "size" !== i && Map.prototype[i] === Map.prototype.entries && (Lr = i) } } } return Lr } function Nr(t) { return !!jr(t) && (Array.isArray(t) || !(t instanceof Map) && Fr() in t) } function jr(t) { return null !== t && ("function" == typeof t || "object" == typeof t) } function Vr(t, e, i) { return t[e] = i } function Br(t, e, i) { return !Object.is(t[e], i) && (t[e] = i, !0) } function Hr(t, e, i, n) { const s = De(); return Br(s, Be(), e) && (Ae(), function (t, e, i, n, s, r) { const o = ye(t, e); !function (t, e, i, n, s, r, o) { if (null == r) ge(t) ? t.removeAttribute(e, s, i) : e.removeAttribute(s); else { const a = null == o ? ct(r) : o(r, n || "", s); ge(t) ? t.setAttribute(e, s, a, i) : i ? e.setAttributeNS(i, s, a) : e.setAttribute(s, a) } }(e[11], o, r, t.value, i, n, s) }(ni(), s, t, e, i, n)), Hr } function zr(t, e, i, n, s, r, o, a) { const l = De(), c = Ae(), h = t + Xt, u = c.firstCreatePass ? function (t, e, i, n, s, r, o, a, l) { const c = e.consts, h = Ps(e, t, 4, o || null, ke(c, a)); Hs(e, i, h, ke(c, l)), oi(e, h); const u = h.tViews = Ns(2, h, n, s, r, e.directiveRegistry, e.pipeRegistry, null, e.schemas, c); return null !== e.queries && (e.queries.template(e, h), u.queries = e.queries.embeddedTView(h)), h }(h, c, l, e, i, n, s, r, o) : c.data[h]; Ie(u, !1); const d = l[11].createComment(""); Qn(c, l, d, u), Sn(d, l), er(l, l[h] = Qs(d, l, d, u)), se(u) && Is(c, l, u), null != o && Ls(l, u, a) } function $r(t) { return function (t, e) { return t[e] }(Te.lFrame.contextLView, Xt + t) } function Ur(t, e = wt.Default) { const i = De(); return null === i ? hn(t, e) : Ri(Re(), i, ot(t), e) } function Wr(t, e, i) { const n = De(); return Br(n, Be(), e) && Bs(Ae(), ni(), n, t, e, n[11], i, !1), Wr } function qr(t, e, i, n, s) { const r = s ? "class" : "style"; ur(t, i, e.inputs[r], r, n) } function Gr(t, e, i, n) { const s = De(), r = Ae(), o = Xt + t, a = s[11], l = s[o] = Vn(a, e, Te.lFrame.currentNamespace), c = r.firstCreatePass ? function (t, e, i, n, s, r, o) { const a = e.consts, l = Ps(e, t, 2, s, ke(a, r)); return Hs(e, i, l, ke(a, o)), null !== l.attrs && dr(l, l.attrs, !1), null !== l.mergedAttrs && dr(l, l.mergedAttrs, !0), null !== e.queries && e.queries.elementStart(e, l), l }(o, r, s, 0, e, i, n) : r.data[o]; Ie(c, !0); const h = c.mergedAttrs; null !== h && fi(a, l, h); const u = c.classes; null !== u && rs(a, l, u); const d = c.styles; null !== d && ss(a, l, d), 64 != (64 & c.flags) && Qn(r, s, l, c), 0 === Te.lFrame.elementDepthCount && Sn(l, s), Te.lFrame.elementDepthCount++, se(c) && (Is(r, s, c), function (t, e, i) { if (ie(e)) { const n = e.directiveEnd; for (let s = e.directiveStart; s < n; s++) { const e = t.data[s]; e.contentQueries && e.contentQueries(1, i[s], s) } } }(r, c, s)), null !== n && Ls(s, c) } function Zr() { let t = Re(); Le() ? Fe() : (t = t.parent, Ie(t, !1)); const e = t; Te.lFrame.elementDepthCount--; const i = Ae(); i.firstCreatePass && (oi(i, t), ie(t) && i.queries.elementEnd(t)), null != e.classesWithoutHost && function (t) { return 0 != (16 & t.flags) }(e) && qr(i, e, De(), e.classesWithoutHost, !0), null != e.stylesWithoutHost && function (t) { return 0 != (32 & t.flags) }(e) && qr(i, e, De(), e.stylesWithoutHost, !1) } function Kr(t, e, i, n) { Gr(t, e, i, n), Zr() } function Yr() { return De() } function Qr(t) { return !!t && "function" == typeof t.then } const Xr = function (t) { return !!t && "function" == typeof t.subscribe }; function Jr(t, e, i, n) { const s = De(), r = Ae(), o = Re(); return eo(r, s, s[11], o, t, e, !!i, n), Jr } function to(t, e) { const i = Re(), n = De(), s = Ae(); return eo(s, n, cr(Ue(s.data), i, n), i, t, e, !1), to } function eo(t, e, i, n, s, r, o, a) { const l = se(n), c = t.firstCreatePass && lr(t), h = ar(e); let u = !0; if (3 & n.type || a) { const d = ye(n, e), p = a ? a(d) : d, f = h.length, g = a ? t => a(_e(t[n.index])) : n.index; if (ge(i)) { let o = null; if (!a && l && (o = function (t, e, i, n) { const s = t.cleanup; if (null != s) for (let r = 0; r < s.length - 1; r += 2) { const t = s[r]; if (t === i && s[r + 1] === n) { const t = e[7], i = s[r + 2]; return t.length > i ? t[i] : null } "string" == typeof t && (r += 2) } return null }(t, e, s, n.index)), null !== o) (o.__ngLastListenerFn__ || o).__ngNextListenerFn__ = r, o.__ngLastListenerFn__ = r, u = !1; else { r = no(n, e, 0, r, !1); const t = i.listen(p, s, r); h.push(r, t), c && c.push(s, g, f, f + 1) } } else r = no(n, e, 0, r, !0), p.addEventListener(s, r, o), h.push(r), c && c.push(s, g, f, o) } else r = no(n, e, 0, r, !1); const d = n.outputs; let p; if (u && null !== d && (p = d[s])) { const t = p.length; if (t) for (let i = 0; i < t; i += 2) { const t = e[p[i]][p[i + 1]].subscribe(r), o = h.length; h.push(r, t), c && c.push(s, n.index, o, -(o + 1)) } } } function io(t, e, i, n) { try { return !1 !== i(n) } catch (s) { return hr(t, s), !1 } } function no(t, e, i, n, s) { return function i(r) { if (r === Function) return n; const o = 2 & t.flags ? we(t.index, e) : e; 0 == (32 & e[2]) && ir(o); let a = io(e, 0, n, r), l = i.__ngNextListenerFn__; for (; l;)a = io(e, 0, l, r) && a, l = l.__ngNextListenerFn__; return s && !1 === a && (r.preventDefault(), r.returnValue = !1), a } } function so(t = 1) { return function (t) { return (Te.lFrame.contextLView = function (t, e) { for (; t > 0;)e = e[15], t--; return e }(t, Te.lFrame.contextLView))[8] }(t) } function ro(t, e, i, n, s) { const r = t[i + 1], o = null === e; let a = n ? ws(r) : Ss(r), l = !1; for (; 0 !== a && (!1 === l || o);) { const i = t[a + 1]; oo(t[a], e) && (l = !0, t[a + 1] = n ? Cs(i) : xs(i)), a = n ? ws(i) : Ss(i) } l && (t[i + 1] = n ? xs(r) : Cs(r)) } function oo(t, e) { return null === t || null == e || (Array.isArray(t) ? t[1] : t) === e || !(!Array.isArray(t) || "string" != typeof e) && en(t, e) >= 0 } const ao = { textEnd: 0, key: 0, keyEnd: 0, value: 0, valueEnd: 0 }; function lo(t) { return t.substring(ao.key, ao.keyEnd) } function co(t, e) { const i = ao.textEnd; return i === e ? -1 : (e = ao.keyEnd = function (t, e, i) { for (; e < i && t.charCodeAt(e) > 32;)e++; return e }(t, ao.key = e, i), ho(t, e, i)) } function ho(t, e, i) { for (; e < i && t.charCodeAt(e) <= 32;)e++; return e } function uo(t, e) { return function (t, e, i, n) { const s = De(), r = Ae(), o = He(2); r.firstUpdatePass && go(r, t, o, true), e !== _s && Br(s, o, e) && vo(r, r.data[ei()], s, s[11], t, s[o + 1] = function (t, e) { return null == t || "object" == typeof t && (t = it(vn(t))), t }(e), true, o) }(t, e), uo } function po(t, e) { for (let i = function (t) { return function (t) { ao.key = 0, ao.keyEnd = 0, ao.value = 0, ao.valueEnd = 0, ao.textEnd = t.length }(t), co(t, ho(t, 0, ao.textEnd)) }(e); i >= 0; i = co(e, i))Ji(t, lo(e), !0) } function fo(t, e) { return e >= t.expandoStartIndex } function go(t, e, i, n) { const s = t.data; if (null === s[i + 1]) { const r = s[ei()], o = fo(t, i); wo(r, n) && null === e && !o && (e = !1), e = function (t, e, i, n) { const s = Ue(t); let r = n ? e.residualClasses : e.residualStyles; if (null === s) 0 === (n ? e.classBindings : e.styleBindings) && (i = _o(i = mo(null, t, e, i, n), e.attrs, n), r = null); else { const o = e.directiveStylingLast; if (-1 === o || t[o] !== s) if (i = mo(s, t, e, i, n), null === r) { let i = function (t, e, i) { const n = i ? e.classBindings : e.styleBindings; if (0 !== Ss(n)) return t[ws(n)] }(t, e, n); void 0 !== i && Array.isArray(i) && (i = mo(null, t, e, i[1], n), i = _o(i, e.attrs, n), function (t, e, i, n) { t[ws(i ? e.classBindings : e.styleBindings)] = n }(t, e, n, i)) } else r = function (t, e, i) { let n; const s = e.directiveEnd; for (let r = 1 + e.directiveStylingLast; r < s; r++)n = _o(n, t[r].hostAttrs, i); return _o(n, e.attrs, i) }(t, e, n) } return void 0 !== r && (n ? e.residualClasses = r : e.residualStyles = r), i }(s, r, e, n), function (t, e, i, n, s, r) { let o = r ? e.classBindings : e.styleBindings, a = ws(o), l = Ss(o); t[n] = i; let c, h = !1; if (Array.isArray(i)) { const t = i; c = t[1], (null === c || en(t, c) > 0) && (h = !0) } else c = i; if (s) if (0 !== l) { const e = ws(t[a + 1]); t[n + 1] = bs(e, a), 0 !== e && (t[e + 1] = ks(t[e + 1], n)), t[a + 1] = 131071 & t[a + 1] | n << 17 } else t[n + 1] = bs(a, 0), 0 !== a && (t[a + 1] = ks(t[a + 1], n)), a = n; else t[n + 1] = bs(l, 0), 0 === a ? a = n : t[l + 1] = ks(t[l + 1], n), l = n; h && (t[n + 1] = xs(t[n + 1])), ro(t, c, n, !0), ro(t, c, n, !1), function (t, e, i, n, s) { const r = s ? t.residualClasses : t.residualStyles; null != r && "string" == typeof e && en(r, e) >= 0 && (i[n + 1] = Cs(i[n + 1])) }(e, c, t, n, r), o = bs(a, l), r ? e.classBindings = o : e.styleBindings = o }(s, r, e, i, o, n) } } function mo(t, e, i, n, s) { let r = null; const o = i.directiveEnd; let a = i.directiveStylingLast; for (-1 === a ? a = i.directiveStart : a++; a < o && (r = e[a], n = _o(n, r.hostAttrs, s), r !== t);)a++; return null !== t && (i.directiveStylingLast = a), n } function _o(t, e, i) { const n = i ? 1 : 2; let s = -1; if (null !== e) for (let r = 0; r < e.length; r++) { const o = e[r]; "number" == typeof o ? s = o : s === n && (Array.isArray(t) || (t = void 0 === t ? [] : ["", t]), Ji(t, o, !!i || e[++r])) } return void 0 === t ? null : t } function vo(t, e, i, n, s, r, o, a) { if (!(3 & e.type)) return; const l = t.data, c = l[a + 1]; bo(1 == (1 & c) ? yo(l, e, i, s, Ss(c), o) : void 0) || (bo(r) || 2 == (2 & c) && (r = yo(l, null, i, s, a, o)), function (t, e, i, n, s) { const r = ge(t); if (e) s ? r ? t.addClass(i, n) : i.classList.add(n) : r ? t.removeClass(i, n) : i.classList.remove(n); else { let e = -1 === n.indexOf("-") ? void 0 : Rn.DashCase; if (null == s) r ? t.removeStyle(i, n, e) : i.style.removeProperty(n); else { const o = "string" == typeof s && s.endsWith("!important"); o && (s = s.slice(0, -10), e |= Rn.Important), r ? t.setStyle(i, n, s, e) : i.style.setProperty(n, s, o ? "important" : "") } } }(n, o, ve(ei(), i), s, r)) } function yo(t, e, i, n, s, r) { const o = null === e; let a; for (; s > 0;) { const e = t[s], r = Array.isArray(e), l = r ? e[1] : e, c = null === l; let h = i[s + 1]; h === _s && (h = c ? It : void 0); let u = c ? tn(h, n) : l === n ? h : void 0; if (r && !bo(u) && (u = tn(e, n)), bo(u) && (a = u, o)) return a; const d = t[s + 1]; s = o ? ws(d) : Ss(d) } if (null !== e) { let t = r ? e.residualClasses : e.residualStyles; null != t && (a = tn(t, n)) } return a } function bo(t) { return void 0 !== t } function wo(t, e) { return 0 != (t.flags & (e ? 16 : 32)) } function xo(t, e = "") { const i = De(), n = Ae(), s = t + Xt, r = n.firstCreatePass ? Ps(n, s, 1, e, null) : n.data[s], o = i[s] = function (t, e) { return ge(t) ? t.createText(e) : t.createTextNode(e) }(i[11], e); Qn(n, i, o, r), Ie(r, !1) } function So(t) { return ko("", t, ""), So } function ko(t, e, i) { const n = De(), s = function (t, e, i, n) { return Br(t, Be(), i) ? e + ct(i) + n : _s }(n, t, e, i); return s !== _s && function (t, e, i) { const n = ve(e, t); !function (t, e, i) { ge(t) ? t.setValue(e, i) : e.textContent = i }(t[11], n, i) }(n, ei(), s), ko } function Co(t, e, i) { const n = De(); return Br(n, Be(), e) && Bs(Ae(), ni(), n, t, e, n[11], i, !0), Co } function Eo(t, e, i) { const n = De(); if (Br(n, Be(), e)) { const s = Ae(), r = ni(); Bs(s, r, n, t, e, cr(Ue(s.data), r, n), i, !0) } return Eo } const To = void 0; var Po = ["en", [["a", "p"], ["AM", "PM"], To], [["AM", "PM"], To, To], [["S", "M", "T", "W", "T", "F", "S"], ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]], To, [["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]], To, [["B", "A"], ["BC", "AD"], ["Before Christ", "Anno Domini"]], 0, [6, 0], ["M/d/yy", "MMM d, y", "MMMM d, y", "EEEE, MMMM d, y"], ["h:mm a", "h:mm:ss a", "h:mm:ss a z", "h:mm:ss a zzzz"], ["{1}, {0}", To, "{1} 'at' {0}", To], [".", ",", ";", "%", "+", "-", "E", "\xd7", "\u2030", "\u221e", "NaN", ":"], ["#,##0.###", "#,##0%", "\xa4#,##0.00", "#E0"], "USD", "$", "US Dollar", {}, "ltr", function (t) { let e = Math.floor(Math.abs(t)), i = t.toString().replace(/^[^.]*\.?/, "").length; return 1 === e && 0 === i ? 1 : 5 }]; let Do = {}; function Ao(t) { return t in Do || (Do[t] = Rt.ng && Rt.ng.common && Rt.ng.common.locales && Rt.ng.common.locales[t]), Do[t] } var Oo = function (t) { return t[t.LocaleId = 0] = "LocaleId", t[t.DayPeriodsFormat = 1] = "DayPeriodsFormat", t[t.DayPeriodsStandalone = 2] = "DayPeriodsStandalone", t[t.DaysFormat = 3] = "DaysFormat", t[t.DaysStandalone = 4] = "DaysStandalone", t[t.MonthsFormat = 5] = "MonthsFormat", t[t.MonthsStandalone = 6] = "MonthsStandalone", t[t.Eras = 7] = "Eras", t[t.FirstDayOfWeek = 8] = "FirstDayOfWeek", t[t.WeekendRange = 9] = "WeekendRange", t[t.DateFormat = 10] = "DateFormat", t[t.TimeFormat = 11] = "TimeFormat", t[t.DateTimeFormat = 12] = "DateTimeFormat", t[t.NumberSymbols = 13] = "NumberSymbols", t[t.NumberFormats = 14] = "NumberFormats", t[t.CurrencyCode = 15] = "CurrencyCode", t[t.CurrencySymbol = 16] = "CurrencySymbol", t[t.CurrencyName = 17] = "CurrencyName", t[t.Currencies = 18] = "Currencies", t[t.Directionality = 19] = "Directionality", t[t.PluralCase = 20] = "PluralCase", t[t.ExtraData = 21] = "ExtraData", t }({}); const Ro = "en-US"; let Mo = Ro; function Io(t) { var e, i; i = "Expected localeId to be defined", null == (e = t) && function (t, e, i, n) { throw new Error(`ASSERTION ERROR: ${t} [Expected=> null != ${e} <=Actual]`) }(i, e), "string" == typeof t && (Mo = t.toLowerCase().replace(/_/g, "-")) } function Lo(t, e, i, n, s) { if (t = ot(t), Array.isArray(t)) for (let r = 0; r < t.length; r++)Lo(t[r], e, i, n, s); else { const r = Ae(), o = De(); let a = Er(t) ? t : ot(t.provide), l = Sr(t); const c = Re(), h = 1048575 & c.providerIndexes, u = c.directiveStart, d = c.providerIndexes >> 20; if (Er(t) || !t.multi) { const n = new pi(l, s, Ur), p = jo(a, e, s ? h : h + d, u); -1 === p ? (Di(Ci(c, o), r, a), Fo(r, t, e.length), e.push(a), c.directiveStart++, c.directiveEnd++, s && (c.providerIndexes += 1048576), i.push(n), o.push(n)) : (i[p] = n, o[p] = n) } else { const p = jo(a, e, h + d, u), f = jo(a, e, h, h + d), g = p >= 0 && i[p], m = f >= 0 && i[f]; if (s && !m || !s && !g) { Di(Ci(c, o), r, a); const h = function (t, e, i, n, s) { const r = new pi(t, i, Ur); return r.multi = [], r.index = e, r.componentProviders = 0, No(r, s, n && !i), r }(s ? Bo : Vo, i.length, s, n, l); !s && m && (i[f].providerFactory = h), Fo(r, t, e.length, 0), e.push(a), c.directiveStart++, c.directiveEnd++, s && (c.providerIndexes += 1048576), i.push(h), o.push(h) } else Fo(r, t, p > -1 ? p : f, No(i[s ? f : p], l, !s && n)); !s && n && m && i[f].componentProviders++ } } } function Fo(t, e, i, n) { const s = Er(e); if (s || e.useClass) { const r = (e.useClass || e).prototype.ngOnDestroy; if (r) { const o = t.destroyHooks || (t.destroyHooks = []); if (!s && e.multi) { const t = o.indexOf(i); -1 === t ? o.push(i, [n, r]) : o[t + 1].push(n, r) } else o.push(i, r) } } } function No(t, e, i) { return i && t.componentProviders++, t.multi.push(e) - 1 } function jo(t, e, i, n) { for (let s = i; s < n; s++)if (e[s] === t) return s; return -1 } function Vo(t, e, i, n) { return Ho(this.multi, []) } function Bo(t, e, i, n) { const s = this.multi; let r; if (this.providerFactory) { const t = this.providerFactory.componentProviders, e = Ni(i, i[1], this.providerFactory.index, n); r = e.slice(0, t), Ho(s, r); for (let i = t; i < e.length; i++)r.push(e[i]) } else r = [], Ho(s, r); return r } function Ho(t, e) { for (let i = 0; i < t.length; i++)e.push((0, t[i])()); return e } function zo(t, e = []) { return i => { i.providersResolver = (i, n) => function (t, e, i) { const n = Ae(); if (n.firstCreatePass) { const s = re(t); Lo(i, n.data, n.blueprint, s, !0), Lo(e, n.data, n.blueprint, s, !1) } }(i, n ? n(t) : t, e) } } class $o { } class Uo { resolveComponentFactory(t) { throw function (t) { const e = Error(`No component factory found for ${it(t)}. Did you add it to @NgModule.entryComponents?`); return e.ngComponent = t, e }(t) } } let Wo = (() => { class t { } return t.NULL = new Uo, t })(); function qo(...t) { } function Go(t, e) { return new Ko(ye(t, e)) } const Zo = function () { return Go(Re(), De()) }; let Ko = (() => { class t { constructor(t) { this.nativeElement = t } } return t.__NG_ELEMENT_ID__ = Zo, t })(); function Yo(t) { return t instanceof Ko ? t.nativeElement : t } class Qo { } let Xo = (() => { class t { } return t.__NG_ELEMENT_ID__ = () => Jo(), t })(); const Jo = function () { const t = De(), e = we(Re().index, t); return function (t) { return t[11] }(te(e) ? e : t) }; let ta = (() => { class t { } return t.\u0275prov = dt({ token: t, providedIn: "root", factory: () => null }), t })(); class ea { constructor(t) { this.full = t, this.major = t.split(".")[0], this.minor = t.split(".")[1], this.patch = t.split(".").slice(2).join(".") } } const ia = new ea("12.0.5"); class na { constructor() { } supports(t) { return Nr(t) } create(t) { return new ra(t) } } const sa = (t, e) => e; class ra { constructor(t) { this.length = 0, this._linkedRecords = null, this._unlinkedRecords = null, this._previousItHead = null, this._itHead = null, this._itTail = null, this._additionsHead = null, this._additionsTail = null, this._movesHead = null, this._movesTail = null, this._removalsHead = null, this._removalsTail = null, this._identityChangesHead = null, this._identityChangesTail = null, this._trackByFn = t || sa } forEachItem(t) { let e; for (e = this._itHead; null !== e; e = e._next)t(e) } forEachOperation(t) { let e = this._itHead, i = this._removalsHead, n = 0, s = null; for (; e || i;) { const r = !i || e && e.currentIndex < ca(i, n, s) ? e : i, o = ca(r, n, s), a = r.currentIndex; if (r === i) n--, i = i._nextRemoved; else if (e = e._next, null == r.previousIndex) n++; else { s || (s = []); const t = o - n, e = a - n; if (t != e) { for (let i = 0; i < t; i++) { const n = i < s.length ? s[i] : s[i] = 0, r = n + i; e <= r && r < t && (s[i] = n + 1) } s[r.previousIndex] = e - t } } o !== a && t(r, o, a) } } forEachPreviousItem(t) { let e; for (e = this._previousItHead; null !== e; e = e._nextPrevious)t(e) } forEachAddedItem(t) { let e; for (e = this._additionsHead; null !== e; e = e._nextAdded)t(e) } forEachMovedItem(t) { let e; for (e = this._movesHead; null !== e; e = e._nextMoved)t(e) } forEachRemovedItem(t) { let e; for (e = this._removalsHead; null !== e; e = e._nextRemoved)t(e) } forEachIdentityChange(t) { let e; for (e = this._identityChangesHead; null !== e; e = e._nextIdentityChange)t(e) } diff(t) { if (null == t && (t = []), !Nr(t)) throw new Error(`Error trying to diff '${it(t)}'. Only arrays and iterables are allowed`); return this.check(t) ? this : null } onDestroy() { } check(t) { this._reset(); let e, i, n, s = this._itHead, r = !1; if (Array.isArray(t)) { this.length = t.length; for (let e = 0; e < this.length; e++)i = t[e], n = this._trackByFn(e, i), null !== s && Object.is(s.trackById, n) ? (r && (s = this._verifyReinsertion(s, i, n, e)), Object.is(s.item, i) || this._addIdentityChange(s, i)) : (s = this._mismatch(s, i, n, e), r = !0), s = s._next } else e = 0, function (t, e) { if (Array.isArray(t)) for (let i = 0; i < t.length; i++)e(t[i]); else { const i = t[Fr()](); let n; for (; !(n = i.next()).done;)e(n.value) } }(t, t => { n = this._trackByFn(e, t), null !== s && Object.is(s.trackById, n) ? (r && (s = this._verifyReinsertion(s, t, n, e)), Object.is(s.item, t) || this._addIdentityChange(s, t)) : (s = this._mismatch(s, t, n, e), r = !0), s = s._next, e++ }), this.length = e; return this._truncate(s), this.collection = t, this.isDirty } get isDirty() { return null !== this._additionsHead || null !== this._movesHead || null !== this._removalsHead || null !== this._identityChangesHead } _reset() { if (this.isDirty) { let t; for (t = this._previousItHead = this._itHead; null !== t; t = t._next)t._nextPrevious = t._next; for (t = this._additionsHead; null !== t; t = t._nextAdded)t.previousIndex = t.currentIndex; for (this._additionsHead = this._additionsTail = null, t = this._movesHead; null !== t; t = t._nextMoved)t.previousIndex = t.currentIndex; this._movesHead = this._movesTail = null, this._removalsHead = this._removalsTail = null, this._identityChangesHead = this._identityChangesTail = null } } _mismatch(t, e, i, n) { let s; return null === t ? s = this._itTail : (s = t._prev, this._remove(t)), null !== (t = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(i, null)) ? (Object.is(t.item, e) || this._addIdentityChange(t, e), this._reinsertAfter(t, s, n)) : null !== (t = null === this._linkedRecords ? null : this._linkedRecords.get(i, n)) ? (Object.is(t.item, e) || this._addIdentityChange(t, e), this._moveAfter(t, s, n)) : t = this._addAfter(new oa(e, i), s, n), t } _verifyReinsertion(t, e, i, n) { let s = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(i, null); return null !== s ? t = this._reinsertAfter(s, t._prev, n) : t.currentIndex != n && (t.currentIndex = n, this._addToMoves(t, n)), t } _truncate(t) { for (; null !== t;) { const e = t._next; this._addToRemovals(this._unlink(t)), t = e } null !== this._unlinkedRecords && this._unlinkedRecords.clear(), null !== this._additionsTail && (this._additionsTail._nextAdded = null), null !== this._movesTail && (this._movesTail._nextMoved = null), null !== this._itTail && (this._itTail._next = null), null !== this._removalsTail && (this._removalsTail._nextRemoved = null), null !== this._identityChangesTail && (this._identityChangesTail._nextIdentityChange = null) } _reinsertAfter(t, e, i) { null !== this._unlinkedRecords && this._unlinkedRecords.remove(t); const n = t._prevRemoved, s = t._nextRemoved; return null === n ? this._removalsHead = s : n._nextRemoved = s, null === s ? this._removalsTail = n : s._prevRemoved = n, this._insertAfter(t, e, i), this._addToMoves(t, i), t } _moveAfter(t, e, i) { return this._unlink(t), this._insertAfter(t, e, i), this._addToMoves(t, i), t } _addAfter(t, e, i) { return this._insertAfter(t, e, i), this._additionsTail = null === this._additionsTail ? this._additionsHead = t : this._additionsTail._nextAdded = t, t } _insertAfter(t, e, i) { const n = null === e ? this._itHead : e._next; return t._next = n, t._prev = e, null === n ? this._itTail = t : n._prev = t, null === e ? this._itHead = t : e._next = t, null === this._linkedRecords && (this._linkedRecords = new la), this._linkedRecords.put(t), t.currentIndex = i, t } _remove(t) { return this._addToRemovals(this._unlink(t)) } _unlink(t) { null !== this._linkedRecords && this._linkedRecords.remove(t); const e = t._prev, i = t._next; return null === e ? this._itHead = i : e._next = i, null === i ? this._itTail = e : i._prev = e, t } _addToMoves(t, e) { return t.previousIndex === e || (this._movesTail = null === this._movesTail ? this._movesHead = t : this._movesTail._nextMoved = t), t } _addToRemovals(t) { return null === this._unlinkedRecords && (this._unlinkedRecords = new la), this._unlinkedRecords.put(t), t.currentIndex = null, t._nextRemoved = null, null === this._removalsTail ? (this._removalsTail = this._removalsHead = t, t._prevRemoved = null) : (t._prevRemoved = this._removalsTail, this._removalsTail = this._removalsTail._nextRemoved = t), t } _addIdentityChange(t, e) { return t.item = e, this._identityChangesTail = null === this._identityChangesTail ? this._identityChangesHead = t : this._identityChangesTail._nextIdentityChange = t, t } } class oa { constructor(t, e) { this.item = t, this.trackById = e, this.currentIndex = null, this.previousIndex = null, this._nextPrevious = null, this._prev = null, this._next = null, this._prevDup = null, this._nextDup = null, this._prevRemoved = null, this._nextRemoved = null, this._nextAdded = null, this._nextMoved = null, this._nextIdentityChange = null } } class aa { constructor() { this._head = null, this._tail = null } add(t) { null === this._head ? (this._head = this._tail = t, t._nextDup = null, t._prevDup = null) : (this._tail._nextDup = t, t._prevDup = this._tail, t._nextDup = null, this._tail = t) } get(t, e) { let i; for (i = this._head; null !== i; i = i._nextDup)if ((null === e || e <= i.currentIndex) && Object.is(i.trackById, t)) return i; return null } remove(t) { const e = t._prevDup, i = t._nextDup; return null === e ? this._head = i : e._nextDup = i, null === i ? this._tail = e : i._prevDup = e, null === this._head } } class la { constructor() { this.map = new Map } put(t) { const e = t.trackById; let i = this.map.get(e); i || (i = new aa, this.map.set(e, i)), i.add(t) } get(t, e) { const i = this.map.get(t); return i ? i.get(t, e) : null } remove(t) { const e = t.trackById; return this.map.get(e).remove(t) && this.map.delete(e), t } get isEmpty() { return 0 === this.map.size } clear() { this.map.clear() } } function ca(t, e, i) { const n = t.previousIndex; if (null === n) return n; let s = 0; return i && n < i.length && (s = i[n]), n + e + s } class ha { constructor() { } supports(t) { return t instanceof Map || jr(t) } create() { return new ua } } class ua { constructor() { this._records = new Map, this._mapHead = null, this._appendAfter = null, this._previousMapHead = null, this._changesHead = null, this._changesTail = null, this._additionsHead = null, this._additionsTail = null, this._removalsHead = null, this._removalsTail = null } get isDirty() { return null !== this._additionsHead || null !== this._changesHead || null !== this._removalsHead } forEachItem(t) { let e; for (e = this._mapHead; null !== e; e = e._next)t(e) } forEachPreviousItem(t) { let e; for (e = this._previousMapHead; null !== e; e = e._nextPrevious)t(e) } forEachChangedItem(t) { let e; for (e = this._changesHead; null !== e; e = e._nextChanged)t(e) } forEachAddedItem(t) { let e; for (e = this._additionsHead; null !== e; e = e._nextAdded)t(e) } forEachRemovedItem(t) { let e; for (e = this._removalsHead; null !== e; e = e._nextRemoved)t(e) } diff(t) { if (t) { if (!(t instanceof Map || jr(t))) throw new Error(`Error trying to diff '${it(t)}'. Only maps and objects are allowed`) } else t = new Map; return this.check(t) ? this : null } onDestroy() { } check(t) { this._reset(); let e = this._mapHead; if (this._appendAfter = null, this._forEach(t, (t, i) => { if (e && e.key === i) this._maybeAddToChanges(e, t), this._appendAfter = e, e = e._next; else { const n = this._getOrCreateRecordForKey(i, t); e = this._insertBeforeOrAppend(e, n) } }), e) { e._prev && (e._prev._next = null), this._removalsHead = e; for (let t = e; null !== t; t = t._nextRemoved)t === this._mapHead && (this._mapHead = null), this._records.delete(t.key), t._nextRemoved = t._next, t.previousValue = t.currentValue, t.currentValue = null, t._prev = null, t._next = null } return this._changesTail && (this._changesTail._nextChanged = null), this._additionsTail && (this._additionsTail._nextAdded = null), this.isDirty } _insertBeforeOrAppend(t, e) { if (t) { const i = t._prev; return e._next = t, e._prev = i, t._prev = e, i && (i._next = e), t === this._mapHead && (this._mapHead = e), this._appendAfter = t, t } return this._appendAfter ? (this._appendAfter._next = e, e._prev = this._appendAfter) : this._mapHead = e, this._appendAfter = e, null } _getOrCreateRecordForKey(t, e) { if (this._records.has(t)) { const i = this._records.get(t); this._maybeAddToChanges(i, e); const n = i._prev, s = i._next; return n && (n._next = s), s && (s._prev = n), i._next = null, i._prev = null, i } const i = new da(t); return this._records.set(t, i), i.currentValue = e, this._addToAdditions(i), i } _reset() { if (this.isDirty) { let t; for (this._previousMapHead = this._mapHead, t = this._previousMapHead; null !== t; t = t._next)t._nextPrevious = t._next; for (t = this._changesHead; null !== t; t = t._nextChanged)t.previousValue = t.currentValue; for (t = this._additionsHead; null != t; t = t._nextAdded)t.previousValue = t.currentValue; this._changesHead = this._changesTail = null, this._additionsHead = this._additionsTail = null, this._removalsHead = null } } _maybeAddToChanges(t, e) { Object.is(e, t.currentValue) || (t.previousValue = t.currentValue, t.currentValue = e, this._addToChanges(t)) } _addToAdditions(t) { null === this._additionsHead ? this._additionsHead = this._additionsTail = t : (this._additionsTail._nextAdded = t, this._additionsTail = t) } _addToChanges(t) { null === this._changesHead ? this._changesHead = this._changesTail = t : (this._changesTail._nextChanged = t, this._changesTail = t) } _forEach(t, e) { t instanceof Map ? t.forEach(e) : Object.keys(t).forEach(i => e(t[i], i)) } } class da { constructor(t) { this.key = t, this.previousValue = null, this.currentValue = null, this._nextPrevious = null, this._next = null, this._prev = null, this._nextAdded = null, this._nextRemoved = null, this._nextChanged = null } } function pa() { return new fa([new na]) } let fa = (() => { class t { constructor(t) { this.factories = t } static create(e, i) { if (null != i) { const t = i.factories.slice(); e = e.concat(t) } return new t(e) } static extend(e) { return { provide: t, useFactory: i => t.create(e, i || pa()), deps: [[t, new mn, new gn]] } } find(t) { const e = this.factories.find(e => e.supports(t)); if (null != e) return e; throw new Error(`Cannot find a differ supporting object '${t}' of type '${i = t, i.name || typeof i}'`); var i } } return t.\u0275prov = dt({ token: t, providedIn: "root", factory: pa }), t })(); function ga() { return new ma([new ha]) } let ma = (() => { class t { constructor(t) { this.factories = t } static create(e, i) { if (i) { const t = i.factories.slice(); e = e.concat(t) } return new t(e) } static extend(e) { return { provide: t, useFactory: i => t.create(e, i || ga()), deps: [[t, new mn, new gn]] } } find(t) { const e = this.factories.find(e => e.supports(t)); if (e) return e; throw new Error(`Cannot find a differ supporting object '${t}'`) } } return t.\u0275prov = dt({ token: t, providedIn: "root", factory: ga }), t })(); function _a(t, e, i, n, s = !1) { for (; null !== i;) { const r = e[i.index]; if (null !== r && n.push(_e(r)), ee(r)) for (let t = Jt; t < r.length; t++) { const e = r[t], i = e[1].firstChild; null !== i && _a(e[1], e, i, n) } const o = i.type; if (8 & o) _a(t, e, i.child, n); else if (32 & o) { const t = Mn(i, e); let s; for (; s = t();)n.push(s) } else if (16 & o) { const t = Jn(e, i); if (Array.isArray(t)) n.push(...t); else { const i = In(e[16]); _a(i[1], i, t, n, !0) } } i = s ? i.projectionNext : i.next } return n } class va { constructor(t, e) { this._lView = t, this._cdRefInjectingView = e, this._appRef = null, this._attachedToViewContainer = !1 } get rootNodes() { const t = this._lView, e = t[1]; return _a(e, t, e.firstChild, []) } get context() { return this._lView[8] } set context(t) { this._lView[8] = t } get destroyed() { return 256 == (256 & this._lView[2]) } destroy() { if (this._appRef) this._appRef.detachView(this); else if (this._attachedToViewContainer) { const t = this._lView[3]; if (ee(t)) { const e = t[8], i = e ? e.indexOf(this) : -1; i > -1 && (Hn(t, i), Qi(e, i)) } this._attachedToViewContainer = !1 } zn(this._lView[1], this._lView) } onDestroy(t) { js(this._lView[1], this._lView, null, t) } markForCheck() { ir(this._cdRefInjectingView || this._lView) } detach() { this._lView[2] &= -129 } reattach() { this._lView[2] |= 128 } detectChanges() { nr(this._lView[1], this._lView, this.context) } checkNoChanges() { !function (t, e, i) { je(!0); try { nr(t, e, i) } finally { je(!1) } }(this._lView[1], this._lView, this.context) } attachToViewContainerRef() { if (this._appRef) throw new Error("This view is already attached directly to the ApplicationRef!"); this._attachedToViewContainer = !0 } detachFromAppRef() { var t; this._appRef = null, is(this._lView[1], t = this._lView, t[11], 2, null, null) } attachToAppRef(t) { if (this._attachedToViewContainer) throw new Error("This view is already attached to a ViewContainer!"); this._appRef = t } } class ya extends va { constructor(t) { super(t), this._view = t } detectChanges() { sr(this._view) } checkNoChanges() { !function (t) { je(!0); try { sr(t) } finally { je(!1) } }(this._view) } get context() { return null } } const ba = function (t) { return function (t, e, i) { if (ne(t) && !i) { const i = we(t.index, e); return new va(i, i) } return 47 & t.type ? new va(e[16], e) : null }(Re(), De(), 16 == (16 & t)) }; let wa = (() => { class t { } return t.__NG_ELEMENT_ID__ = ba, t })(); const xa = [new ha], Sa = new fa([new na]), ka = new ma(xa), Ca = function () { return Da(Re(), De()) }; let Ea = (() => { class t { } return t.__NG_ELEMENT_ID__ = Ca, t })(); const Ta = Ea, Pa = class extends Ta { constructor(t, e, i) { super(), this._declarationLView = t, this._declarationTContainer = e, this.elementRef = i } createEmbeddedView(t) { const e = this._declarationTContainer.tViews, i = Ts(this._declarationLView, e, t, 16, null, e.declTNode, null, null, null, null); i[17] = this._declarationLView[this._declarationTContainer.index]; const n = this._declarationLView[19]; return null !== n && (i[19] = n.createEmbeddedView(e)), As(e, i, t), new va(i) } }; function Da(t, e) { return 4 & t.type ? new Pa(e, t, Go(t, e)) : null } class Aa { } class Oa { } const Ra = function () { return ja(Re(), De()) }; let Ma = (() => { class t { } return t.__NG_ELEMENT_ID__ = Ra, t })(); const Ia = Ma, La = class extends Ia { constructor(t, e, i) { super(), this._lContainer = t, this._hostTNode = e, this._hostLView = i } get element() { return Go(this._hostTNode, this._hostLView) } get injector() { return new Bi(this._hostTNode, this._hostLView) } get parentInjector() { const t = Pi(this._hostTNode, this._hostLView); if (yi(t)) { const e = wi(t, this._hostLView), i = bi(t); return new Bi(e[1].data[i + 8], e) } return new Bi(null, this._hostLView) } clear() { for (; this.length > 0;)this.remove(this.length - 1) } get(t) { const e = Fa(this._lContainer); return null !== e && e[t] || null } get length() { return this._lContainer.length - Jt } createEmbeddedView(t, e, i) { const n = t.createEmbeddedView(e || {}); return this.insert(n, i), n } createComponent(t, e, i, n, s) { const r = i || this.parentInjector; if (!s && null == t.ngModule && r) { const t = r.get(Aa, null); t && (s = t) } const o = t.create(r, n, void 0, s); return this.insert(o.hostView, e), o } insert(t, e) { const i = t._lView, n = i[1]; if (ee(i[3])) { const e = this.indexOf(t); if (-1 !== e) this.detach(e); else { const e = i[3], n = new La(e, e[6], e[3]); n.detach(n.indexOf(t)) } } const s = this._adjustIndex(e), r = this._lContainer; !function (t, e, i, n) { const s = Jt + n, r = i.length; n > 0 && (i[s - 1][4] = e), n < r - Jt ? (e[4] = i[s], Yi(i, Jt + n, e)) : (i.push(e), e[4] = null), e[3] = i; const o = e[17]; null !== o && i !== o && function (t, e) { const i = t[9]; e[16] !== e[3][3][16] && (t[2] = !0), null === i ? t[9] = [e] : i.push(e) }(o, e); const a = e[19]; null !== a && a.insertView(t), e[2] |= 128 }(n, i, r, s); const o = ts(s, r), a = i[11], l = Zn(a, r[7]); return null !== l && function (t, e, i, n, s, r) { n[0] = s, n[6] = e, is(t, n, i, 1, s, r) }(n, r[6], a, i, l, o), t.attachToViewContainerRef(), Yi(Na(r), s, t), t } move(t, e) { return this.insert(t, e) } indexOf(t) { const e = Fa(this._lContainer); return null !== e ? e.indexOf(t) : -1 } remove(t) { const e = this._adjustIndex(t, -1), i = Hn(this._lContainer, e); i && (Qi(Na(this._lContainer), e), zn(i[1], i)) } detach(t) { const e = this._adjustIndex(t, -1), i = Hn(this._lContainer, e); return i && null != Qi(Na(this._lContainer), e) ? new va(i) : null } _adjustIndex(t, e = 0) { return null == t ? this.length + e : t } }; function Fa(t) { return t[8] } function Na(t) { return t[8] || (t[8] = []) } function ja(t, e) { let i; const n = e[t.index]; if (ee(n)) i = n; else { let s; if (8 & t.type) s = _e(n); else { const i = e[11]; s = i.createComment(""); const n = ye(t, e); Wn(i, Zn(i, n), s, function (t, e) { return ge(t) ? t.nextSibling(e) : e.nextSibling }(i, n), !1) } e[t.index] = i = Qs(n, e, s, t), er(e, i) } return new La(i, t, e) } const Va = {}; class Ba extends Wo { constructor(t) { super(), this.ngModule = t } resolveComponentFactory(t) { const e = Yt(t); return new $a(e, this.ngModule) } } function Ha(t) { const e = []; for (let i in t) t.hasOwnProperty(i) && e.push({ propName: t[i], templateName: i }); return e } const za = new Wi("SCHEDULER_TOKEN", { providedIn: "root", factory: () => Dn }); class $a extends $o { constructor(t, e) { super(), this.componentDef = t, this.ngModule = e, this.componentType = t.type, this.selector = t.selectors.map(ms).join(","), this.ngContentSelectors = t.ngContentSelectors ? t.ngContentSelectors : [], this.isBoundToModule = !!e } get inputs() { return Ha(this.componentDef.inputs) } get outputs() { return Ha(this.componentDef.outputs) } create(t, e, i, n) { const s = (n = n || this.ngModule) ? function (t, e) { return { get: (i, n, s) => { const r = t.get(i, Va, s); return r !== Va || n === Va ? r : e.get(i, n, s) } } }(t, n.injector) : t, r = s.get(Qo, me), o = s.get(ta, null), a = r.createRenderer(null, this.componentDef), l = this.componentDef.selectors[0][0] || "div", c = i ? function (t, e, i) { if (ge(t)) return t.selectRootElement(e, i === Tt.ShadowDom); let n = "string" == typeof e ? t.querySelector(e) : e; return n.textContent = "", n }(a, i, this.componentDef.encapsulation) : Vn(r.createRenderer(null, this.componentDef), l, function (t) { const e = t.toLowerCase(); return "svg" === e ? pe : "math" === e ? "http://www.w3.org/1998/MathML/" : null }(l)), h = this.componentDef.onPush ? 576 : 528, u = { components: [], scheduler: Dn, clean: or, playerHandler: null, flags: 0 }, d = Ns(0, null, null, 1, 0, null, null, null, null, null), p = Ts(null, d, u, h, null, null, r, a, o, s); let f, g; Ke(p); try { const t = function (t, e, i, n, s, r) { const o = i[1]; i[20] = t; const a = Ps(o, 20, 2, "#host", null), l = a.mergedAttrs = e.hostAttrs; null !== l && (dr(a, l, !0), null !== t && (fi(s, t, l), null !== a.classes && rs(s, t, a.classes), null !== a.styles && ss(s, t, a.styles))); const c = n.createRenderer(t, e), h = Ts(i, Fs(e), null, e.onPush ? 64 : 16, i[20], a, n, c, null, null); return o.firstCreatePass && (Di(Ci(a, i), o, e.type), Us(o, a), qs(a, i.length, 1)), er(i, h), i[20] = h }(c, this.componentDef, p, r, a); if (c) if (i) fi(a, c, ["ng-version", ia.full]); else { const { attrs: t, classes: e } = function (t) { const e = [], i = []; let n = 1, s = 2; for (; n < t.length;) { let r = t[n]; if ("string" == typeof r) 2 === s ? "" !== r && e.push(r, t[++n]) : 8 === s && i.push(r); else { if (!ds(s)) break; s = r } n++ } return { attrs: e, classes: i } }(this.componentDef.selectors[0]); t && fi(a, c, t), e && e.length > 0 && rs(a, c, e.join(" ")) } if (g = be(d, Xt), void 0 !== e) { const t = g.projection = []; for (let i = 0; i < this.ngContentSelectors.length; i++) { const n = e[i]; t.push(null != n ? Array.from(n) : null) } } f = function (t, e, i, n, s) { const r = i[1], o = function (t, e, i) { const n = Re(); t.firstCreatePass && (i.providersResolver && i.providersResolver(i), Gs(t, n, e, Ds(t, e, 1, null), i)); const s = Ni(e, t, n.directiveStart, n); Sn(s, e); const r = ye(n, e); return r && Sn(r, e), s }(r, i, e); if (n.components.push(o), t[8] = o, s && s.forEach(t => t(o, e)), e.contentQueries) { const t = Re(); e.contentQueries(1, o, t.directiveStart) } const a = Re(); return !r.firstCreatePass || null === e.hostBindings && null === e.hostAttrs || (ii(a.index), zs(i[1], a, 0, a.directiveStart, a.directiveEnd, e), $s(e, o)), o }(t, this.componentDef, p, u, [Dr]), As(d, p, null) } finally { ti() } return new Ua(this.componentType, f, Go(g, p), p, g) } } class Ua extends class { }{ constructor(t, e, i, n, s) { super(), this.location = i, this._rootLView = n, this._tNode = s, this.instance = e, this.hostView = this.changeDetectorRef = new ya(n), this.componentType = t } get injector() { return new Bi(this._tNode, this._rootLView) } destroy() { this.hostView.destroy() } onDestroy(t) { this.hostView.onDestroy(t) } } const Wa = new Map; class qa extends Aa { constructor(t, e) { super(), this._parent = e, this._bootstrapComponents = [], this.injector = this, this.destroyCbs = [], this.componentFactoryResolver = new Ba(this); const i = Qt(t), n = t[Vt] || null; n && Io(n), this._bootstrapComponents = On(i.bootstrap), this._r3Injector = br(t, e, [{ provide: Aa, useValue: this }, { provide: Wo, useValue: this.componentFactoryResolver }], it(t)), this._r3Injector._resolveInjectorDefTypes(), this.instance = this.get(t) } get(t, e = Pr.THROW_IF_NOT_FOUND, i = wt.Default) { return t === Pr || t === Aa || t === pr ? this : this._r3Injector.get(t, e, i) } destroy() { const t = this._r3Injector; !t.destroyed && t.destroy(), this.destroyCbs.forEach(t => t()), this.destroyCbs = null } onDestroy(t) { this.destroyCbs.push(t) } } class Ga extends Oa { constructor(t) { super(), this.moduleType = t, null !== Qt(t) && function (t) { const e = new Set; !function t(i) { const n = Qt(i, !0), s = n.id; null !== s && (function (t, e, i) { if (e && e !== i) throw new Error(`Duplicate module registered for ${t} - ${it(e)} vs ${it(e.name)}`) }(s, Wa.get(s), i), Wa.set(s, i)); const r = On(n.imports); for (const o of r) e.has(o) || (e.add(o), t(o)) }(t) }(t) } create(t) { return new qa(this.moduleType, t) } } function Za(t, e, i) { const n = Ve() + t, s = De(); return s[n] === _s ? Vr(s, n, i ? e.call(i) : e()) : function (t, e) { return t[e] }(s, n) } function Ka(t, e, i, n) { return function (t, e, i, n, s, r) { const o = e + i; return Br(t, o, s) ? Vr(t, o + 1, r ? n.call(r, s) : n(s)) : Qa(t, o + 1) }(De(), Ve(), t, e, i, n) } function Ya(t, e, i, n, s) { return function (t, e, i, n, s, r, o) { const a = e + i; return function (t, e, i, n) { const s = Br(t, e, i); return Br(t, e + 1, n) || s }(t, a, s, r) ? Vr(t, a + 2, o ? n.call(o, s, r) : n(s, r)) : Qa(t, a + 2) }(De(), Ve(), t, e, i, n, s) } function Qa(t, e) { const i = t[e]; return i === _s ? void 0 : i } function Xa(t) { return e => { setTimeout(t, void 0, e) } } const Ja = class extends S { constructor(t = !1) { super(), this.__isAsync = t } emit(t) { super.next(t) } subscribe(t, e, i) { var n, s, r; let o = t, a = e || (() => null), l = i; if (t && "object" == typeof t) { const e = t; o = null === (n = e.next) || void 0 === n ? void 0 : n.bind(e), a = null === (s = e.error) || void 0 === s ? void 0 : s.bind(e), l = null === (r = e.complete) || void 0 === r ? void 0 : r.bind(e) } this.__isAsync && (a = Xa(a), o && (o = Xa(o)), l && (l = Xa(l))); const c = super.subscribe({ next: o, error: a, complete: l }); return t instanceof u && t.add(c), c } }; function tl() { return this._results[Fr()]() } class el { constructor(t = !1) { this._emitDistinctChangesOnly = t, this.dirty = !0, this._results = [], this._changesDetected = !1, this._changes = null, this.length = 0, this.first = void 0, this.last = void 0; const e = Fr(), i = el.prototype; i[e] || (i[e] = tl) } get changes() { return this._changes || (this._changes = new Ja) } get(t) { return this._results[t] } map(t) { return this._results.map(t) } filter(t) { return this._results.filter(t) } find(t) { return this._results.find(t) } reduce(t, e) { return this._results.reduce(t, e) } forEach(t) { this._results.forEach(t) } some(t) { return this._results.some(t) } toArray() { return this._results.slice() } toString() { return this._results.toString() } reset(t, e) { const i = this; i.dirty = !1; const n = Zi(t); (this._changesDetected = !function (t, e, i) { if (t.length !== e.length) return !1; for (let n = 0; n < t.length; n++) { let s = t[n], r = e[n]; if (i && (s = i(s), r = i(r)), r !== s) return !1 } return !0 }(i._results, n, e)) && (i._results = n, i.length = n.length, i.last = n[this.length - 1], i.first = n[0]) } notifyOnChanges() { !this._changes || !this._changesDetected && this._emitDistinctChangesOnly || this._changes.emit(this) } setDirty() { this.dirty = !0 } destroy() { this.changes.complete(), this.changes.unsubscribe() } } class il { constructor(t) { this.queryList = t, this.matches = null } clone() { return new il(this.queryList) } setDirty() { this.queryList.setDirty() } } class nl { constructor(t = []) { this.queries = t } createEmbeddedView(t) { const e = t.queries; if (null !== e) { const i = null !== t.contentQueries ? t.contentQueries[0] : e.length, n = []; for (let t = 0; t < i; t++) { const i = e.getByIndex(t); n.push(this.queries[i.indexInDeclarationView].clone()) } return new nl(n) } return null } insertView(t) { this.dirtyQueriesWithMatches(t) } detachView(t) { this.dirtyQueriesWithMatches(t) } dirtyQueriesWithMatches(t) { for (let e = 0; e < this.queries.length; e++)null !== ml(t, e).matches && this.queries[e].setDirty() } } class sl { constructor(t, e, i = null) { this.predicate = t, this.flags = e, this.read = i } } class rl { constructor(t = []) { this.queries = t } elementStart(t, e) { for (let i = 0; i < this.queries.length; i++)this.queries[i].elementStart(t, e) } elementEnd(t) { for (let e = 0; e < this.queries.length; e++)this.queries[e].elementEnd(t) } embeddedTView(t) { let e = null; for (let i = 0; i < this.length; i++) { const n = null !== e ? e.length : 0, s = this.getByIndex(i).embeddedTView(t, n); s && (s.indexInDeclarationView = i, null !== e ? e.push(s) : e = [s]) } return null !== e ? new rl(e) : null } template(t, e) { for (let i = 0; i < this.queries.length; i++)this.queries[i].template(t, e) } getByIndex(t) { return this.queries[t] } get length() { return this.queries.length } track(t) { this.queries.push(t) } } class ol { constructor(t, e = -1) { this.metadata = t, this.matches = null, this.indexInDeclarationView = -1, this.crossesNgTemplate = !1, this._appliesToNextNode = !0, this._declarationNodeIndex = e } elementStart(t, e) { this.isApplyingToNode(e) && this.matchTNode(t, e) } elementEnd(t) { this._declarationNodeIndex === t.index && (this._appliesToNextNode = !1) } template(t, e) { this.elementStart(t, e) } embeddedTView(t, e) { return this.isApplyingToNode(t) ? (this.crossesNgTemplate = !0, this.addMatch(-t.index, e), new ol(this.metadata)) : null } isApplyingToNode(t) { if (this._appliesToNextNode && 1 != (1 & this.metadata.flags)) { const e = this._declarationNodeIndex; let i = t.parent; for (; null !== i && 8 & i.type && i.index !== e;)i = i.parent; return e === (null !== i ? i.index : -1) } return this._appliesToNextNode } matchTNode(t, e) { const i = this.metadata.predicate; if (Array.isArray(i)) for (let n = 0; n < i.length; n++) { const s = i[n]; this.matchTNodeWithReadOption(t, e, al(e, s)), this.matchTNodeWithReadOption(t, e, Fi(e, t, s, !1, !1)) } else i === Ea ? 4 & e.type && this.matchTNodeWithReadOption(t, e, -1) : this.matchTNodeWithReadOption(t, e, Fi(e, t, i, !1, !1)) } matchTNodeWithReadOption(t, e, i) { if (null !== i) { const n = this.metadata.read; if (null !== n) if (n === Ko || n === Ma || n === Ea && 4 & e.type) this.addMatch(e.index, -2); else { const i = Fi(e, t, n, !1, !1); null !== i && this.addMatch(e.index, i) } else this.addMatch(e.index, i) } } addMatch(t, e) { null === this.matches ? this.matches = [t, e] : this.matches.push(t, e) } } function al(t, e) { const i = t.localNames; if (null !== i) for (let n = 0; n < i.length; n += 2)if (i[n] === e) return i[n + 1]; return null } function ll(t, e, i, n) { return -1 === i ? function (t, e) { return 11 & t.type ? Go(t, e) : 4 & t.type ? Da(t, e) : null }(e, t) : -2 === i ? function (t, e, i) { return i === Ko ? Go(e, t) : i === Ea ? Da(e, t) : i === Ma ? ja(e, t) : void 0 }(t, e, n) : Ni(t, t[1], i, e) } function cl(t, e, i, n) { const s = e[19].queries[n]; if (null === s.matches) { const n = t.data, r = i.matches, o = []; for (let t = 0; t < r.length; t += 2) { const s = r[t]; o.push(s < 0 ? null : ll(e, n[s], r[t + 1], i.metadata.read)) } s.matches = o } return s.matches } function hl(t, e, i, n) { const s = t.queries.getByIndex(i), r = s.matches; if (null !== r) { const o = cl(t, e, s, i); for (let t = 0; t < r.length; t += 2) { const i = r[t]; if (i > 0) n.push(o[t / 2]); else { const s = r[t + 1], o = e[-i]; for (let t = Jt; t < o.length; t++) { const e = o[t]; e[17] === e[3] && hl(e[1], e, s, n) } if (null !== o[9]) { const t = o[9]; for (let e = 0; e < t.length; e++) { const i = t[e]; hl(i[1], i, s, n) } } } } } return n } function ul(t) { const e = De(), i = Ae(), n = We(); qe(n + 1); const s = ml(i, n); if (t.dirty && xe(e) === (2 == (2 & s.metadata.flags))) { if (null === s.matches) t.reset([]); else { const r = s.crossesNgTemplate ? hl(i, e, n, []) : cl(i, e, s, n); t.reset(r, Yo), t.notifyOnChanges() } return !0 } return !1 } function dl(t, e, i, n) { const s = Ae(); if (s.firstCreatePass) { const r = Re(); gl(s, new sl(e, i, n), r.index), function (t, e) { const i = t.contentQueries || (t.contentQueries = []); e !== (i.length ? i[i.length - 1] : -1) && i.push(t.queries.length - 1, e) }(s, t), 2 == (2 & i) && (s.staticContentQueries = !0) } fl(s, De(), i) } function pl() { return t = De(), e = We(), t[19].queries[e].queryList; var t, e } function fl(t, e, i) { const n = new el(4 == (4 & i)); js(t, e, n, n.destroy), null === e[19] && (e[19] = new nl), e[19].queries.push(new il(n)) } function gl(t, e, i) { null === t.queries && (t.queries = new rl), t.queries.track(new ol(e, i)) } function ml(t, e) { return t.queries.getByIndex(e) } function _l(t, e) { return Da(t, e) } const vl = new Wi("Application Initializer"); let yl = (() => { class t { constructor(t) { this.appInits = t, this.resolve = qo, this.reject = qo, this.initialized = !1, this.done = !1, this.donePromise = new Promise((t, e) => { this.resolve = t, this.reject = e }) } runInitializers() { if (this.initialized) return; const t = [], e = () => { this.done = !0, this.resolve() }; if (this.appInits) for (let i = 0; i < this.appInits.length; i++) { const e = this.appInits[i](); if (Qr(e)) t.push(e); else if (Xr(e)) { const i = new Promise((t, i) => { e.subscribe({ complete: t, error: i }) }); t.push(i) } } Promise.all(t).then(() => { e() }).catch(t => { this.reject(t) }), 0 === t.length && e(), this.initialized = !0 } } return t.\u0275fac = function (e) { return new (e || t)(hn(vl, 8)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); const bl = new Wi("AppId"), wl = { provide: bl, useFactory: function () { return `${xl()}${xl()}${xl()}` }, deps: [] }; function xl() { return String.fromCharCode(97 + Math.floor(25 * Math.random())) } const Sl = new Wi("Platform Initializer"), kl = new Wi("Platform ID"), Cl = new Wi("appBootstrapListener"); let El = (() => { class t { log(t) { console.log(t) } warn(t) { console.warn(t) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); const Tl = new Wi("LocaleId"), Pl = new Wi("DefaultCurrencyCode"); class Dl { constructor(t, e) { this.ngModuleFactory = t, this.componentFactories = e } } const Al = function (t) { return new Ga(t) }, Ol = Al, Rl = function (t) { return Promise.resolve(Al(t)) }, Ml = function (t) { const e = Al(t), i = On(Qt(t).declarations).reduce((t, e) => { const i = Yt(e); return i && t.push(new $a(i)), t }, []); return new Dl(e, i) }, Il = Ml, Ll = function (t) { return Promise.resolve(Ml(t)) }; let Fl = (() => { class t { constructor() { this.compileModuleSync = Ol, this.compileModuleAsync = Rl, this.compileModuleAndAllComponentsSync = Il, this.compileModuleAndAllComponentsAsync = Ll } clearCache() { } clearCacheFor(t) { } getModuleId(t) { } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); const Nl = (() => Promise.resolve(0))(); function jl(t) { "undefined" == typeof Zone ? Nl.then(() => { t && t.apply(null, null) }) : Zone.current.scheduleMicroTask("scheduleMicrotask", t) } class Vl { constructor({ enableLongStackTrace: t = !1, shouldCoalesceEventChangeDetection: e = !1, shouldCoalesceRunChangeDetection: i = !1 }) { if (this.hasPendingMacrotasks = !1, this.hasPendingMicrotasks = !1, this.isStable = !0, this.onUnstable = new Ja(!1), this.onMicrotaskEmpty = new Ja(!1), this.onStable = new Ja(!1), this.onError = new Ja(!1), "undefined" == typeof Zone) throw new Error("In this configuration Angular requires Zone.js"); Zone.assertZonePatched(); const n = this; n._nesting = 0, n._outer = n._inner = Zone.current, Zone.TaskTrackingZoneSpec && (n._inner = n._inner.fork(new Zone.TaskTrackingZoneSpec)), t && Zone.longStackTraceZoneSpec && (n._inner = n._inner.fork(Zone.longStackTraceZoneSpec)), n.shouldCoalesceEventChangeDetection = !i && e, n.shouldCoalesceRunChangeDetection = i, n.lastRequestAnimationFrameId = -1, n.nativeRequestAnimationFrame = function () { let t = Rt.requestAnimationFrame, e = Rt.cancelAnimationFrame; if ("undefined" != typeof Zone && t && e) { const i = t[Zone.__symbol__("OriginalDelegate")]; i && (t = i); const n = e[Zone.__symbol__("OriginalDelegate")]; n && (e = n) } return { nativeRequestAnimationFrame: t, nativeCancelAnimationFrame: e } }().nativeRequestAnimationFrame, function (t) { const e = () => { !function (t) { t.isCheckStableRunning || -1 !== t.lastRequestAnimationFrameId || (t.lastRequestAnimationFrameId = t.nativeRequestAnimationFrame.call(Rt, () => { t.fakeTopEventTask || (t.fakeTopEventTask = Zone.root.scheduleEventTask("fakeTopEventTask", () => { t.lastRequestAnimationFrameId = -1, zl(t), t.isCheckStableRunning = !0, Hl(t), t.isCheckStableRunning = !1 }, void 0, () => { }, () => { })), t.fakeTopEventTask.invoke() }), zl(t)) }(t) }; t._inner = t._inner.fork({ name: "angular", properties: { isAngularZone: !0 }, onInvokeTask: (i, n, s, r, o, a) => { try { return $l(t), i.invokeTask(s, r, o, a) } finally { (t.shouldCoalesceEventChangeDetection && "eventTask" === r.type || t.shouldCoalesceRunChangeDetection) && e(), Ul(t) } }, onInvoke: (i, n, s, r, o, a, l) => { try { return $l(t), i.invoke(s, r, o, a, l) } finally { t.shouldCoalesceRunChangeDetection && e(), Ul(t) } }, onHasTask: (e, i, n, s) => { e.hasTask(n, s), i === n && ("microTask" == s.change ? (t._hasPendingMicrotasks = s.microTask, zl(t), Hl(t)) : "macroTask" == s.change && (t.hasPendingMacrotasks = s.macroTask)) }, onHandleError: (e, i, n, s) => (e.handleError(n, s), t.runOutsideAngular(() => t.onError.emit(s)), !1) }) }(n) } static isInAngularZone() { return !0 === Zone.current.get("isAngularZone") } static assertInAngularZone() { if (!Vl.isInAngularZone()) throw new Error("Expected to be in Angular Zone, but it is not!") } static assertNotInAngularZone() { if (Vl.isInAngularZone()) throw new Error("Expected to not be in Angular Zone, but it is!") } run(t, e, i) { return this._inner.run(t, e, i) } runTask(t, e, i, n) { const s = this._inner, r = s.scheduleEventTask("NgZoneEvent: " + n, t, Bl, qo, qo); try { return s.runTask(r, e, i) } finally { s.cancelTask(r) } } runGuarded(t, e, i) { return this._inner.runGuarded(t, e, i) } runOutsideAngular(t) { return this._outer.run(t) } } const Bl = {}; function Hl(t) { if (0 == t._nesting && !t.hasPendingMicrotasks && !t.isStable) try { t._nesting++, t.onMicrotaskEmpty.emit(null) } finally { if (t._nesting--, !t.hasPendingMicrotasks) try { t.runOutsideAngular(() => t.onStable.emit(null)) } finally { t.isStable = !0 } } } function zl(t) { t.hasPendingMicrotasks = !!(t._hasPendingMicrotasks || (t.shouldCoalesceEventChangeDetection || t.shouldCoalesceRunChangeDetection) && -1 !== t.lastRequestAnimationFrameId) } function $l(t) { t._nesting++, t.isStable && (t.isStable = !1, t.onUnstable.emit(null)) } function Ul(t) { t._nesting--, Hl(t) } class Wl { constructor() { this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, this.onUnstable = new Ja, this.onMicrotaskEmpty = new Ja, this.onStable = new Ja, this.onError = new Ja } run(t, e, i) { return t.apply(e, i) } runGuarded(t, e, i) { return t.apply(e, i) } runOutsideAngular(t) { return t() } runTask(t, e, i, n) { return t.apply(e, i) } } let ql = (() => { class t { constructor(t) { this._ngZone = t, this._pendingCount = 0, this._isZoneStable = !0, this._didWork = !1, this._callbacks = [], this.taskTrackingZone = null, this._watchAngularEvents(), t.run(() => { this.taskTrackingZone = "undefined" == typeof Zone ? null : Zone.current.get("TaskTrackingZone") }) } _watchAngularEvents() { this._ngZone.onUnstable.subscribe({ next: () => { this._didWork = !0, this._isZoneStable = !1 } }), this._ngZone.runOutsideAngular(() => { this._ngZone.onStable.subscribe({ next: () => { Vl.assertNotInAngularZone(), jl(() => { this._isZoneStable = !0, this._runCallbacksIfReady() }) } }) }) } increasePendingRequestCount() { return this._pendingCount += 1, this._didWork = !0, this._pendingCount } decreasePendingRequestCount() { if (this._pendingCount -= 1, this._pendingCount < 0) throw new Error("pending async requests below zero"); return this._runCallbacksIfReady(), this._pendingCount } isStable() { return this._isZoneStable && 0 === this._pendingCount && !this._ngZone.hasPendingMacrotasks } _runCallbacksIfReady() { if (this.isStable()) jl(() => { for (; 0 !== this._callbacks.length;) { let t = this._callbacks.pop(); clearTimeout(t.timeoutId), t.doneCb(this._didWork) } this._didWork = !1 }); else { let t = this.getPendingTasks(); this._callbacks = this._callbacks.filter(e => !e.updateCb || !e.updateCb(t) || (clearTimeout(e.timeoutId), !1)), this._didWork = !0 } } getPendingTasks() { return this.taskTrackingZone ? this.taskTrackingZone.macroTasks.map(t => ({ source: t.source, creationLocation: t.creationLocation, data: t.data })) : [] } addCallback(t, e, i) { let n = -1; e && e > 0 && (n = setTimeout(() => { this._callbacks = this._callbacks.filter(t => t.timeoutId !== n), t(this._didWork, this.getPendingTasks()) }, e)), this._callbacks.push({ doneCb: t, timeoutId: n, updateCb: i }) } whenStable(t, e, i) { if (i && !this.taskTrackingZone) throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?'); this.addCallback(t, e, i), this._runCallbacksIfReady() } getPendingRequestCount() { return this._pendingCount } findProviders(t, e, i) { return [] } } return t.\u0275fac = function (e) { return new (e || t)(hn(Vl)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), Gl = (() => { class t { constructor() { this._applications = new Map, Yl.addToWindow(this) } registerApplication(t, e) { this._applications.set(t, e) } unregisterApplication(t) { this._applications.delete(t) } unregisterAllApplications() { this._applications.clear() } getTestability(t) { return this._applications.get(t) || null } getAllTestabilities() { return Array.from(this._applications.values()) } getAllRootElements() { return Array.from(this._applications.keys()) } findTestabilityInTree(t, e = !0) { return Yl.findTestabilityInTree(this, t, e) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); class Zl { addToWindow(t) { } findTestabilityInTree(t, e, i) { return null } } let Kl, Yl = new Zl, Ql = !0, Xl = !1; function Jl() { return Xl = !0, Ql } const tc = new Wi("AllowMultipleToken"); class ec { constructor(t, e) { this.name = t, this.token = e } } function ic(t, e, i = []) { const n = `Platform: ${e}`, s = new Wi(n); return (e = []) => { let r = nc(); if (!r || r.injector.get(tc, !1)) if (t) t(i.concat(e).concat({ provide: s, useValue: !0 })); else { const t = i.concat(e).concat({ provide: s, useValue: !0 }, { provide: gr, useValue: "platform" }); !function (t) { if (Kl && !Kl.destroyed && !Kl.injector.get(tc, !1)) throw new Error("There can be only one platform. Destroy the previous one to create a new one."); Kl = t.get(sc); const e = t.get(Sl, null); e && e.forEach(t => t()) }(Pr.create({ providers: t, name: n })) } return function (t) { const e = nc(); if (!e) throw new Error("No platform exists!"); if (!e.injector.get(t, null)) throw new Error("A platform with a different configuration has been created. Please destroy it first."); return e }(s) } } function nc() { return Kl && !Kl.destroyed ? Kl : null } let sc = (() => { class t { constructor(t) { this._injector = t, this._modules = [], this._destroyListeners = [], this._destroyed = !1 } bootstrapModuleFactory(t, e) { const i = function (t, e) { let i; return i = "noop" === t ? new Wl : ("zone.js" === t ? void 0 : t) || new Vl({ enableLongStackTrace: Jl(), shouldCoalesceEventChangeDetection: !!(null == e ? void 0 : e.ngZoneEventCoalescing), shouldCoalesceRunChangeDetection: !!(null == e ? void 0 : e.ngZoneRunCoalescing) }), i }(e ? e.ngZone : void 0, { ngZoneEventCoalescing: e && e.ngZoneEventCoalescing || !1, ngZoneRunCoalescing: e && e.ngZoneRunCoalescing || !1 }), n = [{ provide: Vl, useValue: i }]; return i.run(() => { const e = Pr.create({ providers: n, parent: this.injector, name: t.moduleType.name }), s = t.create(e), r = s.injector.get(Pn, null); if (!r) throw new Error("No ErrorHandler. Is platform module (BrowserModule) included?"); return i.runOutsideAngular(() => { const t = i.onError.subscribe({ next: t => { r.handleError(t) } }); s.onDestroy(() => { ac(this._modules, s), t.unsubscribe() }) }), function (t, e, i) { try { const n = i(); return Qr(n) ? n.catch(i => { throw e.runOutsideAngular(() => t.handleError(i)), i }) : n } catch (n) { throw e.runOutsideAngular(() => t.handleError(n)), n } }(r, i, () => { const t = s.injector.get(yl); return t.runInitializers(), t.donePromise.then(() => (Io(s.injector.get(Tl, Ro) || Ro), this._moduleDoBootstrap(s), s)) }) }) } bootstrapModule(t, e = []) { const i = rc({}, e); return function (t, e, i) { const n = new Ga(i); return Promise.resolve(n) }(0, 0, t).then(t => this.bootstrapModuleFactory(t, i)) } _moduleDoBootstrap(t) { const e = t.injector.get(oc); if (t._bootstrapComponents.length > 0) t._bootstrapComponents.forEach(t => e.bootstrap(t)); else { if (!t.instance.ngDoBootstrap) throw new Error(`The module ${it(t.instance.constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. Please define one of these.`); t.instance.ngDoBootstrap(e) } this._modules.push(t) } onDestroy(t) { this._destroyListeners.push(t) } get injector() { return this._injector } destroy() { if (this._destroyed) throw new Error("The platform has already been destroyed!"); this._modules.slice().forEach(t => t.destroy()), this._destroyListeners.forEach(t => t()), this._destroyed = !0 } get destroyed() { return this._destroyed } } return t.\u0275fac = function (e) { return new (e || t)(hn(Pr)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); function rc(t, e) { return Array.isArray(e) ? e.reduce(rc, t) : Object.assign(Object.assign({}, t), e) } let oc = (() => { class t { constructor(t, e, i, n, s) { this._zone = t, this._injector = e, this._exceptionHandler = i, this._componentFactoryResolver = n, this._initStatus = s, this._bootstrapListeners = [], this._views = [], this._runningTick = !1, this._stable = !0, this.componentTypes = [], this.components = [], this._onMicrotaskEmptySubscription = this._zone.onMicrotaskEmpty.subscribe({ next: () => { this._zone.run(() => { this.tick() }) } }); const r = new v(t => { this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks, this._zone.runOutsideAngular(() => { t.next(this._stable), t.complete() }) }), o = new v(t => { let e; this._zone.runOutsideAngular(() => { e = this._zone.onStable.subscribe(() => { Vl.assertNotInAngularZone(), jl(() => { this._stable || this._zone.hasPendingMacrotasks || this._zone.hasPendingMicrotasks || (this._stable = !0, t.next(!0)) }) }) }); const i = this._zone.onUnstable.subscribe(() => { Vl.assertInAngularZone(), this._stable && (this._stable = !1, this._zone.runOutsideAngular(() => { t.next(!1) })) }); return () => { e.unsubscribe(), i.unsubscribe() } }); this.isStable = q(r, o.pipe(t => { return G()((e = J, function (t) { let i; i = "function" == typeof e ? e : function () { return e }; const n = Object.create(t, Q); return n.source = t, n.subjectFactory = i, n })(t)); var e })) } bootstrap(t, e) { if (!this._initStatus.done) throw new Error("Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module."); let i; i = t instanceof $o ? t : this._componentFactoryResolver.resolveComponentFactory(t), this.componentTypes.push(i.componentType); const n = i.isBoundToModule ? void 0 : this._injector.get(Aa), s = i.create(Pr.NULL, [], e || i.selector, n), r = s.location.nativeElement, o = s.injector.get(ql, null), a = o && s.injector.get(Gl); return o && a && a.registerApplication(r, o), s.onDestroy(() => { this.detachView(s.hostView), ac(this.components, s), a && a.unregisterApplication(r) }), this._loadComponent(s), s } tick() { if (this._runningTick) throw new Error("ApplicationRef.tick is called recursively"); try { this._runningTick = !0; for (let t of this._views) t.detectChanges() } catch (t) { this._zone.runOutsideAngular(() => this._exceptionHandler.handleError(t)) } finally { this._runningTick = !1 } } attachView(t) { const e = t; this._views.push(e), e.attachToAppRef(this) } detachView(t) { const e = t; ac(this._views, e), e.detachFromAppRef() } _loadComponent(t) { this.attachView(t.hostView), this.tick(), this.components.push(t), this._injector.get(Cl, []).concat(this._bootstrapListeners).forEach(e => e(t)) } ngOnDestroy() { this._views.slice().forEach(t => t.destroy()), this._onMicrotaskEmptySubscription.unsubscribe() } get viewCount() { return this._views.length } } return t.\u0275fac = function (e) { return new (e || t)(hn(Vl), hn(Pr), hn(Pn), hn(Wo), hn(yl)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); function ac(t, e) { const i = t.indexOf(e); i > -1 && t.splice(i, 1) } class lc { } class cc { } const hc = { factoryPathPrefix: "", factoryPathSuffix: ".ngfactory" }; let uc = (() => { class t { constructor(t, e) { this._compiler = t, this._config = e || hc } load(t) { return this.loadAndCompile(t) } loadAndCompile(t) { let [e, n] = t.split("#"); return void 0 === n && (n = "default"), i(255)(e).then(t => t[n]).then(t => dc(t, e, n)).then(t => this._compiler.compileModuleAsync(t)) } loadFactory(t) { let [e, n] = t.split("#"), s = "NgFactory"; return void 0 === n && (n = "default", s = ""), i(255)(this._config.factoryPathPrefix + e + this._config.factoryPathSuffix).then(t => t[n + s]).then(t => dc(t, e, n)) } } return t.\u0275fac = function (e) { return new (e || t)(hn(Fl), hn(cc, 8)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); function dc(t, e, i) { if (!t) throw new Error(`Cannot find '${i}' in '${e}'`); return t } const pc = ic(null, "core", [{ provide: kl, useValue: "unknown" }, { provide: sc, deps: [Pr] }, { provide: Gl, deps: [] }, { provide: El, deps: [] }]), fc = [{ provide: oc, useClass: oc, deps: [Vl, Pr, Pn, Wo, yl] }, { provide: za, deps: [Vl], useFactory: function (t) { let e = []; return t.onStable.subscribe(() => { for (; e.length;)e.pop()() }), function (t) { e.push(t) } } }, { provide: yl, useClass: yl, deps: [[new gn, vl]] }, { provide: Fl, useClass: Fl, deps: [] }, wl, { provide: fa, useFactory: function () { return Sa }, deps: [] }, { provide: ma, useFactory: function () { return ka }, deps: [] }, { provide: Tl, useFactory: function (t) { return Io(t = t || "undefined" != typeof $localize && $localize.locale || Ro), t }, deps: [[new fn(Tl), new gn, new mn]] }, { provide: Pl, useValue: "USD" }]; let gc = (() => { class t { constructor(t) { } } return t.\u0275fac = function (e) { return new (e || t)(hn(oc)) }, t.\u0275mod = Gt({ type: t }), t.\u0275inj = pt({ providers: fc }), t })(), mc = null; function _c() { return mc } const vc = new Wi("DocumentToken"); let yc = (() => { class t { historyGo(t) { throw new Error("Not implemented") } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = dt({ factory: bc, token: t, providedIn: "platform" }), t })(); function bc() { return hn(xc) } const wc = new Wi("Location Initialized"); let xc = (() => { class t extends yc { constructor(t) { super(), this._doc = t, this._init() } _init() { this.location = window.location, this._history = window.history } getBaseHrefFromDOM() { return _c().getBaseHref(this._doc) } onPopState(t) { const e = _c().getGlobalEventTarget(this._doc, "window"); return e.addEventListener("popstate", t, !1), () => e.removeEventListener("popstate", t) } onHashChange(t) { const e = _c().getGlobalEventTarget(this._doc, "window"); return e.addEventListener("hashchange", t, !1), () => e.removeEventListener("hashchange", t) } get href() { return this.location.href } get protocol() { return this.location.protocol } get hostname() { return this.location.hostname } get port() { return this.location.port } get pathname() { return this.location.pathname } get search() { return this.location.search } get hash() { return this.location.hash } set pathname(t) { this.location.pathname = t } pushState(t, e, i) { Sc() ? this._history.pushState(t, e, i) : this.location.hash = i } replaceState(t, e, i) { Sc() ? this._history.replaceState(t, e, i) : this.location.hash = i } forward() { this._history.forward() } back() { this._history.back() } historyGo(t = 0) { this._history.go(t) } getState() { return this._history.state } } return t.\u0275fac = function (e) { return new (e || t)(hn(vc)) }, t.\u0275prov = dt({ factory: kc, token: t, providedIn: "platform" }), t })(); function Sc() { return !!window.history.pushState } function kc() { return new xc(hn(vc)) } function Cc(t, e) { if (0 == t.length) return e; if (0 == e.length) return t; let i = 0; return t.endsWith("/") && i++, e.startsWith("/") && i++, 2 == i ? t + e.substring(1) : 1 == i ? t + e : t + "/" + e } function Ec(t) { const e = t.match(/#|\?|$/), i = e && e.index || t.length; return t.slice(0, i - ("/" === t[i - 1] ? 1 : 0)) + t.slice(i) } function Tc(t) { return t && "?" !== t[0] ? "?" + t : t } let Pc = (() => { class t { historyGo(t) { throw new Error("Not implemented") } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = dt({ factory: Dc, token: t, providedIn: "root" }), t })(); function Dc(t) { const e = hn(vc).location; return new Oc(hn(yc), e && e.origin || "") } const Ac = new Wi("appBaseHref"); let Oc = (() => { class t extends Pc { constructor(t, e) { if (super(), this._platformLocation = t, this._removeListenerFns = [], null == e && (e = this._platformLocation.getBaseHrefFromDOM()), null == e) throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document."); this._baseHref = e } ngOnDestroy() { for (; this._removeListenerFns.length;)this._removeListenerFns.pop()() } onPopState(t) { this._removeListenerFns.push(this._platformLocation.onPopState(t), this._platformLocation.onHashChange(t)) } getBaseHref() { return this._baseHref } prepareExternalUrl(t) { return Cc(this._baseHref, t) } path(t = !1) { const e = this._platformLocation.pathname + Tc(this._platformLocation.search), i = this._platformLocation.hash; return i && t ? `${e}${i}` : e } pushState(t, e, i, n) { const s = this.prepareExternalUrl(i + Tc(n)); this._platformLocation.pushState(t, e, s) } replaceState(t, e, i, n) { const s = this.prepareExternalUrl(i + Tc(n)); this._platformLocation.replaceState(t, e, s) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } historyGo(t = 0) { var e, i; null === (i = (e = this._platformLocation).historyGo) || void 0 === i || i.call(e, t) } } return t.\u0275fac = function (e) { return new (e || t)(hn(yc), hn(Ac, 8)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), Rc = (() => { class t extends Pc { constructor(t, e) { super(), this._platformLocation = t, this._baseHref = "", this._removeListenerFns = [], null != e && (this._baseHref = e) } ngOnDestroy() { for (; this._removeListenerFns.length;)this._removeListenerFns.pop()() } onPopState(t) { this._removeListenerFns.push(this._platformLocation.onPopState(t), this._platformLocation.onHashChange(t)) } getBaseHref() { return this._baseHref } path(t = !1) { let e = this._platformLocation.hash; return null == e && (e = "#"), e.length > 0 ? e.substring(1) : e } prepareExternalUrl(t) { const e = Cc(this._baseHref, t); return e.length > 0 ? "#" + e : e } pushState(t, e, i, n) { let s = this.prepareExternalUrl(i + Tc(n)); 0 == s.length && (s = this._platformLocation.pathname), this._platformLocation.pushState(t, e, s) } replaceState(t, e, i, n) { let s = this.prepareExternalUrl(i + Tc(n)); 0 == s.length && (s = this._platformLocation.pathname), this._platformLocation.replaceState(t, e, s) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } historyGo(t = 0) { var e, i; null === (i = (e = this._platformLocation).historyGo) || void 0 === i || i.call(e, t) } } return t.\u0275fac = function (e) { return new (e || t)(hn(yc), hn(Ac, 8)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), Mc = (() => { class t { constructor(t, e) { this._subject = new Ja, this._urlChangeListeners = [], this._platformStrategy = t; const i = this._platformStrategy.getBaseHref(); this._platformLocation = e, this._baseHref = Ec(Lc(i)), this._platformStrategy.onPopState(t => { this._subject.emit({ url: this.path(!0), pop: !0, state: t.state, type: t.type }) }) } path(t = !1) { return this.normalize(this._platformStrategy.path(t)) } getState() { return this._platformLocation.getState() } isCurrentPathEqualTo(t, e = "") { return this.path() == this.normalize(t + Tc(e)) } normalize(e) { return t.stripTrailingSlash(function (t, e) { return t && e.startsWith(t) ? e.substring(t.length) : e }(this._baseHref, Lc(e))) } prepareExternalUrl(t) { return t && "/" !== t[0] && (t = "/" + t), this._platformStrategy.prepareExternalUrl(t) } go(t, e = "", i = null) { this._platformStrategy.pushState(i, "", t, e), this._notifyUrlChangeListeners(this.prepareExternalUrl(t + Tc(e)), i) } replaceState(t, e = "", i = null) { this._platformStrategy.replaceState(i, "", t, e), this._notifyUrlChangeListeners(this.prepareExternalUrl(t + Tc(e)), i) } forward() { this._platformStrategy.forward() } back() { this._platformStrategy.back() } historyGo(t = 0) { var e, i; null === (i = (e = this._platformStrategy).historyGo) || void 0 === i || i.call(e, t) } onUrlChange(t) { this._urlChangeListeners.push(t), this._urlChangeSubscription || (this._urlChangeSubscription = this.subscribe(t => { this._notifyUrlChangeListeners(t.url, t.state) })) } _notifyUrlChangeListeners(t = "", e) { this._urlChangeListeners.forEach(i => i(t, e)) } subscribe(t, e, i) { return this._subject.subscribe({ next: t, error: e, complete: i }) } } return t.\u0275fac = function (e) { return new (e || t)(hn(Pc), hn(yc)) }, t.normalizeQueryParams = Tc, t.joinWithSlash = Cc, t.stripTrailingSlash = Ec, t.\u0275prov = dt({ factory: Ic, token: t, providedIn: "root" }), t })(); function Ic() { return new Mc(hn(Pc), hn(yc)) } function Lc(t) { return t.replace(/\/index.html$/, "") } var Fc = function (t) { return t[t.Zero = 0] = "Zero", t[t.One = 1] = "One", t[t.Two = 2] = "Two", t[t.Few = 3] = "Few", t[t.Many = 4] = "Many", t[t.Other = 5] = "Other", t }({}); class Nc { } let jc = (() => { class t extends Nc { constructor(t) { super(), this.locale = t } getPluralCategory(t, e) { switch (function (t) { return function (t) { const e = function (t) { return t.toLowerCase().replace(/_/g, "-") }(t); let i = Ao(e); if (i) return i; const n = e.split("-")[0]; if (i = Ao(n), i) return i; if ("en" === n) return Po; throw new Error(`Missing locale data for the locale "${t}".`) }(t)[Oo.PluralCase] }(e || this.locale)(t)) { case Fc.Zero: return "zero"; case Fc.One: return "one"; case Fc.Two: return "two"; case Fc.Few: return "few"; case Fc.Many: return "many"; default: return "other" } } } return t.\u0275fac = function (e) { return new (e || t)(hn(Tl)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); function Vc(t, e) { e = encodeURIComponent(e); for (const i of t.split(";")) { const t = i.indexOf("="), [n, s] = -1 == t ? [i, ""] : [i.slice(0, t), i.slice(t + 1)]; if (n.trim() === e) return decodeURIComponent(s) } return null } let Bc = (() => { class t { constructor(t, e, i, n) { this._iterableDiffers = t, this._keyValueDiffers = e, this._ngEl = i, this._renderer = n, this._iterableDiffer = null, this._keyValueDiffer = null, this._initialClasses = [], this._rawClass = null } set klass(t) { this._removeClasses(this._initialClasses), this._initialClasses = "string" == typeof t ? t.split(/\s+/) : [], this._applyClasses(this._initialClasses), this._applyClasses(this._rawClass) } set ngClass(t) { this._removeClasses(this._rawClass), this._applyClasses(this._initialClasses), this._iterableDiffer = null, this._keyValueDiffer = null, this._rawClass = "string" == typeof t ? t.split(/\s+/) : t, this._rawClass && (Nr(this._rawClass) ? this._iterableDiffer = this._iterableDiffers.find(this._rawClass).create() : this._keyValueDiffer = this._keyValueDiffers.find(this._rawClass).create()) } ngDoCheck() { if (this._iterableDiffer) { const t = this._iterableDiffer.diff(this._rawClass); t && this._applyIterableChanges(t) } else if (this._keyValueDiffer) { const t = this._keyValueDiffer.diff(this._rawClass); t && this._applyKeyValueChanges(t) } } _applyKeyValueChanges(t) { t.forEachAddedItem(t => this._toggleClass(t.key, t.currentValue)), t.forEachChangedItem(t => this._toggleClass(t.key, t.currentValue)), t.forEachRemovedItem(t => { t.previousValue && this._toggleClass(t.key, !1) }) } _applyIterableChanges(t) { t.forEachAddedItem(t => { if ("string" != typeof t.item) throw new Error(`NgClass can only toggle CSS classes expressed as strings, got ${it(t.item)}`); this._toggleClass(t.item, !0) }), t.forEachRemovedItem(t => this._toggleClass(t.item, !1)) } _applyClasses(t) { t && (Array.isArray(t) || t instanceof Set ? t.forEach(t => this._toggleClass(t, !0)) : Object.keys(t).forEach(e => this._toggleClass(e, !!t[e]))) } _removeClasses(t) { t && (Array.isArray(t) || t instanceof Set ? t.forEach(t => this._toggleClass(t, !1)) : Object.keys(t).forEach(t => this._toggleClass(t, !1))) } _toggleClass(t, e) { (t = t.trim()) && t.split(/\s+/g).forEach(t => { e ? this._renderer.addClass(this._ngEl.nativeElement, t) : this._renderer.removeClass(this._ngEl.nativeElement, t) }) } } return t.\u0275fac = function (e) { return new (e || t)(Ur(fa), Ur(ma), Ur(Ko), Ur(Xo)) }, t.\u0275dir = Kt({ type: t, selectors: [["", "ngClass", ""]], inputs: { klass: ["class", "klass"], ngClass: "ngClass" } }), t })(); class Hc { constructor(t, e, i, n) { this.$implicit = t, this.ngForOf = e, this.index = i, this.count = n } get first() { return 0 === this.index } get last() { return this.index === this.count - 1 } get even() { return this.index % 2 == 0 } get odd() { return !this.even } } let zc = (() => { class t { constructor(t, e, i) { this._viewContainer = t, this._template = e, this._differs = i, this._ngForOf = null, this._ngForOfDirty = !0, this._differ = null } set ngForOf(t) { this._ngForOf = t, this._ngForOfDirty = !0 } set ngForTrackBy(t) { this._trackByFn = t } get ngForTrackBy() { return this._trackByFn } set ngForTemplate(t) { t && (this._template = t) } ngDoCheck() { if (this._ngForOfDirty) { this._ngForOfDirty = !1; const i = this._ngForOf; if (!this._differ && i) try { this._differ = this._differs.find(i).create(this.ngForTrackBy) } catch (e) { throw new Error(`Cannot find a differ supporting object '${i}' of type '${t = i, t.name || typeof t}'. NgFor only supports binding to Iterables such as Arrays.`) } } var t; if (this._differ) { const t = this._differ.diff(this._ngForOf); t && this._applyChanges(t) } } _applyChanges(t) { const e = []; t.forEachOperation((t, i, n) => { if (null == t.previousIndex) { const i = this._viewContainer.createEmbeddedView(this._template, new Hc(null, this._ngForOf, -1, -1), null === n ? void 0 : n), s = new $c(t, i); e.push(s) } else if (null == n) this._viewContainer.remove(null === i ? void 0 : i); else if (null !== i) { const s = this._viewContainer.get(i); this._viewContainer.move(s, n); const r = new $c(t, s); e.push(r) } }); for (let i = 0; i < e.length; i++)this._perViewChange(e[i].view, e[i].record); for (let i = 0, n = this._viewContainer.length; i < n; i++) { const t = this._viewContainer.get(i); t.context.index = i, t.context.count = n, t.context.ngForOf = this._ngForOf } t.forEachIdentityChange(t => { this._viewContainer.get(t.currentIndex).context.$implicit = t.item }) } _perViewChange(t, e) { t.context.$implicit = e.item } static ngTemplateContextGuard(t, e) { return !0 } } return t.\u0275fac = function (e) { return new (e || t)(Ur(Ma), Ur(Ea), Ur(fa)) }, t.\u0275dir = Kt({ type: t, selectors: [["", "ngFor", "", "ngForOf", ""]], inputs: { ngForOf: "ngForOf", ngForTrackBy: "ngForTrackBy", ngForTemplate: "ngForTemplate" } }), t })(); class $c { constructor(t, e) { this.record = t, this.view = e } } let Uc = (() => { class t { constructor(t, e) { this._viewContainer = t, this._context = new Wc, this._thenTemplateRef = null, this._elseTemplateRef = null, this._thenViewRef = null, this._elseViewRef = null, this._thenTemplateRef = e } set ngIf(t) { this._context.$implicit = this._context.ngIf = t, this._updateView() } set ngIfThen(t) { qc("ngIfThen", t), this._thenTemplateRef = t, this._thenViewRef = null, this._updateView() } set ngIfElse(t) { qc("ngIfElse", t), this._elseTemplateRef = t, this._elseViewRef = null, this._updateView() } _updateView() { this._context.$implicit ? this._thenViewRef || (this._viewContainer.clear(), this._elseViewRef = null, this._thenTemplateRef && (this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context))) : this._elseViewRef || (this._viewContainer.clear(), this._thenViewRef = null, this._elseTemplateRef && (this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context))) } static ngTemplateContextGuard(t, e) { return !0 } } return t.\u0275fac = function (e) { return new (e || t)(Ur(Ma), Ur(Ea)) }, t.\u0275dir = Kt({ type: t, selectors: [["", "ngIf", ""]], inputs: { ngIf: "ngIf", ngIfThen: "ngIfThen", ngIfElse: "ngIfElse" } }), t })(); class Wc { constructor() { this.$implicit = null, this.ngIf = null } } function qc(t, e) { if (e && !e.createEmbeddedView) throw new Error(`${t} must be a TemplateRef, but received '${it(e)}'.`) } let Gc = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Gt({ type: t }), t.\u0275inj = pt({ providers: [{ provide: Nc, useClass: jc }] }), t })(); function Zc(t) { return "browser" === t } let Kc = (() => { class t { } return t.\u0275prov = dt({ token: t, providedIn: "root", factory: () => new Yc(hn(vc), window) }), t })(); class Yc { constructor(t, e) { this.document = t, this.window = e, this.offset = () => [0, 0] } setOffset(t) { this.offset = Array.isArray(t) ? () => t : t } getScrollPosition() { return this.supportsScrolling() ? [this.window.pageXOffset, this.window.pageYOffset] : [0, 0] } scrollToPosition(t) { this.supportsScrolling() && this.window.scrollTo(t[0], t[1]) } scrollToAnchor(t) { if (!this.supportsScrolling()) return; const e = function (t, e) { const i = t.getElementById(e) || t.getElementsByName(e)[0]; if (i) return i; if ("function" == typeof t.createTreeWalker && t.body && (t.body.createShadowRoot || t.body.attachShadow)) { const i = t.createTreeWalker(t.body, NodeFilter.SHOW_ELEMENT); let n = i.currentNode; for (; n;) { const t = n.shadowRoot; if (t) { const i = t.getElementById(e) || t.querySelector(`[name="${e}"]`); if (i) return i } n = i.nextNode() } } return null }(this.document, t); e && (this.scrollToElement(e), this.attemptFocus(e)) } setHistoryScrollRestoration(t) { if (this.supportScrollRestoration()) { const e = this.window.history; e && e.scrollRestoration && (e.scrollRestoration = t) } } scrollToElement(t) { const e = t.getBoundingClientRect(), i = e.left + this.window.pageXOffset, n = e.top + this.window.pageYOffset, s = this.offset(); this.window.scrollTo(i - s[0], n - s[1]) } attemptFocus(t) { return t.focus(), this.document.activeElement === t } supportScrollRestoration() { try { if (!this.supportsScrolling()) return !1; const t = Qc(this.window.history) || Qc(Object.getPrototypeOf(this.window.history)); return !(!t || !t.writable && !t.set) } catch (t) { return !1 } } supportsScrolling() { try { return !!this.window && !!this.window.scrollTo && "pageXOffset" in this.window } catch (t) { return !1 } } } function Qc(t) { return Object.getOwnPropertyDescriptor(t, "scrollRestoration") } class Xc { } class Jc extends class extends class { }{ constructor() { super(...arguments), this.supportsDOMEvents = !0 } }{ static makeCurrent() { var t; t = new Jc, mc || (mc = t) } onAndCancel(t, e, i) { return t.addEventListener(e, i, !1), () => { t.removeEventListener(e, i, !1) } } dispatchEvent(t, e) { t.dispatchEvent(e) } remove(t) { t.parentNode && t.parentNode.removeChild(t) } createElement(t, e) { return (e = e || this.getDefaultDocument()).createElement(t) } createHtmlDocument() { return document.implementation.createHTMLDocument("fakeTitle") } getDefaultDocument() { return document } isElementNode(t) { return t.nodeType === Node.ELEMENT_NODE } isShadowRoot(t) { return t instanceof DocumentFragment } getGlobalEventTarget(t, e) { return "window" === e ? window : "document" === e ? t : "body" === e ? t.body : null } getBaseHref(t) { const e = (eh = eh || document.querySelector("base"), eh ? eh.getAttribute("href") : null); return null == e ? null : function (t) { th = th || document.createElement("a"), th.setAttribute("href", t); const e = th.pathname; return "/" === e.charAt(0) ? e : `/${e}` }(e) } resetBaseElement() { eh = null } getUserAgent() { return window.navigator.userAgent } getCookie(t) { return Vc(document.cookie, t) } } let th, eh = null; const ih = new Wi("TRANSITION_ID"), nh = [{ provide: vl, useFactory: function (t, e, i) { return () => { i.get(yl).donePromise.then(() => { const i = _c(); Array.prototype.slice.apply(e.querySelectorAll("style[ng-transition]")).filter(e => e.getAttribute("ng-transition") === t).forEach(t => i.remove(t)) }) } }, deps: [ih, vc, Pr], multi: !0 }]; class sh { static init() { var t; t = new sh, Yl = t } addToWindow(t) { Rt.getAngularTestability = (e, i = !0) => { const n = t.findTestabilityInTree(e, i); if (null == n) throw new Error("Could not find testability for element."); return n }, Rt.getAllAngularTestabilities = () => t.getAllTestabilities(), Rt.getAllAngularRootElements = () => t.getAllRootElements(), Rt.frameworkStabilizers || (Rt.frameworkStabilizers = []), Rt.frameworkStabilizers.push(t => { const e = Rt.getAllAngularTestabilities(); let i = e.length, n = !1; const s = function (e) { n = n || e, i--, 0 == i && t(n) }; e.forEach(function (t) { t.whenStable(s) }) }) } findTestabilityInTree(t, e, i) { if (null == e) return null; const n = t.getTestability(e); return null != n ? n : i ? _c().isShadowRoot(e) ? this.findTestabilityInTree(t, e.host, !0) : this.findTestabilityInTree(t, e.parentElement, !0) : null } } let rh = (() => { class t { build() { return new XMLHttpRequest } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); const oh = new Wi("EventManagerPlugins"); let ah = (() => { class t { constructor(t, e) { this._zone = e, this._eventNameToPlugin = new Map, t.forEach(t => t.manager = this), this._plugins = t.slice().reverse() } addEventListener(t, e, i) { return this._findPluginFor(e).addEventListener(t, e, i) } addGlobalEventListener(t, e, i) { return this._findPluginFor(e).addGlobalEventListener(t, e, i) } getZone() { return this._zone } _findPluginFor(t) { const e = this._eventNameToPlugin.get(t); if (e) return e; const i = this._plugins; for (let n = 0; n < i.length; n++) { const e = i[n]; if (e.supports(t)) return this._eventNameToPlugin.set(t, e), e } throw new Error(`No event manager plugin found for event ${t}`) } } return t.\u0275fac = function (e) { return new (e || t)(hn(oh), hn(Vl)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); class lh { constructor(t) { this._doc = t } addGlobalEventListener(t, e, i) { const n = _c().getGlobalEventTarget(this._doc, t); if (!n) throw new Error(`Unsupported event target ${n} for event ${e}`); return this.addEventListener(n, e, i) } } let ch = (() => { class t { constructor() { this._stylesSet = new Set } addStyles(t) { const e = new Set; t.forEach(t => { this._stylesSet.has(t) || (this._stylesSet.add(t), e.add(t)) }), this.onStylesAdded(e) } onStylesAdded(t) { } getAllStyles() { return Array.from(this._stylesSet) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), hh = (() => { class t extends ch { constructor(t) { super(), this._doc = t, this._hostNodes = new Map, this._hostNodes.set(t.head, []) } _addStylesToHost(t, e, i) { t.forEach(t => { const n = this._doc.createElement("style"); n.textContent = t, i.push(e.appendChild(n)) }) } addHost(t) { const e = []; this._addStylesToHost(this._stylesSet, t, e), this._hostNodes.set(t, e) } removeHost(t) { const e = this._hostNodes.get(t); e && e.forEach(uh), this._hostNodes.delete(t) } onStylesAdded(t) { this._hostNodes.forEach((e, i) => { this._addStylesToHost(t, i, e) }) } ngOnDestroy() { this._hostNodes.forEach(t => t.forEach(uh)) } } return t.\u0275fac = function (e) { return new (e || t)(hn(vc)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); function uh(t) { _c().remove(t) } const dh = { svg: "http://www.w3.org/2000/svg", xhtml: "http://www.w3.org/1999/xhtml", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/" }, ph = /%COMP%/g; function fh(t, e, i) { for (let n = 0; n < e.length; n++) { let s = e[n]; Array.isArray(s) ? fh(t, s, i) : (s = s.replace(ph, t), i.push(s)) } return i } function gh(t) { return e => { if ("__ngUnwrap__" === e) return t; !1 === t(e) && (e.preventDefault(), e.returnValue = !1) } } let mh = (() => { class t { constructor(t, e, i) { this.eventManager = t, this.sharedStylesHost = e, this.appId = i, this.rendererByCompId = new Map, this.defaultRenderer = new _h(t) } createRenderer(t, e) { if (!t || !e) return this.defaultRenderer; switch (e.encapsulation) { case Tt.Emulated: { let i = this.rendererByCompId.get(e.id); return i || (i = new vh(this.eventManager, this.sharedStylesHost, e, this.appId), this.rendererByCompId.set(e.id, i)), i.applyToHost(t), i } case 1: case Tt.ShadowDom: return new yh(this.eventManager, this.sharedStylesHost, t, e); default: if (!this.rendererByCompId.has(e.id)) { const t = fh(e.id, e.styles, []); this.sharedStylesHost.addStyles(t), this.rendererByCompId.set(e.id, this.defaultRenderer) } return this.defaultRenderer } } begin() { } end() { } } return t.\u0275fac = function (e) { return new (e || t)(hn(ah), hn(hh), hn(bl)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); class _h { constructor(t) { this.eventManager = t, this.data = Object.create(null) } destroy() { } createElement(t, e) { return e ? document.createElementNS(dh[e] || e, t) : document.createElement(t) } createComment(t) { return document.createComment(t) } createText(t) { return document.createTextNode(t) } appendChild(t, e) { t.appendChild(e) } insertBefore(t, e, i) { t && t.insertBefore(e, i) } removeChild(t, e) { t && t.removeChild(e) } selectRootElement(t, e) { let i = "string" == typeof t ? document.querySelector(t) : t; if (!i) throw new Error(`The selector "${t}" did not match any elements`); return e || (i.textContent = ""), i } parentNode(t) { return t.parentNode } nextSibling(t) { return t.nextSibling } setAttribute(t, e, i, n) { if (n) { e = n + ":" + e; const s = dh[n]; s ? t.setAttributeNS(s, e, i) : t.setAttribute(e, i) } else t.setAttribute(e, i) } removeAttribute(t, e, i) { if (i) { const n = dh[i]; n ? t.removeAttributeNS(n, e) : t.removeAttribute(`${i}:${e}`) } else t.removeAttribute(e) } addClass(t, e) { t.classList.add(e) } removeClass(t, e) { t.classList.remove(e) } setStyle(t, e, i, n) { n & (Rn.DashCase | Rn.Important) ? t.style.setProperty(e, i, n & Rn.Important ? "important" : "") : t.style[e] = i } removeStyle(t, e, i) { i & Rn.DashCase ? t.style.removeProperty(e) : t.style[e] = "" } setProperty(t, e, i) { t[e] = i } setValue(t, e) { t.nodeValue = e } listen(t, e, i) { return "string" == typeof t ? this.eventManager.addGlobalEventListener(t, e, gh(i)) : this.eventManager.addEventListener(t, e, gh(i)) } } class vh extends _h { constructor(t, e, i, n) { super(t), this.component = i; const s = fh(n + "-" + i.id, i.styles, []); e.addStyles(s), this.contentAttr = "_ngcontent-%COMP%".replace(ph, n + "-" + i.id), this.hostAttr = "_nghost-%COMP%".replace(ph, n + "-" + i.id) } applyToHost(t) { super.setAttribute(t, this.hostAttr, "") } createElement(t, e) { const i = super.createElement(t, e); return super.setAttribute(i, this.contentAttr, ""), i } } class yh extends _h { constructor(t, e, i, n) { super(t), this.sharedStylesHost = e, this.hostEl = i, this.shadowRoot = i.attachShadow({ mode: "open" }), this.sharedStylesHost.addHost(this.shadowRoot); const s = fh(n.id, n.styles, []); for (let r = 0; r < s.length; r++) { const t = document.createElement("style"); t.textContent = s[r], this.shadowRoot.appendChild(t) } } nodeOrShadowRoot(t) { return t === this.hostEl ? this.shadowRoot : t } destroy() { this.sharedStylesHost.removeHost(this.shadowRoot) } appendChild(t, e) { return super.appendChild(this.nodeOrShadowRoot(t), e) } insertBefore(t, e, i) { return super.insertBefore(this.nodeOrShadowRoot(t), e, i) } removeChild(t, e) { return super.removeChild(this.nodeOrShadowRoot(t), e) } parentNode(t) { return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t))) } } let bh = (() => { class t extends lh { constructor(t) { super(t) } supports(t) { return !0 } addEventListener(t, e, i) { return t.addEventListener(e, i, !1), () => this.removeEventListener(t, e, i) } removeEventListener(t, e, i) { return t.removeEventListener(e, i) } } return t.\u0275fac = function (e) { return new (e || t)(hn(vc)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); const wh = ["alt", "control", "meta", "shift"], xh = { "\b": "Backspace", "\t": "Tab", "\x7f": "Delete", "\x1b": "Escape", Del: "Delete", Esc: "Escape", Left: "ArrowLeft", Right: "ArrowRight", Up: "ArrowUp", Down: "ArrowDown", Menu: "ContextMenu", Scroll: "ScrollLock", Win: "OS" }, Sh = { A: "1", B: "2", C: "3", D: "4", E: "5", F: "6", G: "7", H: "8", I: "9", J: "*", K: "+", M: "-", N: ".", O: "/", "`": "0", "\x90": "NumLock" }, kh = { alt: t => t.altKey, control: t => t.ctrlKey, meta: t => t.metaKey, shift: t => t.shiftKey }; let Ch = (() => { class t extends lh { constructor(t) { super(t) } supports(e) { return null != t.parseEventName(e) } addEventListener(e, i, n) { const s = t.parseEventName(i), r = t.eventCallback(s.fullKey, n, this.manager.getZone()); return this.manager.getZone().runOutsideAngular(() => _c().onAndCancel(e, s.domEventName, r)) } static parseEventName(e) { const i = e.toLowerCase().split("."), n = i.shift(); if (0 === i.length || "keydown" !== n && "keyup" !== n) return null; const s = t._normalizeKey(i.pop()); let r = ""; if (wh.forEach(t => { const e = i.indexOf(t); e > -1 && (i.splice(e, 1), r += t + ".") }), r += s, 0 != i.length || 0 === s.length) return null; const o = {}; return o.domEventName = n, o.fullKey = r, o } static getEventFullKey(t) { let e = "", i = function (t) { let e = t.key; if (null == e) { if (e = t.keyIdentifier, null == e) return "Unidentified"; e.startsWith("U+") && (e = String.fromCharCode(parseInt(e.substring(2), 16)), 3 === t.location && Sh.hasOwnProperty(e) && (e = Sh[e])) } return xh[e] || e }(t); return i = i.toLowerCase(), " " === i ? i = "space" : "." === i && (i = "dot"), wh.forEach(n => { n != i && (0, kh[n])(t) && (e += n + ".") }), e += i, e } static eventCallback(e, i, n) { return s => { t.getEventFullKey(s) === e && n.runGuarded(() => i(s)) } } static _normalizeKey(t) { switch (t) { case "esc": return "escape"; default: return t } } } return t.\u0275fac = function (e) { return new (e || t)(hn(vc)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); const Eh = ic(pc, "browser", [{ provide: kl, useValue: "browser" }, { provide: Sl, useValue: function () { Jc.makeCurrent(), sh.init() }, multi: !0 }, { provide: vc, useFactory: function () { return function (t) { fe = t }(document), document }, deps: [] }]), Th = [[], { provide: gr, useValue: "root" }, { provide: Pn, useFactory: function () { return new Pn }, deps: [] }, { provide: oh, useClass: bh, multi: !0, deps: [vc, Vl, kl] }, { provide: oh, useClass: Ch, multi: !0, deps: [vc] }, [], { provide: mh, useClass: mh, deps: [ah, hh, bl] }, { provide: Qo, useExisting: mh }, { provide: ch, useExisting: hh }, { provide: hh, useClass: hh, deps: [vc] }, { provide: ql, useClass: ql, deps: [Vl] }, { provide: ah, useClass: ah, deps: [oh, Vl] }, { provide: Xc, useClass: rh, deps: [] }, []]; let Ph = (() => { class t { constructor(t) { if (t) throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.") } static withServerTransition(e) { return { ngModule: t, providers: [{ provide: bl, useValue: e.appId }, { provide: ih, useExisting: bl }, nh] } } } return t.\u0275fac = function (e) { return new (e || t)(hn(t, 12)) }, t.\u0275mod = Gt({ type: t }), t.\u0275inj = pt({ providers: Th, imports: [Gc, gc] }), t })(); function Dh(...t) { let e = t[t.length - 1]; return C(e) ? (t.pop(), L(t, e)) : W(t) } "undefined" != typeof window && window; class Ah extends S { constructor(t) { super(), this._value = t } get value() { return this.getValue() } _subscribe(t) { const e = super._subscribe(t); return e && !e.closed && t.next(this._value), e } getValue() { if (this.hasError) throw this.thrownError; if (this.closed) throw new b; return this._value } next(t) { super.next(this._value = t) } } class Oh extends f { notifyNext(t, e, i, n, s) { this.destination.next(e) } notifyError(t, e) { this.destination.error(t) } notifyComplete(t) { this.destination.complete() } } class Rh extends f { constructor(t, e, i) { super(), this.parent = t, this.outerValue = e, this.outerIndex = i, this.index = 0 } _next(t) { this.parent.notifyNext(this.outerValue, t, this.outerIndex, this.index++, this) } _error(t) { this.parent.notifyError(t, this), this.unsubscribe() } _complete() { this.parent.notifyComplete(this), this.unsubscribe() } } function Mh(t, e, i, n, s = new Rh(t, i, n)) { if (!s.closed) return e instanceof v ? e.subscribe(s) : I(e)(s) } const Ih = {}; class Lh { constructor(t) { this.resultSelector = t } call(t, e) { return e.subscribe(new Fh(t, this.resultSelector)) } } class Fh extends Oh { constructor(t, e) { super(t), this.resultSelector = e, this.active = 0, this.values = [], this.observables = [] } _next(t) { this.values.push(Ih), this.observables.push(t) } _complete() { const t = this.observables, e = t.length; if (0 === e) this.destination.complete(); else { this.active = e, this.toRespond = e; for (let i = 0; i < e; i++)this.add(Mh(this, t[i], void 0, i)) } } notifyComplete(t) { 0 == (this.active -= 1) && this.destination.complete() } notifyNext(t, e, i) { const n = this.values, s = this.toRespond ? n[i] === Ih ? --this.toRespond : this.toRespond : 0; n[i] = e, 0 === s && (this.resultSelector ? this._tryResultSelector(n) : this.destination.next(n.slice())) } _tryResultSelector(t) { let e; try { e = this.resultSelector.apply(this, t) } catch (i) { return void this.destination.error(i) } this.destination.next(e) } } const Nh = (() => { function t() { return Error.call(this), this.message = "no elements in sequence", this.name = "EmptyError", this } return t.prototype = Object.create(Error.prototype), t })(); function jh(...t) { return U(1)(Dh(...t)) } const Vh = new v(t => t.complete()); function Bh(t) { return t ? function (t) { return new v(e => t.schedule(() => e.complete())) }(t) : Vh } function Hh(t) { return new v(e => { let i; try { i = t() } catch (n) { return void e.error(n) } return (i ? F(i) : Bh()).subscribe(e) }) } function zh(t, e) { return "function" == typeof e ? i => i.pipe(zh((i, n) => F(t(i, n)).pipe(E((t, s) => e(i, t, n, s))))) : e => e.lift(new $h(t)) } class $h { constructor(t) { this.project = t } call(t, e) { return e.subscribe(new Uh(t, this.project)) } } class Uh extends j { constructor(t, e) { super(t), this.project = e, this.index = 0 } _next(t) { let e; const i = this.index++; try { e = this.project(t, i) } catch (n) { return void this.destination.error(n) } this._innerSub(e) } _innerSub(t) { const e = this.innerSubscription; e && e.unsubscribe(); const i = new N(this), n = this.destination; n.add(i), this.innerSubscription = V(t, i), this.innerSubscription !== i && n.add(this.innerSubscription) } _complete() { const { innerSubscription: t } = this; t && !t.closed || super._complete(), this.unsubscribe() } _unsubscribe() { this.innerSubscription = void 0 } notifyComplete() { this.innerSubscription = void 0, this.isStopped && super._complete() } notifyNext(t) { this.destination.next(t) } } const Wh = (() => { function t() { return Error.call(this), this.message = "argument out of range", this.name = "ArgumentOutOfRangeError", this } return t.prototype = Object.create(Error.prototype), t })(); function qh(t) { return e => 0 === t ? Bh() : e.lift(new Gh(t)) } class Gh { constructor(t) { if (this.total = t, this.total < 0) throw new Wh } call(t, e) { return e.subscribe(new Zh(t, this.total)) } } class Zh extends f { constructor(t, e) { super(t), this.total = e, this.count = 0 } _next(t) { const e = this.total, i = ++this.count; i <= e && (this.destination.next(t), i === e && (this.destination.complete(), this.unsubscribe())) } } function Kh(...t) { const e = t[t.length - 1]; return C(e) ? (t.pop(), i => jh(t, i, e)) : e => jh(t, e) } function Yh(t, e) { let i = !1; return arguments.length >= 2 && (i = !0), function (n) { return n.lift(new Qh(t, e, i)) } } class Qh { constructor(t, e, i = !1) { this.accumulator = t, this.seed = e, this.hasSeed = i } call(t, e) { return e.subscribe(new Xh(t, this.accumulator, this.seed, this.hasSeed)) } } class Xh extends f { constructor(t, e, i, n) { super(t), this.accumulator = e, this._seed = i, this.hasSeed = n, this.index = 0 } get seed() { return this._seed } set seed(t) { this.hasSeed = !0, this._seed = t } _next(t) { if (this.hasSeed) return this._tryNext(t); this.seed = t, this.destination.next(t) } _tryNext(t) { const e = this.index++; let i; try { i = this.accumulator(this.seed, t, e) } catch (n) { this.destination.error(n) } this.seed = i, this.destination.next(i) } } function Jh(t, e) { return function (i) { return i.lift(new tu(t, e)) } } class tu { constructor(t, e) { this.predicate = t, this.thisArg = e } call(t, e) { return e.subscribe(new eu(t, this.predicate, this.thisArg)) } } class eu extends f { constructor(t, e, i) { super(t), this.predicate = e, this.thisArg = i, this.count = 0 } _next(t) { let e; try { e = this.predicate.call(this.thisArg, t, this.count++) } catch (i) { return void this.destination.error(i) } e && this.destination.next(t) } } function iu(t) { return function (e) { const i = new nu(t), n = e.lift(i); return i.caught = n } } class nu { constructor(t) { this.selector = t } call(t, e) { return e.subscribe(new su(t, this.selector, this.caught)) } } class su extends j { constructor(t, e, i) { super(t), this.selector = e, this.caught = i } error(t) { if (!this.isStopped) { let i; try { i = this.selector(t, this.caught) } catch (e) { return void super.error(e) } this._unsubscribeAndRecycle(); const n = new N(this); this.add(n); const s = V(i, n); s !== n && this.add(s) } } } function ru(t, e) { return B(t, e, 1) } function ou(t) { return function (e) { return 0 === t ? Bh() : e.lift(new au(t)) } } class au { constructor(t) { if (this.total = t, this.total < 0) throw new Wh } call(t, e) { return e.subscribe(new lu(t, this.total)) } } class lu extends f { constructor(t, e) { super(t), this.total = e, this.ring = new Array, this.count = 0 } _next(t) { const e = this.ring, i = this.total, n = this.count++; e.length < i ? e.push(t) : e[n % i] = t } _complete() { const t = this.destination; let e = this.count; if (e > 0) { const i = this.count >= this.total ? this.total : this.count, n = this.ring; for (let s = 0; s < i; s++) { const s = e++ % i; t.next(n[s]) } } t.complete() } } function cu(t = du) { return e => e.lift(new hu(t)) } class hu { constructor(t) { this.errorFactory = t } call(t, e) { return e.subscribe(new uu(t, this.errorFactory)) } } class uu extends f { constructor(t, e) { super(t), this.errorFactory = e, this.hasValue = !1 } _next(t) { this.hasValue = !0, this.destination.next(t) } _complete() { if (this.hasValue) return this.destination.complete(); { let e; try { e = this.errorFactory() } catch (t) { e = t } this.destination.error(e) } } } function du() { return new Nh } function pu(t = null) { return e => e.lift(new fu(t)) } class fu { constructor(t) { this.defaultValue = t } call(t, e) { return e.subscribe(new gu(t, this.defaultValue)) } } class gu extends f { constructor(t, e) { super(t), this.defaultValue = e, this.isEmpty = !0 } _next(t) { this.isEmpty = !1, this.destination.next(t) } _complete() { this.isEmpty && this.destination.next(this.defaultValue), this.destination.complete() } } function mu(t, e) { const i = arguments.length >= 2; return n => n.pipe(t ? Jh((e, i) => t(e, i, n)) : _, qh(1), i ? pu(e) : cu(() => new Nh)) } function _u() { } function vu(t, e, i) { return function (n) { return n.lift(new yu(t, e, i)) } } class yu { constructor(t, e, i) { this.nextOrObserver = t, this.error = e, this.complete = i } call(t, e) { return e.subscribe(new bu(t, this.nextOrObserver, this.error, this.complete)) } } class bu extends f { constructor(t, e, i, s) { super(t), this._tapNext = _u, this._tapError = _u, this._tapComplete = _u, this._tapError = i || _u, this._tapComplete = s || _u, n(e) ? (this._context = this, this._tapNext = e) : e && (this._context = e, this._tapNext = e.next || _u, this._tapError = e.error || _u, this._tapComplete = e.complete || _u) } _next(t) { try { this._tapNext.call(this._context, t) } catch (e) { return void this.destination.error(e) } this.destination.next(t) } _error(t) { try { this._tapError.call(this._context, t) } catch (t) { return void this.destination.error(t) } this.destination.error(t) } _complete() { try { this._tapComplete.call(this._context) } catch (t) { return void this.destination.error(t) } return this.destination.complete() } } class wu { constructor(t) { this.callback = t } call(t, e) { return e.subscribe(new xu(t, this.callback)) } } class xu extends f { constructor(t, e) { super(t), this.add(new u(e)) } } class Su { constructor(t, e) { this.id = t, this.url = e } } class ku extends Su { constructor(t, e, i = "imperative", n = null) { super(t, e), this.navigationTrigger = i, this.restoredState = n } toString() { return `NavigationStart(id: ${this.id}, url: '${this.url}')` } } class Cu extends Su { constructor(t, e, i) { super(t, e), this.urlAfterRedirects = i } toString() { return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')` } } class Eu extends Su { constructor(t, e, i) { super(t, e), this.reason = i } toString() { return `NavigationCancel(id: ${this.id}, url: '${this.url}')` } } class Tu extends Su { constructor(t, e, i) { super(t, e), this.error = i } toString() { return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})` } } class Pu extends Su { constructor(t, e, i, n) { super(t, e), this.urlAfterRedirects = i, this.state = n } toString() { return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class Du extends Su { constructor(t, e, i, n) { super(t, e), this.urlAfterRedirects = i, this.state = n } toString() { return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class Au extends Su { constructor(t, e, i, n, s) { super(t, e), this.urlAfterRedirects = i, this.state = n, this.shouldActivate = s } toString() { return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})` } } class Ou extends Su { constructor(t, e, i, n) { super(t, e), this.urlAfterRedirects = i, this.state = n } toString() { return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class Ru extends Su { constructor(t, e, i, n) { super(t, e), this.urlAfterRedirects = i, this.state = n } toString() { return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class Mu { constructor(t) { this.route = t } toString() { return `RouteConfigLoadStart(path: ${this.route.path})` } } class Iu { constructor(t) { this.route = t } toString() { return `RouteConfigLoadEnd(path: ${this.route.path})` } } class Lu { constructor(t) { this.snapshot = t } toString() { return `ChildActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class Fu { constructor(t) { this.snapshot = t } toString() { return `ChildActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class Nu { constructor(t) { this.snapshot = t } toString() { return `ActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class ju { constructor(t) { this.snapshot = t } toString() { return `ActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class Vu { constructor(t, e, i) { this.routerEvent = t, this.position = e, this.anchor = i } toString() { return `Scroll(anchor: '${this.anchor}', position: '${this.position ? `${this.position[0]}, ${this.position[1]}` : null}')` } } const Bu = "primary"; class Hu { constructor(t) { this.params = t || {} } has(t) { return Object.prototype.hasOwnProperty.call(this.params, t) } get(t) { if (this.has(t)) { const e = this.params[t]; return Array.isArray(e) ? e[0] : e } return null } getAll(t) { if (this.has(t)) { const e = this.params[t]; return Array.isArray(e) ? e : [e] } return [] } get keys() { return Object.keys(this.params) } } function zu(t) { return new Hu(t) } function $u(t) { const e = Error("NavigationCancelingError: " + t); return e.ngNavigationCancelingError = !0, e } function Uu(t, e, i) { const n = i.path.split("/"); if (n.length > t.length) return null; if ("full" === i.pathMatch && (e.hasChildren() || n.length < t.length)) return null; const s = {}; for (let r = 0; r < n.length; r++) { const e = n[r], i = t[r]; if (e.startsWith(":")) s[e.substring(1)] = i; else if (e !== i.path) return null } return { consumed: t.slice(0, n.length), posParams: s } } function Wu(t, e) { const i = t ? Object.keys(t) : void 0, n = e ? Object.keys(e) : void 0; if (!i || !n || i.length != n.length) return !1; let s; for (let r = 0; r < i.length; r++)if (s = i[r], !qu(t[s], e[s])) return !1; return !0 } function qu(t, e) { if (Array.isArray(t) && Array.isArray(e)) { if (t.length !== e.length) return !1; const i = [...t].sort(), n = [...e].sort(); return i.every((t, e) => n[e] === t) } return t === e } function Gu(t) { return Array.prototype.concat.apply([], t) } function Zu(t) { return t.length > 0 ? t[t.length - 1] : null } function Ku(t, e) { for (const i in t) t.hasOwnProperty(i) && e(t[i], i) } function Yu(t) { return Xr(t) ? t : Qr(t) ? F(Promise.resolve(t)) : Dh(t) } const Qu = { exact: function t(e, i, n) { if (!od(e.segments, i.segments)) return !1; if (!id(e.segments, i.segments, n)) return !1; if (e.numberOfChildren !== i.numberOfChildren) return !1; for (const s in i.children) { if (!e.children[s]) return !1; if (!t(e.children[s], i.children[s], n)) return !1 } return !0 }, subset: td }, Xu = { exact: function (t, e) { return Wu(t, e) }, subset: function (t, e) { return Object.keys(e).length <= Object.keys(t).length && Object.keys(e).every(i => qu(t[i], e[i])) }, ignored: () => !0 }; function Ju(t, e, i) { return Qu[i.paths](t.root, e.root, i.matrixParams) && Xu[i.queryParams](t.queryParams, e.queryParams) && !("exact" === i.fragment && t.fragment !== e.fragment) } function td(t, e, i) { return ed(t, e, e.segments, i) } function ed(t, e, i, n) { if (t.segments.length > i.length) { const s = t.segments.slice(0, i.length); return !!od(s, i) && !e.hasChildren() && !!id(s, i, n) } if (t.segments.length === i.length) { if (!od(t.segments, i)) return !1; if (!id(t.segments, i, n)) return !1; for (const i in e.children) { if (!t.children[i]) return !1; if (!td(t.children[i], e.children[i], n)) return !1 } return !0 } { const s = i.slice(0, t.segments.length), r = i.slice(t.segments.length); return !!od(t.segments, s) && !!id(t.segments, s, n) && !!t.children.primary && ed(t.children.primary, e, r, n) } } function id(t, e, i) { return e.every((e, n) => Xu[i](t[n].parameters, e.parameters)) } class nd { constructor(t, e, i) { this.root = t, this.queryParams = e, this.fragment = i } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = zu(this.queryParams)), this._queryParamMap } toString() { return cd.serialize(this) } } class sd { constructor(t, e) { this.segments = t, this.children = e, this.parent = null, Ku(e, (t, e) => t.parent = this) } hasChildren() { return this.numberOfChildren > 0 } get numberOfChildren() { return Object.keys(this.children).length } toString() { return hd(this) } } class rd { constructor(t, e) { this.path = t, this.parameters = e } get parameterMap() { return this._parameterMap || (this._parameterMap = zu(this.parameters)), this._parameterMap } toString() { return _d(this) } } function od(t, e) { return t.length === e.length && t.every((t, i) => t.path === e[i].path) } class ad { } class ld { parse(t) { const e = new xd(t); return new nd(e.parseRootSegment(), e.parseQueryParams(), e.parseFragment()) } serialize(t) { var e; return `/${ud(t.root, !0)}${function (t) { const e = Object.keys(t).map(e => { const i = t[e]; return Array.isArray(i) ? i.map(t => `${pd(e)}=${pd(t)}`).join("&") : `${pd(e)}=${pd(i)}` }).filter(t => !!t); return e.length ? `?${e.join("&")}` : "" }(t.queryParams)}${"string" == typeof t.fragment ? `#${e = t.fragment, encodeURI(e)}` : ""}` } } const cd = new ld; function hd(t) { return t.segments.map(t => _d(t)).join("/") } function ud(t, e) { if (!t.hasChildren()) return hd(t); if (e) { const e = t.children.primary ? ud(t.children.primary, !1) : "", i = []; return Ku(t.children, (t, e) => { e !== Bu && i.push(`${e}:${ud(t, !1)}`) }), i.length > 0 ? `${e}(${i.join("//")})` : e } { const e = function (t, e) { let i = []; return Ku(t.children, (t, n) => { n === Bu && (i = i.concat(e(t, n))) }), Ku(t.children, (t, n) => { n !== Bu && (i = i.concat(e(t, n))) }), i }(t, (e, i) => i === Bu ? [ud(t.children.primary, !1)] : [`${i}:${ud(e, !1)}`]); return 1 === Object.keys(t.children).length && null != t.children.primary ? `${hd(t)}/${e[0]}` : `${hd(t)}/(${e.join("//")})` } } function dd(t) { return encodeURIComponent(t).replace(/%40/g, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",") } function pd(t) { return dd(t).replace(/%3B/gi, ";") } function fd(t) { return dd(t).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/%26/gi, "&") } function gd(t) { return decodeURIComponent(t) } function md(t) { return gd(t.replace(/\+/g, "%20")) } function _d(t) { return `${fd(t.path)}${e = t.parameters, Object.keys(e).map(t => `;${fd(t)}=${fd(e[t])}`).join("")}`; var e } const vd = /^[^\/()?;=#]+/; function yd(t) { const e = t.match(vd); return e ? e[0] : "" } const bd = /^[^=?&#]+/, wd = /^[^?&#]+/; class xd { constructor(t) { this.url = t, this.remaining = t } parseRootSegment() { return this.consumeOptional("/"), "" === this.remaining || this.peekStartsWith("?") || this.peekStartsWith("#") ? new sd([], {}) : new sd([], this.parseChildren()) } parseQueryParams() { const t = {}; if (this.consumeOptional("?")) do { this.parseQueryParam(t) } while (this.consumeOptional("&")); return t } parseFragment() { return this.consumeOptional("#") ? decodeURIComponent(this.remaining) : null } parseChildren() { if ("" === this.remaining) return {}; this.consumeOptional("/"); const t = []; for (this.peekStartsWith("(") || t.push(this.parseSegment()); this.peekStartsWith("/") && !this.peekStartsWith("//") && !this.peekStartsWith("/(");)this.capture("/"), t.push(this.parseSegment()); let e = {}; this.peekStartsWith("/(") && (this.capture("/"), e = this.parseParens(!0)); let i = {}; return this.peekStartsWith("(") && (i = this.parseParens(!1)), (t.length > 0 || Object.keys(e).length > 0) && (i.primary = new sd(t, e)), i } parseSegment() { const t = yd(this.remaining); if ("" === t && this.peekStartsWith(";")) throw new Error(`Empty path url segment cannot have parameters: '${this.remaining}'.`); return this.capture(t), new rd(gd(t), this.parseMatrixParams()) } parseMatrixParams() { const t = {}; for (; this.consumeOptional(";");)this.parseParam(t); return t } parseParam(t) { const e = yd(this.remaining); if (!e) return; this.capture(e); let i = ""; if (this.consumeOptional("=")) { const t = yd(this.remaining); t && (i = t, this.capture(i)) } t[gd(e)] = gd(i) } parseQueryParam(t) { const e = function (t) { const e = t.match(bd); return e ? e[0] : "" }(this.remaining); if (!e) return; this.capture(e); let i = ""; if (this.consumeOptional("=")) { const t = function (t) { const e = t.match(wd); return e ? e[0] : "" }(this.remaining); t && (i = t, this.capture(i)) } const n = md(e), s = md(i); if (t.hasOwnProperty(n)) { let e = t[n]; Array.isArray(e) || (e = [e], t[n] = e), e.push(s) } else t[n] = s } parseParens(t) { const e = {}; for (this.capture("("); !this.consumeOptional(")") && this.remaining.length > 0;) { const i = yd(this.remaining), n = this.remaining[i.length]; if ("/" !== n && ")" !== n && ";" !== n) throw new Error(`Cannot parse url '${this.url}'`); let s; i.indexOf(":") > -1 ? (s = i.substr(0, i.indexOf(":")), this.capture(s), this.capture(":")) : t && (s = Bu); const r = this.parseChildren(); e[s] = 1 === Object.keys(r).length ? r.primary : new sd([], r), this.consumeOptional("//") } return e } peekStartsWith(t) { return this.remaining.startsWith(t) } consumeOptional(t) { return !!this.peekStartsWith(t) && (this.remaining = this.remaining.substring(t.length), !0) } capture(t) { if (!this.consumeOptional(t)) throw new Error(`Expected "${t}".`) } } class Sd { constructor(t) { this._root = t } get root() { return this._root.value } parent(t) { const e = this.pathFromRoot(t); return e.length > 1 ? e[e.length - 2] : null } children(t) { const e = kd(t, this._root); return e ? e.children.map(t => t.value) : [] } firstChild(t) { const e = kd(t, this._root); return e && e.children.length > 0 ? e.children[0].value : null } siblings(t) { const e = Cd(t, this._root); return e.length < 2 ? [] : e[e.length - 2].children.map(t => t.value).filter(e => e !== t) } pathFromRoot(t) { return Cd(t, this._root).map(t => t.value) } } function kd(t, e) { if (t === e.value) return e; for (const i of e.children) { const e = kd(t, i); if (e) return e } return null } function Cd(t, e) { if (t === e.value) return [e]; for (const i of e.children) { const n = Cd(t, i); if (n.length) return n.unshift(e), n } return [] } class Ed { constructor(t, e) { this.value = t, this.children = e } toString() { return `TreeNode(${this.value})` } } function Td(t) { const e = {}; return t && t.children.forEach(t => e[t.value.outlet] = t), e } class Pd extends Sd { constructor(t, e) { super(t), this.snapshot = e, Id(this, t) } toString() { return this.snapshot.toString() } } function Dd(t, e) { const i = function (t, e) { const i = new Rd([], {}, {}, "", {}, Bu, e, null, t.root, -1, {}); return new Md("", new Ed(i, [])) }(t, e), n = new Ah([new rd("", {})]), s = new Ah({}), r = new Ah({}), o = new Ah({}), a = new Ah(""), l = new Ad(n, s, o, a, r, Bu, e, i.root); return l.snapshot = i.root, new Pd(new Ed(l, []), i) } class Ad { constructor(t, e, i, n, s, r, o, a) { this.url = t, this.params = e, this.queryParams = i, this.fragment = n, this.data = s, this.outlet = r, this.component = o, this._futureSnapshot = a } get routeConfig() { return this._futureSnapshot.routeConfig } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = this.params.pipe(E(t => zu(t)))), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = this.queryParams.pipe(E(t => zu(t)))), this._queryParamMap } toString() { return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})` } } function Od(t, e = "emptyOnly") { const i = t.pathFromRoot; let n = 0; if ("always" !== e) for (n = i.length - 1; n >= 1;) { const t = i[n], e = i[n - 1]; if (t.routeConfig && "" === t.routeConfig.path) n--; else { if (e.component) break; n-- } } return function (t) { return t.reduce((t, e) => ({ params: Object.assign(Object.assign({}, t.params), e.params), data: Object.assign(Object.assign({}, t.data), e.data), resolve: Object.assign(Object.assign({}, t.resolve), e._resolvedData) }), { params: {}, data: {}, resolve: {} }) }(i.slice(n)) } class Rd { constructor(t, e, i, n, s, r, o, a, l, c, h) { this.url = t, this.params = e, this.queryParams = i, this.fragment = n, this.data = s, this.outlet = r, this.component = o, this.routeConfig = a, this._urlSegment = l, this._lastPathIndex = c, this._resolve = h } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = zu(this.params)), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = zu(this.queryParams)), this._queryParamMap } toString() { return `Route(url:'${this.url.map(t => t.toString()).join("/")}', path:'${this.routeConfig ? this.routeConfig.path : ""}')` } } class Md extends Sd { constructor(t, e) { super(e), this.url = t, Id(this, e) } toString() { return Ld(this._root) } } function Id(t, e) { e.value._routerState = t, e.children.forEach(e => Id(t, e)) } function Ld(t) { const e = t.children.length > 0 ? ` { ${t.children.map(Ld).join(", ")} } ` : ""; return `${t.value}${e}` } function Fd(t) { if (t.snapshot) { const e = t.snapshot, i = t._futureSnapshot; t.snapshot = i, Wu(e.queryParams, i.queryParams) || t.queryParams.next(i.queryParams), e.fragment !== i.fragment && t.fragment.next(i.fragment), Wu(e.params, i.params) || t.params.next(i.params), function (t, e) { if (t.length !== e.length) return !1; for (let i = 0; i < t.length; ++i)if (!Wu(t[i], e[i])) return !1; return !0 }(e.url, i.url) || t.url.next(i.url), Wu(e.data, i.data) || t.data.next(i.data) } else t.snapshot = t._futureSnapshot, t.data.next(t._futureSnapshot.data) } function Nd(t, e) { var i, n; return Wu(t.params, e.params) && od(i = t.url, n = e.url) && i.every((t, e) => Wu(t.parameters, n[e].parameters)) && !(!t.parent != !e.parent) && (!t.parent || Nd(t.parent, e.parent)) } function jd(t, e, i) { if (i && t.shouldReuseRoute(e.value, i.value.snapshot)) { const n = i.value; n._futureSnapshot = e.value; const s = function (t, e, i) { return e.children.map(e => { for (const n of i.children) if (t.shouldReuseRoute(e.value, n.value.snapshot)) return jd(t, e, n); return jd(t, e) }) }(t, e, i); return new Ed(n, s) } { if (t.shouldAttach(e.value)) { const i = t.retrieve(e.value); if (null !== i) { const t = i.route; return Vd(e, t), t } } const i = new Ad(new Ah((n = e.value).url), new Ah(n.params), new Ah(n.queryParams), new Ah(n.fragment), new Ah(n.data), n.outlet, n.component, n), s = e.children.map(e => jd(t, e)); return new Ed(i, s) } var n } function Vd(t, e) { if (t.value.routeConfig !== e.value.routeConfig) throw new Error("Cannot reattach ActivatedRouteSnapshot created from a different route"); if (t.children.length !== e.children.length) throw new Error("Cannot reattach ActivatedRouteSnapshot with a different number of children"); e.value._futureSnapshot = t.value; for (let i = 0; i < t.children.length; ++i)Vd(t.children[i], e.children[i]) } function Bd(t) { return "object" == typeof t && null != t && !t.outlets && !t.segmentPath } function Hd(t) { return "object" == typeof t && null != t && t.outlets } function zd(t, e, i, n, s) { let r = {}; return n && Ku(n, (t, e) => { r[e] = Array.isArray(t) ? t.map(t => `${t}`) : `${t}` }), new nd(i.root === t ? e : $d(i.root, t, e), r, s) } function $d(t, e, i) { const n = {}; return Ku(t.children, (t, s) => { n[s] = t === e ? i : $d(t, e, i) }), new sd(t.segments, n) } class Ud { constructor(t, e, i) { if (this.isAbsolute = t, this.numberOfDoubleDots = e, this.commands = i, t && i.length > 0 && Bd(i[0])) throw new Error("Root segment cannot have matrix parameters"); const n = i.find(Hd); if (n && n !== Zu(i)) throw new Error("{outlets:{}} has to be the last command") } toRoot() { return this.isAbsolute && 1 === this.commands.length && "/" == this.commands[0] } } class Wd { constructor(t, e, i) { this.segmentGroup = t, this.processChildren = e, this.index = i } } function qd(t, e, i) { if (t || (t = new sd([], {})), 0 === t.segments.length && t.hasChildren()) return Gd(t, e, i); const n = function (t, e, i) { let n = 0, s = e; const r = { match: !1, pathIndex: 0, commandIndex: 0 }; for (; s < t.segments.length;) { if (n >= i.length) return r; const e = t.segments[s], o = i[n]; if (Hd(o)) break; const a = `${o}`, l = n < i.length - 1 ? i[n + 1] : null; if (s > 0 && void 0 === a) break; if (a && l && "object" == typeof l && void 0 === l.outlets) { if (!Qd(a, l, e)) return r; n += 2 } else { if (!Qd(a, {}, e)) return r; n++ } s++ } return { match: !0, pathIndex: s, commandIndex: n } }(t, e, i), s = i.slice(n.commandIndex); if (n.match && n.pathIndex < t.segments.length) { const e = new sd(t.segments.slice(0, n.pathIndex), {}); return e.children.primary = new sd(t.segments.slice(n.pathIndex), t.children), Gd(e, 0, s) } return n.match && 0 === s.length ? new sd(t.segments, {}) : n.match && !t.hasChildren() ? Zd(t, e, i) : n.match ? Gd(t, 0, s) : Zd(t, e, i) } function Gd(t, e, i) { if (0 === i.length) return new sd(t.segments, {}); { const n = function (t) { return Hd(t[0]) ? t[0].outlets : { [Bu]: t } }(i), s = {}; return Ku(n, (i, n) => { "string" == typeof i && (i = [i]), null !== i && (s[n] = qd(t.children[n], e, i)) }), Ku(t.children, (t, e) => { void 0 === n[e] && (s[e] = t) }), new sd(t.segments, s) } } function Zd(t, e, i) { const n = t.segments.slice(0, e); let s = 0; for (; s < i.length;) { const r = i[s]; if (Hd(r)) { const t = Kd(r.outlets); return new sd(n, t) } if (0 === s && Bd(i[0])) { n.push(new rd(t.segments[e].path, Yd(i[0]))), s++; continue } const o = Hd(r) ? r.outlets.primary : `${r}`, a = s < i.length - 1 ? i[s + 1] : null; o && a && Bd(a) ? (n.push(new rd(o, Yd(a))), s += 2) : (n.push(new rd(o, {})), s++) } return new sd(n, {}) } function Kd(t) { const e = {}; return Ku(t, (t, i) => { "string" == typeof t && (t = [t]), null !== t && (e[i] = Zd(new sd([], {}), 0, t)) }), e } function Yd(t) { const e = {}; return Ku(t, (t, i) => e[i] = `${t}`), e } function Qd(t, e, i) { return t == i.path && Wu(e, i.parameters) } class Xd { constructor(t, e, i, n) { this.routeReuseStrategy = t, this.futureState = e, this.currState = i, this.forwardEvent = n } activate(t) { const e = this.futureState._root, i = this.currState ? this.currState._root : null; this.deactivateChildRoutes(e, i, t), Fd(this.futureState.root), this.activateChildRoutes(e, i, t) } deactivateChildRoutes(t, e, i) { const n = Td(e); t.children.forEach(t => { const e = t.value.outlet; this.deactivateRoutes(t, n[e], i), delete n[e] }), Ku(n, (t, e) => { this.deactivateRouteAndItsChildren(t, i) }) } deactivateRoutes(t, e, i) { const n = t.value, s = e ? e.value : null; if (n === s) if (n.component) { const s = i.getContext(n.outlet); s && this.deactivateChildRoutes(t, e, s.children) } else this.deactivateChildRoutes(t, e, i); else s && this.deactivateRouteAndItsChildren(e, i) } deactivateRouteAndItsChildren(t, e) { this.routeReuseStrategy.shouldDetach(t.value.snapshot) ? this.detachAndStoreRouteSubtree(t, e) : this.deactivateRouteAndOutlet(t, e) } detachAndStoreRouteSubtree(t, e) { const i = e.getContext(t.value.outlet); if (i && i.outlet) { const e = i.outlet.detach(), n = i.children.onOutletDeactivated(); this.routeReuseStrategy.store(t.value.snapshot, { componentRef: e, route: t, contexts: n }) } } deactivateRouteAndOutlet(t, e) { const i = e.getContext(t.value.outlet), n = i && t.value.component ? i.children : e, s = Td(t); for (const r of Object.keys(s)) this.deactivateRouteAndItsChildren(s[r], n); i && i.outlet && (i.outlet.deactivate(), i.children.onOutletDeactivated(), i.attachRef = null, i.resolver = null, i.route = null) } activateChildRoutes(t, e, i) { const n = Td(e); t.children.forEach(t => { this.activateRoutes(t, n[t.value.outlet], i), this.forwardEvent(new ju(t.value.snapshot)) }), t.children.length && this.forwardEvent(new Fu(t.value.snapshot)) } activateRoutes(t, e, i) { const n = t.value, s = e ? e.value : null; if (Fd(n), n === s) if (n.component) { const s = i.getOrCreateContext(n.outlet); this.activateChildRoutes(t, e, s.children) } else this.activateChildRoutes(t, e, i); else if (n.component) { const e = i.getOrCreateContext(n.outlet); if (this.routeReuseStrategy.shouldAttach(n.snapshot)) { const t = this.routeReuseStrategy.retrieve(n.snapshot); this.routeReuseStrategy.store(n.snapshot, null), e.children.onOutletReAttached(t.contexts), e.attachRef = t.componentRef, e.route = t.route.value, e.outlet && e.outlet.attach(t.componentRef, t.route.value), Jd(t.route) } else { const i = function (t) { for (let e = t.parent; e; e = e.parent) { const t = e.routeConfig; if (t && t._loadedConfig) return t._loadedConfig; if (t && t.component) return null } return null }(n.snapshot), s = i ? i.module.componentFactoryResolver : null; e.attachRef = null, e.route = n, e.resolver = s, e.outlet && e.outlet.activateWith(n, s), this.activateChildRoutes(t, null, e.children) } } else this.activateChildRoutes(t, null, i) } } function Jd(t) { Fd(t.value), t.children.forEach(Jd) } class tp { constructor(t, e) { this.routes = t, this.module = e } } function ep(t) { return "function" == typeof t } function ip(t) { return t instanceof nd } const np = Symbol("INITIAL_VALUE"); function sp() { return zh(t => function (...t) { let e, i; return C(t[t.length - 1]) && (i = t.pop()), "function" == typeof t[t.length - 1] && (e = t.pop()), 1 === t.length && l(t[0]) && (t = t[0]), W(t, i).lift(new Lh(e)) }(t.map(t => t.pipe(qh(1), Kh(np)))).pipe(Yh((t, e) => { let i = !1; return e.reduce((t, n, s) => { if (t !== np) return t; if (n === np && (i = !0), !i) { if (!1 === n) return n; if (s === e.length - 1 || ip(n)) return n } return t }, t) }, np), Jh(t => t !== np), E(t => ip(t) ? t : !0 === t), qh(1))) } let rp = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = $t({ type: t, selectors: [["ng-component"]], decls: 1, vars: 0, template: function (t, e) { 1 & t && Kr(0, "router-outlet") }, directives: function () { return [ef] }, encapsulation: 2 }), t })(); function op(t, e = "") { for (let i = 0; i < t.length; i++) { const n = t[i]; ap(n, lp(e, n)) } } function ap(t, e) { t.children && op(t.children, e) } function lp(t, e) { return e ? t || e.path ? t && !e.path ? `${t}/` : !t && e.path ? e.path : `${t}/${e.path}` : "" : t } function cp(t) { const e = t.children && t.children.map(cp), i = e ? Object.assign(Object.assign({}, t), { children: e }) : Object.assign({}, t); return !i.component && (e || i.loadChildren) && i.outlet && i.outlet !== Bu && (i.component = rp), i } function hp(t) { return t.outlet || Bu } function up(t, e) { const i = t.filter(t => hp(t) === e); return i.push(...t.filter(t => hp(t) !== e)), i } const dp = { matched: !1, consumedSegments: [], lastChild: 0, parameters: {}, positionalParamSegments: {} }; function pp(t, e, i) { var n; if ("" === e.path) return "full" === e.pathMatch && (t.hasChildren() || i.length > 0) ? Object.assign({}, dp) : { matched: !0, consumedSegments: [], lastChild: 0, parameters: {}, positionalParamSegments: {} }; const s = (e.matcher || Uu)(i, t, e); if (!s) return Object.assign({}, dp); const r = {}; Ku(s.posParams, (t, e) => { r[e] = t.path }); const o = s.consumed.length > 0 ? Object.assign(Object.assign({}, r), s.consumed[s.consumed.length - 1].parameters) : r; return { matched: !0, consumedSegments: s.consumed, lastChild: s.consumed.length, parameters: o, positionalParamSegments: null !== (n = s.posParams) && void 0 !== n ? n : {} } } function fp(t, e, i, n, s = "corrected") { if (i.length > 0 && function (t, e, i) { return i.some(i => gp(t, e, i) && hp(i) !== Bu) }(t, i, n)) { const s = new sd(e, function (t, e, i, n) { const s = {}; s.primary = n, n._sourceSegment = t, n._segmentIndexShift = e.length; for (const r of i) if ("" === r.path && hp(r) !== Bu) { const i = new sd([], {}); i._sourceSegment = t, i._segmentIndexShift = e.length, s[hp(r)] = i } return s }(t, e, n, new sd(i, t.children))); return s._sourceSegment = t, s._segmentIndexShift = e.length, { segmentGroup: s, slicedSegments: [] } } if (0 === i.length && function (t, e, i) { return i.some(i => gp(t, e, i)) }(t, i, n)) { const r = new sd(t.segments, function (t, e, i, n, s, r) { const o = {}; for (const a of n) if (gp(t, i, a) && !s[hp(a)]) { const i = new sd([], {}); i._sourceSegment = t, i._segmentIndexShift = "legacy" === r ? t.segments.length : e.length, o[hp(a)] = i } return Object.assign(Object.assign({}, s), o) }(t, e, i, n, t.children, s)); return r._sourceSegment = t, r._segmentIndexShift = e.length, { segmentGroup: r, slicedSegments: i } } const r = new sd(t.segments, t.children); return r._sourceSegment = t, r._segmentIndexShift = e.length, { segmentGroup: r, slicedSegments: i } } function gp(t, e, i) { return (!(t.hasChildren() || e.length > 0) || "full" !== i.pathMatch) && "" === i.path } function mp(t, e, i, n) { return !!(hp(t) === n || n !== Bu && gp(e, i, t)) && ("**" === t.path || pp(e, t, i).matched) } function _p(t, e, i) { return 0 === e.length && !t.children[i] } class vp { constructor(t) { this.segmentGroup = t || null } } class yp { constructor(t) { this.urlTree = t } } function bp(t) { return new v(e => e.error(new vp(t))) } function wp(t) { return new v(e => e.error(new yp(t))) } function xp(t) { return new v(e => e.error(new Error(`Only absolute redirects can have named outlets. redirectTo: '${t}'`))) } class Sp { constructor(t, e, i, n, s) { this.configLoader = e, this.urlSerializer = i, this.urlTree = n, this.config = s, this.allowRedirects = !0, this.ngModule = t.get(Aa) } apply() { const t = fp(this.urlTree.root, [], [], this.config).segmentGroup, e = new sd(t.segments, t.children); return this.expandSegmentGroup(this.ngModule, this.config, e, Bu).pipe(E(t => this.createUrlTree(kp(t), this.urlTree.queryParams, this.urlTree.fragment))).pipe(iu(t => { if (t instanceof yp) return this.allowRedirects = !1, this.match(t.urlTree); if (t instanceof vp) throw this.noMatchError(t); throw t })) } match(t) { return this.expandSegmentGroup(this.ngModule, this.config, t.root, Bu).pipe(E(e => this.createUrlTree(kp(e), t.queryParams, t.fragment))).pipe(iu(t => { if (t instanceof vp) throw this.noMatchError(t); throw t })) } noMatchError(t) { return new Error(`Cannot match any routes. URL Segment: '${t.segmentGroup}'`) } createUrlTree(t, e, i) { const n = t.segments.length > 0 ? new sd([], { [Bu]: t }) : t; return new nd(n, e, i) } expandSegmentGroup(t, e, i, n) { return 0 === i.segments.length && i.hasChildren() ? this.expandChildren(t, e, i).pipe(E(t => new sd([], t))) : this.expandSegment(t, i, e, i.segments, n, !0) } expandChildren(t, e, i) { const n = []; for (const s of Object.keys(i.children)) "primary" === s ? n.unshift(s) : n.push(s); return F(n).pipe(ru(n => { const s = i.children[n], r = up(e, n); return this.expandSegmentGroup(t, r, s, n).pipe(E(t => ({ segment: t, outlet: n }))) }), Yh((t, e) => (t[e.outlet] = e.segment, t), {}), function (t, e) { const i = arguments.length >= 2; return n => n.pipe(t ? Jh((e, i) => t(e, i, n)) : _, ou(1), i ? pu(e) : cu(() => new Nh)) }()) } expandSegment(t, e, i, n, s, r) { return F(i).pipe(ru(o => this.expandSegmentAgainstRoute(t, e, i, o, n, s, r).pipe(iu(t => { if (t instanceof vp) return Dh(null); throw t }))), mu(t => !!t), iu((t, i) => { if (t instanceof Nh || "EmptyError" === t.name) { if (_p(e, n, s)) return Dh(new sd([], {})); throw new vp(e) } throw t })) } expandSegmentAgainstRoute(t, e, i, n, s, r, o) { return mp(n, e, s, r) ? void 0 === n.redirectTo ? this.matchSegmentAgainstRoute(t, e, n, s, r) : o && this.allowRedirects ? this.expandSegmentAgainstRouteUsingRedirect(t, e, i, n, s, r) : bp(e) : bp(e) } expandSegmentAgainstRouteUsingRedirect(t, e, i, n, s, r) { return "**" === n.path ? this.expandWildCardWithParamsAgainstRouteUsingRedirect(t, i, n, r) : this.expandRegularSegmentAgainstRouteUsingRedirect(t, e, i, n, s, r) } expandWildCardWithParamsAgainstRouteUsingRedirect(t, e, i, n) { const s = this.applyRedirectCommands([], i.redirectTo, {}); return i.redirectTo.startsWith("/") ? wp(s) : this.lineralizeSegments(i, s).pipe(B(i => { const s = new sd(i, {}); return this.expandSegment(t, s, e, i, n, !1) })) } expandRegularSegmentAgainstRouteUsingRedirect(t, e, i, n, s, r) { const { matched: o, consumedSegments: a, lastChild: l, positionalParamSegments: c } = pp(e, n, s); if (!o) return bp(e); const h = this.applyRedirectCommands(a, n.redirectTo, c); return n.redirectTo.startsWith("/") ? wp(h) : this.lineralizeSegments(n, h).pipe(B(n => this.expandSegment(t, e, i, n.concat(s.slice(l)), r, !1))) } matchSegmentAgainstRoute(t, e, i, n, s) { if ("**" === i.path) return i.loadChildren ? (i._loadedConfig ? Dh(i._loadedConfig) : this.configLoader.load(t.injector, i)).pipe(E(t => (i._loadedConfig = t, new sd(n, {})))) : Dh(new sd(n, {})); const { matched: r, consumedSegments: o, lastChild: a } = pp(e, i, n); if (!r) return bp(e); const l = n.slice(a); return this.getChildConfig(t, i, n).pipe(B(t => { const n = t.module, r = t.routes, { segmentGroup: a, slicedSegments: c } = fp(e, o, l, r), h = new sd(a.segments, a.children); if (0 === c.length && h.hasChildren()) return this.expandChildren(n, r, h).pipe(E(t => new sd(o, t))); if (0 === r.length && 0 === c.length) return Dh(new sd(o, {})); const u = hp(i) === s; return this.expandSegment(n, h, r, c, u ? Bu : s, !0).pipe(E(t => new sd(o.concat(t.segments), t.children))) })) } getChildConfig(t, e, i) { return e.children ? Dh(new tp(e.children, t)) : e.loadChildren ? void 0 !== e._loadedConfig ? Dh(e._loadedConfig) : this.runCanLoadGuards(t.injector, e, i).pipe(B(i => i ? this.configLoader.load(t.injector, e).pipe(E(t => (e._loadedConfig = t, t))) : function (t) { return new v(e => e.error($u(`Cannot load children because the guard of the route "path: '${t.path}'" returned false`))) }(e))) : Dh(new tp([], t)) } runCanLoadGuards(t, e, i) { const n = e.canLoad; return n && 0 !== n.length ? Dh(n.map(n => { const s = t.get(n); let r; if (function (t) { return t && ep(t.canLoad) }(s)) r = s.canLoad(e, i); else { if (!ep(s)) throw new Error("Invalid CanLoad guard"); r = s(e, i) } return Yu(r) })).pipe(sp(), vu(t => { if (!ip(t)) return; const e = $u(`Redirecting to "${this.urlSerializer.serialize(t)}"`); throw e.url = t, e }), E(t => !0 === t)) : Dh(!0) } lineralizeSegments(t, e) { let i = [], n = e.root; for (; ;) { if (i = i.concat(n.segments), 0 === n.numberOfChildren) return Dh(i); if (n.numberOfChildren > 1 || !n.children.primary) return xp(t.redirectTo); n = n.children.primary } } applyRedirectCommands(t, e, i) { return this.applyRedirectCreatreUrlTree(e, this.urlSerializer.parse(e), t, i) } applyRedirectCreatreUrlTree(t, e, i, n) { const s = this.createSegmentGroup(t, e.root, i, n); return new nd(s, this.createQueryParams(e.queryParams, this.urlTree.queryParams), e.fragment) } createQueryParams(t, e) { const i = {}; return Ku(t, (t, n) => { if ("string" == typeof t && t.startsWith(":")) { const s = t.substring(1); i[n] = e[s] } else i[n] = t }), i } createSegmentGroup(t, e, i, n) { const s = this.createSegments(t, e.segments, i, n); let r = {}; return Ku(e.children, (e, s) => { r[s] = this.createSegmentGroup(t, e, i, n) }), new sd(s, r) } createSegments(t, e, i, n) { return e.map(e => e.path.startsWith(":") ? this.findPosParam(t, e, n) : this.findOrReturn(e, i)) } findPosParam(t, e, i) { const n = i[e.path.substring(1)]; if (!n) throw new Error(`Cannot redirect to '${t}'. Cannot find '${e.path}'.`); return n } findOrReturn(t, e) { let i = 0; for (const n of e) { if (n.path === t.path) return e.splice(i), n; i++ } return t } } function kp(t) { const e = {}; for (const i of Object.keys(t.children)) { const n = kp(t.children[i]); (n.segments.length > 0 || n.hasChildren()) && (e[i] = n) } return function (t) { if (1 === t.numberOfChildren && t.children.primary) { const e = t.children.primary; return new sd(t.segments.concat(e.segments), e.children) } return t }(new sd(t.segments, e)) } class Cp { constructor(t) { this.path = t, this.route = this.path[this.path.length - 1] } } class Ep { constructor(t, e) { this.component = t, this.route = e } } function Tp(t, e, i) { const n = t._root; return Dp(n, e ? e._root : null, i, [n.value]) } function Pp(t, e, i) { const n = function (t) { if (!t) return null; for (let e = t.parent; e; e = e.parent) { const t = e.routeConfig; if (t && t._loadedConfig) return t._loadedConfig } return null }(e); return (n ? n.module.injector : i).get(t) } function Dp(t, e, i, n, s = { canDeactivateChecks: [], canActivateChecks: [] }) { const r = Td(e); return t.children.forEach(t => { !function (t, e, i, n, s = { canDeactivateChecks: [], canActivateChecks: [] }) { const r = t.value, o = e ? e.value : null, a = i ? i.getContext(t.value.outlet) : null; if (o && r.routeConfig === o.routeConfig) { const l = function (t, e, i) { if ("function" == typeof i) return i(t, e); switch (i) { case "pathParamsChange": return !od(t.url, e.url); case "pathParamsOrQueryParamsChange": return !od(t.url, e.url) || !Wu(t.queryParams, e.queryParams); case "always": return !0; case "paramsOrQueryParamsChange": return !Nd(t, e) || !Wu(t.queryParams, e.queryParams); case "paramsChange": default: return !Nd(t, e) } }(o, r, r.routeConfig.runGuardsAndResolvers); l ? s.canActivateChecks.push(new Cp(n)) : (r.data = o.data, r._resolvedData = o._resolvedData), Dp(t, e, r.component ? a ? a.children : null : i, n, s), l && a && a.outlet && a.outlet.isActivated && s.canDeactivateChecks.push(new Ep(a.outlet.component, o)) } else o && Ap(e, a, s), s.canActivateChecks.push(new Cp(n)), Dp(t, null, r.component ? a ? a.children : null : i, n, s) }(t, r[t.value.outlet], i, n.concat([t.value]), s), delete r[t.value.outlet] }), Ku(r, (t, e) => Ap(t, i.getContext(e), s)), s } function Ap(t, e, i) { const n = Td(t), s = t.value; Ku(n, (t, n) => { Ap(t, s.component ? e ? e.children.getContext(n) : null : e, i) }), i.canDeactivateChecks.push(new Ep(s.component && e && e.outlet && e.outlet.isActivated ? e.outlet.component : null, s)) } class Op { } function Rp(t) { return new v(e => e.error(t)) } class Mp { constructor(t, e, i, n, s, r) { this.rootComponentType = t, this.config = e, this.urlTree = i, this.url = n, this.paramsInheritanceStrategy = s, this.relativeLinkResolution = r } recognize() { const t = fp(this.urlTree.root, [], [], this.config.filter(t => void 0 === t.redirectTo), this.relativeLinkResolution).segmentGroup, e = this.processSegmentGroup(this.config, t, Bu); if (null === e) return null; const i = new Rd([], Object.freeze({}), Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, {}, Bu, this.rootComponentType, null, this.urlTree.root, -1, {}), n = new Ed(i, e), s = new Md(this.url, n); return this.inheritParamsAndData(s._root), s } inheritParamsAndData(t) { const e = t.value, i = Od(e, this.paramsInheritanceStrategy); e.params = Object.freeze(i.params), e.data = Object.freeze(i.data), t.children.forEach(t => this.inheritParamsAndData(t)) } processSegmentGroup(t, e, i) { return 0 === e.segments.length && e.hasChildren() ? this.processChildren(t, e) : this.processSegment(t, e, e.segments, i) } processChildren(t, e) { const i = []; for (const s of Object.keys(e.children)) { const n = e.children[s], r = up(t, s), o = this.processSegmentGroup(r, n, s); if (null === o) return null; i.push(...o) } const n = Lp(i); return n.sort((t, e) => t.value.outlet === Bu ? -1 : e.value.outlet === Bu ? 1 : t.value.outlet.localeCompare(e.value.outlet)), n } processSegment(t, e, i, n) { for (const s of t) { const t = this.processSegmentAgainstRoute(s, e, i, n); if (null !== t) return t } return _p(e, i, n) ? [] : null } processSegmentAgainstRoute(t, e, i, n) { if (t.redirectTo || !mp(t, e, i, n)) return null; let s, r = [], o = []; if ("**" === t.path) { const n = i.length > 0 ? Zu(i).parameters : {}; s = new Rd(i, n, Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, jp(t), hp(t), t.component, t, Fp(e), Np(e) + i.length, Vp(t)) } else { const n = pp(e, t, i); if (!n.matched) return null; r = n.consumedSegments, o = i.slice(n.lastChild), s = new Rd(r, n.parameters, Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, jp(t), hp(t), t.component, t, Fp(e), Np(e) + r.length, Vp(t)) } const a = function (t) { return t.children ? t.children : t.loadChildren ? t._loadedConfig.routes : [] }(t), { segmentGroup: l, slicedSegments: c } = fp(e, r, o, a.filter(t => void 0 === t.redirectTo), this.relativeLinkResolution); if (0 === c.length && l.hasChildren()) { const t = this.processChildren(a, l); return null === t ? null : [new Ed(s, t)] } if (0 === a.length && 0 === c.length) return [new Ed(s, [])]; const h = hp(t) === n, u = this.processSegment(a, l, c, h ? Bu : n); return null === u ? null : [new Ed(s, u)] } } function Ip(t) { const e = t.value.routeConfig; return e && "" === e.path && void 0 === e.redirectTo } function Lp(t) { const e = [], i = new Set; for (const n of t) { if (!Ip(n)) { e.push(n); continue } const t = e.find(t => n.value.routeConfig === t.value.routeConfig); void 0 !== t ? (t.children.push(...n.children), i.add(t)) : e.push(n) } for (const n of i) { const t = Lp(n.children); e.push(new Ed(n.value, t)) } return e.filter(t => !i.has(t)) } function Fp(t) { let e = t; for (; e._sourceSegment;)e = e._sourceSegment; return e } function Np(t) { let e = t, i = e._segmentIndexShift ? e._segmentIndexShift : 0; for (; e._sourceSegment;)e = e._sourceSegment, i += e._segmentIndexShift ? e._segmentIndexShift : 0; return i - 1 } function jp(t) { return t.data || {} } function Vp(t) { return t.resolve || {} } function Bp(t) { return zh(e => { const i = t(e); return i ? F(i).pipe(E(() => e)) : Dh(e) }) } class Hp extends class { shouldDetach(t) { return !1 } store(t, e) { } shouldAttach(t) { return !1 } retrieve(t) { return null } shouldReuseRoute(t, e) { return t.routeConfig === e.routeConfig } }{ } const zp = new Wi("ROUTES"); class $p { constructor(t, e, i, n) { this.loader = t, this.compiler = e, this.onLoadStartListener = i, this.onLoadEndListener = n } load(t, e) { if (e._loader$) return e._loader$; this.onLoadStartListener && this.onLoadStartListener(e); const i = this.loadModuleFactory(e.loadChildren).pipe(E(i => { this.onLoadEndListener && this.onLoadEndListener(e); const n = i.create(t); return new tp(Gu(n.injector.get(zp, void 0, wt.Self | wt.Optional)).map(cp), n) }), iu(t => { throw e._loader$ = void 0, t })); return e._loader$ = new Y(i, () => new S).pipe(G()), e._loader$ } loadModuleFactory(t) { return "string" == typeof t ? F(this.loader.load(t)) : Yu(t()).pipe(B(t => t instanceof Oa ? Dh(t) : F(this.compiler.compileModuleAsync(t)))) } } class Up { constructor() { this.outlet = null, this.route = null, this.resolver = null, this.children = new Wp, this.attachRef = null } } class Wp { constructor() { this.contexts = new Map } onChildOutletCreated(t, e) { const i = this.getOrCreateContext(t); i.outlet = e, this.contexts.set(t, i) } onChildOutletDestroyed(t) { const e = this.getContext(t); e && (e.outlet = null) } onOutletDeactivated() { const t = this.contexts; return this.contexts = new Map, t } onOutletReAttached(t) { this.contexts = t } getOrCreateContext(t) { let e = this.getContext(t); return e || (e = new Up, this.contexts.set(t, e)), e } getContext(t) { return this.contexts.get(t) || null } } class qp { shouldProcessUrl(t) { return !0 } extract(t) { return t } merge(t, e) { return t } } function Gp(t) { throw t } function Zp(t, e, i) { return e.parse("/") } function Kp(t, e) { return Dh(null) } const Yp = { paths: "exact", fragment: "ignored", matrixParams: "ignored", queryParams: "exact" }, Qp = { paths: "subset", fragment: "ignored", matrixParams: "ignored", queryParams: "subset" }; let Xp = (() => { class t { constructor(t, e, i, n, s, r, o, a) { this.rootComponentType = t, this.urlSerializer = e, this.rootContexts = i, this.location = n, this.config = a, this.lastSuccessfulNavigation = null, this.currentNavigation = null, this.disposed = !1, this.lastLocationChangeInfo = null, this.navigationId = 0, this.currentPageId = 0, this.isNgZoneEnabled = !1, this.events = new S, this.errorHandler = Gp, this.malformedUriErrorHandler = Zp, this.navigated = !1, this.lastSuccessfulId = -1, this.hooks = { beforePreactivation: Kp, afterPreactivation: Kp }, this.urlHandlingStrategy = new qp, this.routeReuseStrategy = new Hp, this.onSameUrlNavigation = "ignore", this.paramsInheritanceStrategy = "emptyOnly", this.urlUpdateStrategy = "deferred", this.relativeLinkResolution = "corrected", this.canceledNavigationResolution = "replace", this.ngModule = s.get(Aa), this.console = s.get(El); const l = s.get(Vl); this.isNgZoneEnabled = l instanceof Vl && Vl.isInAngularZone(), this.resetConfig(a), this.currentUrlTree = new nd(new sd([], {}), {}, null), this.rawUrlTree = this.currentUrlTree, this.browserUrlTree = this.currentUrlTree, this.configLoader = new $p(r, o, t => this.triggerEvent(new Mu(t)), t => this.triggerEvent(new Iu(t))), this.routerState = Dd(this.currentUrlTree, this.rootComponentType), this.transitions = new Ah({ id: 0, targetPageId: 0, currentUrlTree: this.currentUrlTree, currentRawUrl: this.currentUrlTree, extractedUrl: this.urlHandlingStrategy.extract(this.currentUrlTree), urlAfterRedirects: this.urlHandlingStrategy.extract(this.currentUrlTree), rawUrl: this.currentUrlTree, extras: {}, resolve: null, reject: null, promise: Promise.resolve(!0), source: "imperative", restoredState: null, currentSnapshot: this.routerState.snapshot, targetSnapshot: null, currentRouterState: this.routerState, targetRouterState: null, guards: { canActivateChecks: [], canDeactivateChecks: [] }, guardsResult: null }), this.navigations = this.setupNavigations(this.transitions), this.processNavigations() } setupNavigations(t) { const e = this.events; return t.pipe(Jh(t => 0 !== t.id), E(t => Object.assign(Object.assign({}, t), { extractedUrl: this.urlHandlingStrategy.extract(t.rawUrl) })), zh(t => { let i = !1, n = !1; return Dh(t).pipe(vu(t => { this.currentNavigation = { id: t.id, initialUrl: t.currentRawUrl, extractedUrl: t.extractedUrl, trigger: t.source, extras: t.extras, previousNavigation: this.lastSuccessfulNavigation ? Object.assign(Object.assign({}, this.lastSuccessfulNavigation), { previousNavigation: null }) : null } }), zh(t => { const i = !this.navigated || t.extractedUrl.toString() !== this.browserUrlTree.toString(); if (("reload" === this.onSameUrlNavigation || i) && this.urlHandlingStrategy.shouldProcessUrl(t.rawUrl)) return Dh(t).pipe(zh(t => { const i = this.transitions.getValue(); return e.next(new ku(t.id, this.serializeUrl(t.extractedUrl), t.source, t.restoredState)), i !== this.transitions.getValue() ? Vh : Promise.resolve(t) }), function (t, e, i, n) { return zh(s => function (t, e, i, n, s) { return new Sp(t, e, i, n, s).apply() }(t, e, i, s.extractedUrl, n).pipe(E(t => Object.assign(Object.assign({}, s), { urlAfterRedirects: t })))) }(this.ngModule.injector, this.configLoader, this.urlSerializer, this.config), vu(t => { this.currentNavigation = Object.assign(Object.assign({}, this.currentNavigation), { finalUrl: t.urlAfterRedirects }) }), function (t, e, i, n, s) { return B(r => function (t, e, i, n, s = "emptyOnly", r = "legacy") { try { const o = new Mp(t, e, i, n, s, r).recognize(); return null === o ? Rp(new Op) : Dh(o) } catch (o) { return Rp(o) } }(t, e, r.urlAfterRedirects, i(r.urlAfterRedirects), n, s).pipe(E(t => Object.assign(Object.assign({}, r), { targetSnapshot: t })))) }(this.rootComponentType, this.config, t => this.serializeUrl(t), this.paramsInheritanceStrategy, this.relativeLinkResolution), vu(t => { "eager" === this.urlUpdateStrategy && (t.extras.skipLocationChange || this.setBrowserUrl(t.urlAfterRedirects, t), this.browserUrlTree = t.urlAfterRedirects); const i = new Pu(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot); e.next(i) })); if (i && this.rawUrlTree && this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)) { const { id: i, extractedUrl: n, source: s, restoredState: r, extras: o } = t, a = new ku(i, this.serializeUrl(n), s, r); e.next(a); const l = Dd(n, this.rootComponentType).snapshot; return Dh(Object.assign(Object.assign({}, t), { targetSnapshot: l, urlAfterRedirects: n, extras: Object.assign(Object.assign({}, o), { skipLocationChange: !1, replaceUrl: !1 }) })) } return this.rawUrlTree = t.rawUrl, this.browserUrlTree = t.urlAfterRedirects, t.resolve(null), Vh }), Bp(t => { const { targetSnapshot: e, id: i, extractedUrl: n, rawUrl: s, extras: { skipLocationChange: r, replaceUrl: o } } = t; return this.hooks.beforePreactivation(e, { navigationId: i, appliedUrlTree: n, rawUrlTree: s, skipLocationChange: !!r, replaceUrl: !!o }) }), vu(t => { const e = new Du(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot); this.triggerEvent(e) }), E(t => Object.assign(Object.assign({}, t), { guards: Tp(t.targetSnapshot, t.currentSnapshot, this.rootContexts) })), function (t, e) { return B(i => { const { targetSnapshot: n, currentSnapshot: s, guards: { canActivateChecks: r, canDeactivateChecks: o } } = i; return 0 === o.length && 0 === r.length ? Dh(Object.assign(Object.assign({}, i), { guardsResult: !0 })) : function (t, e, i, n) { return F(t).pipe(B(t => function (t, e, i, n, s) { const r = e && e.routeConfig ? e.routeConfig.canDeactivate : null; return r && 0 !== r.length ? Dh(r.map(r => { const o = Pp(r, e, s); let a; if (function (t) { return t && ep(t.canDeactivate) }(o)) a = Yu(o.canDeactivate(t, e, i, n)); else { if (!ep(o)) throw new Error("Invalid CanDeactivate guard"); a = Yu(o(t, e, i, n)) } return a.pipe(mu()) })).pipe(sp()) : Dh(!0) }(t.component, t.route, i, e, n)), mu(t => !0 !== t, !0)) }(o, n, s, t).pipe(B(i => i && "boolean" == typeof i ? function (t, e, i, n) { return F(e).pipe(ru(e => jh(function (t, e) { return null !== t && e && e(new Lu(t)), Dh(!0) }(e.route.parent, n), function (t, e) { return null !== t && e && e(new Nu(t)), Dh(!0) }(e.route, n), function (t, e, i) { const n = e[e.length - 1], s = e.slice(0, e.length - 1).reverse().map(t => function (t) { const e = t.routeConfig ? t.routeConfig.canActivateChild : null; return e && 0 !== e.length ? { node: t, guards: e } : null }(t)).filter(t => null !== t).map(e => Hh(() => Dh(e.guards.map(s => { const r = Pp(s, e.node, i); let o; if (function (t) { return t && ep(t.canActivateChild) }(r)) o = Yu(r.canActivateChild(n, t)); else { if (!ep(r)) throw new Error("Invalid CanActivateChild guard"); o = Yu(r(n, t)) } return o.pipe(mu()) })).pipe(sp()))); return Dh(s).pipe(sp()) }(t, e.path, i), function (t, e, i) { const n = e.routeConfig ? e.routeConfig.canActivate : null; return n && 0 !== n.length ? Dh(n.map(n => Hh(() => { const s = Pp(n, e, i); let r; if (function (t) { return t && ep(t.canActivate) }(s)) r = Yu(s.canActivate(e, t)); else { if (!ep(s)) throw new Error("Invalid CanActivate guard"); r = Yu(s(e, t)) } return r.pipe(mu()) }))).pipe(sp()) : Dh(!0) }(t, e.route, i))), mu(t => !0 !== t, !0)) }(n, r, t, e) : Dh(i)), E(t => Object.assign(Object.assign({}, i), { guardsResult: t }))) }) }(this.ngModule.injector, t => this.triggerEvent(t)), vu(t => { if (ip(t.guardsResult)) { const e = $u(`Redirecting to "${this.serializeUrl(t.guardsResult)}"`); throw e.url = t.guardsResult, e } const e = new Au(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot, !!t.guardsResult); this.triggerEvent(e) }), Jh(t => !!t.guardsResult || (this.cancelNavigationTransition(t, ""), !1)), Bp(t => { if (t.guards.canActivateChecks.length) return Dh(t).pipe(vu(t => { const e = new Ou(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot); this.triggerEvent(e) }), zh(t => { let e = !1; return Dh(t).pipe((i = this.paramsInheritanceStrategy, n = this.ngModule.injector, B(t => { const { targetSnapshot: e, guards: { canActivateChecks: s } } = t; if (!s.length) return Dh(t); let r = 0; return F(s).pipe(ru(t => function (t, e, i, n) { return function (t, e, i, n) { const s = Object.keys(t); if (0 === s.length) return Dh({}); const r = {}; return F(s).pipe(B(s => function (t, e, i, n) { const s = Pp(t, e, n); return Yu(s.resolve ? s.resolve(e, i) : s(e, i)) }(t[s], e, i, n).pipe(vu(t => { r[s] = t }))), ou(1), B(() => Object.keys(r).length === s.length ? Dh(r) : Vh)) }(t._resolve, t, e, n).pipe(E(e => (t._resolvedData = e, t.data = Object.assign(Object.assign({}, t.data), Od(t, i).resolve), null))) }(t.route, e, i, n)), vu(() => r++), ou(1), B(e => r === s.length ? Dh(t) : Vh)) })), vu({ next: () => e = !0, complete: () => { e || this.cancelNavigationTransition(t, "At least one route resolver didn't emit any value.") } })); var i, n }), vu(t => { const e = new Ru(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot); this.triggerEvent(e) })) }), Bp(t => { const { targetSnapshot: e, id: i, extractedUrl: n, rawUrl: s, extras: { skipLocationChange: r, replaceUrl: o } } = t; return this.hooks.afterPreactivation(e, { navigationId: i, appliedUrlTree: n, rawUrlTree: s, skipLocationChange: !!r, replaceUrl: !!o }) }), E(t => { const e = function (t, e, i) { const n = jd(t, e._root, i ? i._root : void 0); return new Pd(n, e) }(this.routeReuseStrategy, t.targetSnapshot, t.currentRouterState); return Object.assign(Object.assign({}, t), { targetRouterState: e }) }), vu(t => { this.currentUrlTree = t.urlAfterRedirects, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, t.rawUrl), this.routerState = t.targetRouterState, "deferred" === this.urlUpdateStrategy && (t.extras.skipLocationChange || this.setBrowserUrl(this.rawUrlTree, t), this.browserUrlTree = t.urlAfterRedirects) }), (s = this.rootContexts, r = this.routeReuseStrategy, o = t => this.triggerEvent(t), E(t => (new Xd(r, t.targetRouterState, t.currentRouterState, o).activate(s), t))), vu({ next() { i = !0 }, complete() { i = !0 } }), function (t) { return e => e.lift(new wu(t)) }(() => { i || n || this.cancelNavigationTransition(t, `Navigation ID ${t.id} is not equal to the current navigation id ${this.navigationId}`), this.currentNavigation = null }), iu(i => { if (n = !0, (s = i) && s.ngNavigationCancelingError) { const n = ip(i.url); n || (this.navigated = !0, this.resetStateAndUrl(t.currentRouterState, t.currentUrlTree, t.rawUrl)); const s = new Eu(t.id, this.serializeUrl(t.extractedUrl), i.message); e.next(s), n ? setTimeout(() => { const e = this.urlHandlingStrategy.merge(i.url, this.rawUrlTree); this.scheduleNavigation(e, "imperative", null, { skipLocationChange: t.extras.skipLocationChange, replaceUrl: "eager" === this.urlUpdateStrategy }, { resolve: t.resolve, reject: t.reject, promise: t.promise }) }, 0) : t.resolve(!1) } else { this.resetStateAndUrl(t.currentRouterState, t.currentUrlTree, t.rawUrl); const n = new Tu(t.id, this.serializeUrl(t.extractedUrl), i); e.next(n); try { t.resolve(this.errorHandler(i)) } catch (r) { t.reject(r) } } var s; return Vh })); var s, r, o })) } resetRootComponentType(t) { this.rootComponentType = t, this.routerState.root.component = this.rootComponentType } getTransition() { const t = this.transitions.value; return t.urlAfterRedirects = this.browserUrlTree, t } setTransition(t) { this.transitions.next(Object.assign(Object.assign({}, this.getTransition()), t)) } initialNavigation() { this.setUpLocationChangeListener(), 0 === this.navigationId && this.navigateByUrl(this.location.path(!0), { replaceUrl: !0 }) } setUpLocationChangeListener() { this.locationSubscription || (this.locationSubscription = this.location.subscribe(t => { const e = this.extractLocationChangeInfoFromEvent(t); this.shouldScheduleNavigation(this.lastLocationChangeInfo, e) && setTimeout(() => { const { source: t, state: i, urlTree: n } = e, s = { replaceUrl: !0 }; if (i) { const t = Object.assign({}, i); delete t.navigationId, delete t.\u0275routerPageId, 0 !== Object.keys(t).length && (s.state = t) } this.scheduleNavigation(n, t, i, s) }, 0), this.lastLocationChangeInfo = e })) } extractLocationChangeInfoFromEvent(t) { var e; return { source: "popstate" === t.type ? "popstate" : "hashchange", urlTree: this.parseUrl(t.url), state: (null === (e = t.state) || void 0 === e ? void 0 : e.navigationId) ? t.state : null, transitionId: this.getTransition().id } } shouldScheduleNavigation(t, e) { if (!t) return !0; const i = e.urlTree.toString() === t.urlTree.toString(); return !(e.transitionId === t.transitionId && i && ("hashchange" === e.source && "popstate" === t.source || "popstate" === e.source && "hashchange" === t.source)) } get url() { return this.serializeUrl(this.currentUrlTree) } getCurrentNavigation() { return this.currentNavigation } triggerEvent(t) { this.events.next(t) } resetConfig(t) { op(t), this.config = t.map(cp), this.navigated = !1, this.lastSuccessfulId = -1 } ngOnDestroy() { this.dispose() } dispose() { this.transitions.complete(), this.locationSubscription && (this.locationSubscription.unsubscribe(), this.locationSubscription = void 0), this.disposed = !0 } createUrlTree(t, e = {}) { const { relativeTo: i, queryParams: n, fragment: s, queryParamsHandling: r, preserveFragment: o } = e, a = i || this.routerState.root, l = o ? this.currentUrlTree.fragment : s; let c = null; switch (r) { case "merge": c = Object.assign(Object.assign({}, this.currentUrlTree.queryParams), n); break; case "preserve": c = this.currentUrlTree.queryParams; break; default: c = n || null }return null !== c && (c = this.removeEmptyProps(c)), function (t, e, i, n, s) { if (0 === i.length) return zd(e.root, e.root, e, n, s); const r = function (t) { if ("string" == typeof t[0] && 1 === t.length && "/" === t[0]) return new Ud(!0, 0, t); let e = 0, i = !1; const n = t.reduce((t, n, s) => { if ("object" == typeof n && null != n) { if (n.outlets) { const e = {}; return Ku(n.outlets, (t, i) => { e[i] = "string" == typeof t ? t.split("/") : t }), [...t, { outlets: e }] } if (n.segmentPath) return [...t, n.segmentPath] } return "string" != typeof n ? [...t, n] : 0 === s ? (n.split("/").forEach((n, s) => { 0 == s && "." === n || (0 == s && "" === n ? i = !0 : ".." === n ? e++ : "" != n && t.push(n)) }), t) : [...t, n] }, []); return new Ud(i, e, n) }(i); if (r.toRoot()) return zd(e.root, new sd([], {}), e, n, s); const o = function (t, e, i) { if (t.isAbsolute) return new Wd(e.root, !0, 0); if (-1 === i.snapshot._lastPathIndex) { const t = i.snapshot._urlSegment; return new Wd(t, t === e.root, 0) } const n = Bd(t.commands[0]) ? 0 : 1; return function (t, e, i) { let n = t, s = e, r = i; for (; r > s;) { if (r -= s, n = n.parent, !n) throw new Error("Invalid number of '../'"); s = n.segments.length } return new Wd(n, !1, s - r) }(i.snapshot._urlSegment, i.snapshot._lastPathIndex + n, t.numberOfDoubleDots) }(r, e, t), a = o.processChildren ? Gd(o.segmentGroup, o.index, r.commands) : qd(o.segmentGroup, o.index, r.commands); return zd(o.segmentGroup, a, e, n, s) }(a, this.currentUrlTree, t, c, null != l ? l : null) } navigateByUrl(t, e = { skipLocationChange: !1 }) { const i = ip(t) ? t : this.parseUrl(t), n = this.urlHandlingStrategy.merge(i, this.rawUrlTree); let s = null; return "computed" === this.canceledNavigationResolution && (0 === this.currentPageId || e.skipLocationChange || e.replaceUrl) && (s = this.location.getState()), this.scheduleNavigation(n, "imperative", s, e) } navigate(t, e = { skipLocationChange: !1 }) { return function (t) { for (let e = 0; e < t.length; e++) { const i = t[e]; if (null == i) throw new Error(`The requested path contains ${i} segment at index ${e}`) } }(t), this.navigateByUrl(this.createUrlTree(t, e), e) } serializeUrl(t) { return this.urlSerializer.serialize(t) } parseUrl(t) { let e; try { e = this.urlSerializer.parse(t) } catch (i) { e = this.malformedUriErrorHandler(i, this.urlSerializer, t) } return e } isActive(t, e) { let i; if (i = !0 === e ? Object.assign({}, Yp) : !1 === e ? Object.assign({}, Qp) : e, ip(t)) return Ju(this.currentUrlTree, t, i); const n = this.parseUrl(t); return Ju(this.currentUrlTree, n, i) } removeEmptyProps(t) { return Object.keys(t).reduce((e, i) => { const n = t[i]; return null != n && (e[i] = n), e }, {}) } processNavigations() { this.navigations.subscribe(t => { this.navigated = !0, this.lastSuccessfulId = t.id, this.currentPageId = t.targetPageId, this.events.next(new Cu(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(this.currentUrlTree))), this.lastSuccessfulNavigation = this.currentNavigation, t.resolve(!0) }, t => { this.console.warn("Unhandled Navigation Error: ") }) } scheduleNavigation(t, e, i, n, s) { if (this.disposed) return Promise.resolve(!1); const r = this.getTransition(), o = "imperative" !== e && "imperative" === (null == r ? void 0 : r.source), a = (this.lastSuccessfulId === r.id || this.currentNavigation ? r.rawUrl : r.urlAfterRedirects).toString() === t.toString(); if (o && a) return Promise.resolve(!0); let l, c, h; s ? (l = s.resolve, c = s.reject, h = s.promise) : h = new Promise((t, e) => { l = t, c = e }); const u = ++this.navigationId; let d; return d = "computed" === this.canceledNavigationResolution ? i && i.\u0275routerPageId ? i.\u0275routerPageId : this.currentPageId + 1 : 0, this.setTransition({ id: u, targetPageId: d, source: e, restoredState: i, currentUrlTree: this.currentUrlTree, currentRawUrl: this.rawUrlTree, rawUrl: t, extras: n, resolve: l, reject: c, promise: h, currentSnapshot: this.routerState.snapshot, currentRouterState: this.routerState }), h.catch(t => Promise.reject(t)) } setBrowserUrl(t, e) { const i = this.urlSerializer.serialize(t), n = Object.assign(Object.assign({}, e.extras.state), this.generateNgRouterState(e.id, e.targetPageId)); this.location.isCurrentPathEqualTo(i) || e.extras.replaceUrl ? this.location.replaceState(i, "", n) : this.location.go(i, "", n) } resetStateAndUrl(t, e, i) { this.routerState = t, this.currentUrlTree = e, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, i), this.resetUrlToCurrentUrlTree() } resetUrlToCurrentUrlTree() { this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), "", this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId)) } cancelNavigationTransition(t, e) { "computed" === this.canceledNavigationResolution ? "popstate" !== t.source && "eager" !== this.urlUpdateStrategy || this.location.historyGo(this.currentPageId - t.targetPageId) : this.resetUrlToCurrentUrlTree(); const i = new Eu(t.id, this.serializeUrl(t.extractedUrl), e); this.triggerEvent(i), t.resolve(!1) } generateNgRouterState(t, e) { return "computed" === this.canceledNavigationResolution ? { navigationId: t, "\u0275routerPageId": e } : { navigationId: t } } } return t.\u0275fac = function (e) { return new (e || t)(hn(Gi), hn(ad), hn(Wp), hn(Mc), hn(Pr), hn(lc), hn(Fl), hn(void 0)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), Jp = (() => { class t { constructor(t, e, i) { this.router = t, this.route = e, this.locationStrategy = i, this.commands = [], this.onChanges = new S, this.subscription = t.events.subscribe(t => { t instanceof Cu && this.updateTargetUrlAndHref() }) } set routerLink(t) { this.commands = null != t ? Array.isArray(t) ? t : [t] : [] } ngOnChanges(t) { this.updateTargetUrlAndHref(), this.onChanges.next(this) } ngOnDestroy() { this.subscription.unsubscribe() } onClick(t, e, i, n, s) { if (0 !== t || e || i || n || s) return !0; if ("string" == typeof this.target && "_self" != this.target) return !0; const r = { skipLocationChange: tf(this.skipLocationChange), replaceUrl: tf(this.replaceUrl), state: this.state }; return this.router.navigateByUrl(this.urlTree, r), !1 } updateTargetUrlAndHref() { this.href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.urlTree)) } get urlTree() { return this.router.createUrlTree(this.commands, { relativeTo: void 0 !== this.relativeTo ? this.relativeTo : this.route, queryParams: this.queryParams, fragment: this.fragment, queryParamsHandling: this.queryParamsHandling, preserveFragment: tf(this.preserveFragment) }) } } return t.\u0275fac = function (e) { return new (e || t)(Ur(Xp), Ur(Ad), Ur(Pc)) }, t.\u0275dir = Kt({ type: t, selectors: [["a", "routerLink", ""], ["area", "routerLink", ""]], hostVars: 2, hostBindings: function (t, e) { 1 & t && Jr("click", function (t) { return e.onClick(t.button, t.ctrlKey, t.shiftKey, t.altKey, t.metaKey) }), 2 & t && (Co("href", e.href, xn), Hr("target", e.target)) }, inputs: { routerLink: "routerLink", target: "target", queryParams: "queryParams", fragment: "fragment", queryParamsHandling: "queryParamsHandling", preserveFragment: "preserveFragment", skipLocationChange: "skipLocationChange", replaceUrl: "replaceUrl", state: "state", relativeTo: "relativeTo" }, features: [le] }), t })(); function tf(t) { return "" === t || !!t } let ef = (() => { class t { constructor(t, e, i, n, s) { this.parentContexts = t, this.location = e, this.resolver = i, this.changeDetector = s, this.activated = null, this._activatedRoute = null, this.activateEvents = new Ja, this.deactivateEvents = new Ja, this.name = n || Bu, t.onChildOutletCreated(this.name, this) } ngOnDestroy() { this.parentContexts.onChildOutletDestroyed(this.name) } ngOnInit() { if (!this.activated) { const t = this.parentContexts.getContext(this.name); t && t.route && (t.attachRef ? this.attach(t.attachRef, t.route) : this.activateWith(t.route, t.resolver || null)) } } get isActivated() { return !!this.activated } get component() { if (!this.activated) throw new Error("Outlet is not activated"); return this.activated.instance } get activatedRoute() { if (!this.activated) throw new Error("Outlet is not activated"); return this._activatedRoute } get activatedRouteData() { return this._activatedRoute ? this._activatedRoute.snapshot.data : {} } detach() { if (!this.activated) throw new Error("Outlet is not activated"); this.location.detach(); const t = this.activated; return this.activated = null, this._activatedRoute = null, t } attach(t, e) { this.activated = t, this._activatedRoute = e, this.location.insert(t.hostView) } deactivate() { if (this.activated) { const t = this.component; this.activated.destroy(), this.activated = null, this._activatedRoute = null, this.deactivateEvents.emit(t) } } activateWith(t, e) { if (this.isActivated) throw new Error("Cannot activate an already activated outlet"); this._activatedRoute = t; const i = (e = e || this.resolver).resolveComponentFactory(t._futureSnapshot.routeConfig.component), n = this.parentContexts.getOrCreateContext(this.name).children, s = new nf(t, n, this.location.injector); this.activated = this.location.createComponent(i, this.location.length, s), this.changeDetector.markForCheck(), this.activateEvents.emit(this.activated.instance) } } return t.\u0275fac = function (e) { return new (e || t)(Ur(Wp), Ur(Ma), Ur(Wo), ("name", function (t, e) { const i = t.attrs; if (i) { const t = i.length; let n = 0; for (; n < t;) { const s = i[n]; if (gi(s)) break; if (0 === s) n += 2; else if ("number" == typeof s) for (n++; n < t && "string" == typeof i[n];)n++; else { if (s === e) return i[n + 1]; n += 2 } } } return null }(Re(), "name")), Ur(wa)) }, t.\u0275dir = Kt({ type: t, selectors: [["router-outlet"]], outputs: { activateEvents: "activate", deactivateEvents: "deactivate" }, exportAs: ["outlet"] }), t })(); class nf { constructor(t, e, i) { this.route = t, this.childContexts = e, this.parent = i } get(t, e) { return t === Ad ? this.route : t === Wp ? this.childContexts : this.parent.get(t, e) } } class sf { } class rf { preload(t, e) { return Dh(null) } } let of = (() => { class t { constructor(t, e, i, n, s) { this.router = t, this.injector = n, this.preloadingStrategy = s, this.loader = new $p(e, i, e => t.triggerEvent(new Mu(e)), e => t.triggerEvent(new Iu(e))) } setUpPreloading() { this.subscription = this.router.events.pipe(Jh(t => t instanceof Cu), ru(() => this.preload())).subscribe(() => { }) } preload() { const t = this.injector.get(Aa); return this.processRoutes(t, this.router.config) } ngOnDestroy() { this.subscription && this.subscription.unsubscribe() } processRoutes(t, e) { const i = []; for (const n of e) if (n.loadChildren && !n.canLoad && n._loadedConfig) { const t = n._loadedConfig; i.push(this.processRoutes(t.module, t.routes)) } else n.loadChildren && !n.canLoad ? i.push(this.preloadConfig(t, n)) : n.children && i.push(this.processRoutes(t, n.children)); return F(i).pipe(U(), E(t => { })) } preloadConfig(t, e) { return this.preloadingStrategy.preload(e, () => (e._loadedConfig ? Dh(e._loadedConfig) : this.loader.load(t.injector, e)).pipe(B(t => (e._loadedConfig = t, this.processRoutes(t.module, t.routes))))) } } return t.\u0275fac = function (e) { return new (e || t)(hn(Xp), hn(lc), hn(Fl), hn(Pr), hn(sf)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), af = (() => { class t { constructor(t, e, i = {}) { this.router = t, this.viewportScroller = e, this.options = i, this.lastId = 0, this.lastSource = "imperative", this.restoredId = 0, this.store = {}, i.scrollPositionRestoration = i.scrollPositionRestoration || "disabled", i.anchorScrolling = i.anchorScrolling || "disabled" } init() { "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.setHistoryScrollRestoration("manual"), this.routerEventsSubscription = this.createScrollEvents(), this.scrollEventsSubscription = this.consumeScrollEvents() } createScrollEvents() { return this.router.events.subscribe(t => { t instanceof ku ? (this.store[this.lastId] = this.viewportScroller.getScrollPosition(), this.lastSource = t.navigationTrigger, this.restoredId = t.restoredState ? t.restoredState.navigationId : 0) : t instanceof Cu && (this.lastId = t.id, this.scheduleScrollEvent(t, this.router.parseUrl(t.urlAfterRedirects).fragment)) }) } consumeScrollEvents() { return this.router.events.subscribe(t => { t instanceof Vu && (t.position ? "top" === this.options.scrollPositionRestoration ? this.viewportScroller.scrollToPosition([0, 0]) : "enabled" === this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition(t.position) : t.anchor && "enabled" === this.options.anchorScrolling ? this.viewportScroller.scrollToAnchor(t.anchor) : "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition([0, 0])) }) } scheduleScrollEvent(t, e) { this.router.triggerEvent(new Vu(t, "popstate" === this.lastSource ? this.store[this.restoredId] : null, e)) } ngOnDestroy() { this.routerEventsSubscription && this.routerEventsSubscription.unsubscribe(), this.scrollEventsSubscription && this.scrollEventsSubscription.unsubscribe() } } return t.\u0275fac = function (e) { return new (e || t)(hn(Xp), hn(Kc), hn(void 0)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); const lf = new Wi("ROUTER_CONFIGURATION"), cf = new Wi("ROUTER_FORROOT_GUARD"), hf = [Mc, { provide: ad, useClass: ld }, { provide: Xp, useFactory: function (t, e, i, n, s, r, o, a = {}, l, c) { const h = new Xp(null, t, e, i, n, s, r, Gu(o)); return l && (h.urlHandlingStrategy = l), c && (h.routeReuseStrategy = c), function (t, e) { t.errorHandler && (e.errorHandler = t.errorHandler), t.malformedUriErrorHandler && (e.malformedUriErrorHandler = t.malformedUriErrorHandler), t.onSameUrlNavigation && (e.onSameUrlNavigation = t.onSameUrlNavigation), t.paramsInheritanceStrategy && (e.paramsInheritanceStrategy = t.paramsInheritanceStrategy), t.relativeLinkResolution && (e.relativeLinkResolution = t.relativeLinkResolution), t.urlUpdateStrategy && (e.urlUpdateStrategy = t.urlUpdateStrategy) }(a, h), a.enableTracing && h.events.subscribe(t => { var e, i; null === (e = console.group) || void 0 === e || e.call(console, `Router Event: ${t.constructor.name}`), console.log(t.toString()), console.log(t), null === (i = console.groupEnd) || void 0 === i || i.call(console) }), h }, deps: [ad, Wp, Mc, Pr, lc, Fl, zp, lf, [class { }, new gn], [class { }, new gn]] }, Wp, { provide: Ad, useFactory: function (t) { return t.routerState.root }, deps: [Xp] }, { provide: lc, useClass: uc }, of, rf, class { preload(t, e) { return e().pipe(iu(() => Dh(null))) } }, { provide: lf, useValue: { enableTracing: !1 } }]; function uf() { return new ec("Router", Xp) } let df = (() => { class t { constructor(t, e) { } static forRoot(e, i) { return { ngModule: t, providers: [hf, mf(e), { provide: cf, useFactory: gf, deps: [[Xp, new gn, new mn]] }, { provide: lf, useValue: i || {} }, { provide: Pc, useFactory: ff, deps: [yc, [new fn(Ac), new gn], lf] }, { provide: af, useFactory: pf, deps: [Xp, Kc, lf] }, { provide: sf, useExisting: i && i.preloadingStrategy ? i.preloadingStrategy : rf }, { provide: ec, multi: !0, useFactory: uf }, [_f, { provide: vl, multi: !0, useFactory: vf, deps: [_f] }, { provide: bf, useFactory: yf, deps: [_f] }, { provide: Cl, multi: !0, useExisting: bf }]] } } static forChild(e) { return { ngModule: t, providers: [mf(e)] } } } return t.\u0275fac = function (e) { return new (e || t)(hn(cf, 8), hn(Xp, 8)) }, t.\u0275mod = Gt({ type: t }), t.\u0275inj = pt({}), t })(); function pf(t, e, i) { return i.scrollOffset && e.setOffset(i.scrollOffset), new af(t, e, i) } function ff(t, e, i = {}) { return i.useHash ? new Rc(t, e) : new Oc(t, e) } function gf(t) { return "guarded" } function mf(t) { return [{ provide: qi, multi: !0, useValue: t }, { provide: zp, multi: !0, useValue: t }] } let _f = (() => { class t { constructor(t) { this.injector = t, this.initNavigation = !1, this.resultOfPreactivationDone = new S } appInitializer() { return this.injector.get(wc, Promise.resolve(null)).then(() => { let t = null; const e = new Promise(e => t = e), i = this.injector.get(Xp), n = this.injector.get(lf); return "disabled" === n.initialNavigation ? (i.setUpLocationChangeListener(), t(!0)) : "enabled" === n.initialNavigation || "enabledBlocking" === n.initialNavigation ? (i.hooks.afterPreactivation = () => this.initNavigation ? Dh(null) : (this.initNavigation = !0, t(!0), this.resultOfPreactivationDone), i.initialNavigation()) : t(!0), e }) } bootstrapListener(t) { const e = this.injector.get(lf), i = this.injector.get(of), n = this.injector.get(af), s = this.injector.get(Xp), r = this.injector.get(oc); t === r.components[0] && ("enabledNonBlocking" !== e.initialNavigation && void 0 !== e.initialNavigation || s.initialNavigation(), i.setUpPreloading(), n.init(), s.resetRootComponentType(r.componentTypes[0]), this.resultOfPreactivationDone.next(null), this.resultOfPreactivationDone.complete()) } } return t.\u0275fac = function (e) { return new (e || t)(hn(Pr)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); function vf(t) { return t.appInitializer.bind(t) } function yf(t) { return t.bootstrapListener.bind(t) } const bf = new Wi("Router Initializer"), wf = "access_token", xf = "auth-user", Sf = "role-user"; let kf = (() => { class t { constructor() { } signOut() { window.localStorage.clear() } savedata(t) { const e = this.decode(t.access_token); console.log("decodedToken :", e), e && (localStorage.setItem(wf, t.access_token), localStorage.setItem(Sf, e.sub)) } getToken() { return localStorage.getItem(wf) } getId() { const t = localStorage.getItem(xf); return t ? Number(t) : null } getRole() { return localStorage.getItem(Sf) } remove() { localStorage.removeItem(wf), localStorage.removeItem(xf), localStorage.removeItem(Sf) } decode(t) { console.log("payload :", t); let e = JSON.parse(atob(this.payload(t))); return console.log("payload :", e), e } payload(t) { console.log("token :", t); let e = t.split(".")[1]; return console.log("x :", e), e } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(); function Cf(t, e) { return new v(i => { const n = t.length; if (0 === n) return void i.complete(); const s = new Array(n); let r = 0, o = 0; for (let a = 0; a < n; a++) { const l = F(t[a]); let c = !1; i.add(l.subscribe({ next: t => { c || (c = !0, o++), s[a] = t }, error: t => i.error(t), complete: () => { r++, r !== n && c || (o === n && i.next(e ? e.reduce((t, e, i) => (t[e] = s[i], t), {}) : s), i.complete()) } })) } }) } let Ef = (() => { class t { constructor(t, e) { this._renderer = t, this._elementRef = e, this.onChange = t => { }, this.onTouched = () => { } } setProperty(t, e) { this._renderer.setProperty(this._elementRef.nativeElement, t, e) } registerOnTouched(t) { this.onTouched = t } registerOnChange(t) { this.onChange = t } setDisabledState(t) { this.setProperty("disabled", t) } } return t.\u0275fac = function (e) { return new (e || t)(Ur(Xo), Ur(Ko)) }, t.\u0275dir = Kt({ type: t }), t })(), Tf = (() => { class t extends Ef { } return t.\u0275fac = function () { let e; return function (i) { return (e || (e = Hi(t)))(i || t) } }(), t.\u0275dir = Kt({ type: t, features: [Ar] }), t })(); const Pf = new Wi("NgValueAccessor"), Df = { provide: Pf, useExisting: rt(() => Of), multi: !0 }, Af = new Wi("CompositionEventMode"); let Of = (() => { class t extends Ef { constructor(t, e, i) { super(t, e), this._compositionMode = i, this._composing = !1, null == this._compositionMode && (this._compositionMode = !function () { const t = _c() ? _c().getUserAgent() : ""; return /android (\d+)/.test(t.toLowerCase()) }()) } writeValue(t) { this.setProperty("value", null == t ? "" : t) } _handleInput(t) { (!this._compositionMode || this._compositionMode && !this._composing) && this.onChange(t) } _compositionStart() { this._composing = !0 } _compositionEnd(t) { this._composing = !1, this._compositionMode && this.onChange(t) } } return t.\u0275fac = function (e) { return new (e || t)(Ur(Xo), Ur(Ko), Ur(Af, 8)) }, t.\u0275dir = Kt({ type: t, selectors: [["input", "formControlName", "", 3, "type", "checkbox"], ["textarea", "formControlName", ""], ["input", "formControl", "", 3, "type", "checkbox"], ["textarea", "formControl", ""], ["input", "ngModel", "", 3, "type", "checkbox"], ["textarea", "ngModel", ""], ["", "ngDefaultControl", ""]], hostBindings: function (t, e) { 1 & t && Jr("input", function (t) { return e._handleInput(t.target.value) })("blur", function () { return e.onTouched() })("compositionstart", function () { return e._compositionStart() })("compositionend", function (t) { return e._compositionEnd(t.target.value) }) }, features: [zo([Df]), Ar] }), t })(); function Rf(t) { return null == t || 0 === t.length } function Mf(t) { return null != t && "number" == typeof t.length } const If = new Wi("NgValidators"), Lf = new Wi("NgAsyncValidators"), Ff = /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/; class Nf { static min(t) { return function (t) { return e => { if (Rf(e.value) || Rf(t)) return null; const i = parseFloat(e.value); return !isNaN(i) && i < t ? { min: { min: t, actual: e.value } } : null } }(t) } static max(t) { return function (t) { return e => { if (Rf(e.value) || Rf(t)) return null; const i = parseFloat(e.value); return !isNaN(i) && i > t ? { max: { max: t, actual: e.value } } : null } }(t) } static required(t) { return function (t) { return Rf(t.value) ? { required: !0 } : null }(t) } static requiredTrue(t) { return function (t) { return !0 === t.value ? null : { required: !0 } }(t) } static email(t) { return function (t) { return Rf(t.value) || Ff.test(t.value) ? null : { email: !0 } }(t) } static minLength(t) { return function (t) { return e => Rf(e.value) || !Mf(e.value) ? null : e.value.length < t ? { minlength: { requiredLength: t, actualLength: e.value.length } } : null }(t) } static maxLength(t) { return function (t) { return e => Mf(e.value) && e.value.length > t ? { maxlength: { requiredLength: t, actualLength: e.value.length } } : null }(t) } static pattern(t) { return function (t) { if (!t) return jf; let e, i; return "string" == typeof t ? (i = "", "^" !== t.charAt(0) && (i += "^"), i += t, "$" !== t.charAt(t.length - 1) && (i += "$"), e = new RegExp(i)) : (i = t.toString(), e = t), t => { if (Rf(t.value)) return null; const n = t.value; return e.test(n) ? null : { pattern: { requiredPattern: i, actualValue: n } } } }(t) } static nullValidator(t) { return null } static compose(t) { return Uf(t) } static composeAsync(t) { return qf(t) } } function jf(t) { return null } function Vf(t) { return null != t } function Bf(t) { const e = Qr(t) ? F(t) : t; return Xr(e), e } function Hf(t) { let e = {}; return t.forEach(t => { e = null != t ? Object.assign(Object.assign({}, e), t) : e }), 0 === Object.keys(e).length ? null : e } function zf(t, e) { return e.map(e => e(t)) } function $f(t) { return t.map(t => function (t) { return !t.validate }(t) ? t : e => t.validate(e)) } function Uf(t) { if (!t) return null; const e = t.filter(Vf); return 0 == e.length ? null : function (t) { return Hf(zf(t, e)) } } function Wf(t) { return null != t ? Uf($f(t)) : null } function qf(t) { if (!t) return null; const e = t.filter(Vf); return 0 == e.length ? null : function (t) { return function (...t) { if (1 === t.length) { const e = t[0]; if (l(e)) return Cf(e, null); if (c(e) && Object.getPrototypeOf(e) === Object.prototype) { const t = Object.keys(e); return Cf(t.map(t => e[t]), t) } } if ("function" == typeof t[t.length - 1]) { const e = t.pop(); return Cf(t = 1 === t.length && l(t[0]) ? t[0] : t, null).pipe(E(t => e(...t))) } return Cf(t, null) }(zf(t, e).map(Bf)).pipe(E(Hf)) } } function Gf(t) { return null != t ? qf($f(t)) : null } function Zf(t, e) { return null === t ? [e] : Array.isArray(t) ? [...t, e] : [t, e] } function Kf(t) { return t._rawValidators } function Yf(t) { return t._rawAsyncValidators } let Qf = (() => { class t { constructor() { this._rawValidators = [], this._rawAsyncValidators = [], this._onDestroyCallbacks = [] } get value() { return this.control ? this.control.value : null } get valid() { return this.control ? this.control.valid : null } get invalid() { return this.control ? this.control.invalid : null } get pending() { return this.control ? this.control.pending : null } get disabled() { return this.control ? this.control.disabled : null } get enabled() { return this.control ? this.control.enabled : null } get errors() { return this.control ? this.control.errors : null } get pristine() { return this.control ? this.control.pristine : null } get dirty() { return this.control ? this.control.dirty : null } get touched() { return this.control ? this.control.touched : null } get status() { return this.control ? this.control.status : null } get untouched() { return this.control ? this.control.untouched : null } get statusChanges() { return this.control ? this.control.statusChanges : null } get valueChanges() { return this.control ? this.control.valueChanges : null } get path() { return null } _setValidators(t) { this._rawValidators = t || [], this._composedValidatorFn = Wf(this._rawValidators) } _setAsyncValidators(t) { this._rawAsyncValidators = t || [], this._composedAsyncValidatorFn = Gf(this._rawAsyncValidators) } get validator() { return this._composedValidatorFn || null } get asyncValidator() { return this._composedAsyncValidatorFn || null } _registerOnDestroy(t) { this._onDestroyCallbacks.push(t) } _invokeOnDestroyCallbacks() { this._onDestroyCallbacks.forEach(t => t()), this._onDestroyCallbacks = [] } reset(t) { this.control && this.control.reset(t) } hasError(t, e) { return !!this.control && this.control.hasError(t, e) } getError(t, e) { return this.control ? this.control.getError(t, e) : null } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = Kt({ type: t }), t })(), Xf = (() => { class t extends Qf { get formDirective() { return null } get path() { return null } } return t.\u0275fac = function () { let e; return function (i) { return (e || (e = Hi(t)))(i || t) } }(), t.\u0275dir = Kt({ type: t, features: [Ar] }), t })(); class Jf extends Qf { constructor() { super(...arguments), this._parent = null, this.name = null, this.valueAccessor = null } } class tg { constructor(t) { this._cd = t } is(t) { var e, i; return !!(null === (i = null === (e = this._cd) || void 0 === e ? void 0 : e.control) || void 0 === i ? void 0 : i[t]) } } let eg = (() => { class t extends tg { constructor(t) { super(t) } } return t.\u0275fac = function (e) { return new (e || t)(Ur(Jf, 2)) }, t.\u0275dir = Kt({ type: t, selectors: [["", "formControlName", ""], ["", "ngModel", ""], ["", "formControl", ""]], hostVars: 14, hostBindings: function (t, e) { 2 & t && uo("ng-untouched", e.is("untouched"))("ng-touched", e.is("touched"))("ng-pristine", e.is("pristine"))("ng-dirty", e.is("dirty"))("ng-valid", e.is("valid"))("ng-invalid", e.is("invalid"))("ng-pending", e.is("pending")) }, features: [Ar] }), t })(), ig = (() => { class t extends tg { constructor(t) { super(t) } } return t.\u0275fac = function (e) { return new (e || t)(Ur(Xf, 10)) }, t.\u0275dir = Kt({ type: t, selectors: [["", "formGroupName", ""], ["", "formArrayName", ""], ["", "ngModelGroup", ""], ["", "formGroup", ""], ["form", 3, "ngNoForm", ""], ["", "ngForm", ""]], hostVars: 14, hostBindings: function (t, e) { 2 & t && uo("ng-untouched", e.is("untouched"))("ng-touched", e.is("touched"))("ng-pristine", e.is("pristine"))("ng-dirty", e.is("dirty"))("ng-valid", e.is("valid"))("ng-invalid", e.is("invalid"))("ng-pending", e.is("pending")) }, features: [Ar] }), t })(); function ng(t, e) { return [...e.path, t] } function sg(t, e) { ag(t, e), e.valueAccessor.writeValue(t.value), function (t, e) { e.valueAccessor.registerOnChange(i => { t._pendingValue = i, t._pendingChange = !0, t._pendingDirty = !0, "change" === t.updateOn && cg(t, e) }) }(t, e), function (t, e) { const i = (t, i) => { e.valueAccessor.writeValue(t), i && e.viewToModelUpdate(t) }; t.registerOnChange(i), e._registerOnDestroy(() => { t._unregisterOnChange(i) }) }(t, e), function (t, e) { e.valueAccessor.registerOnTouched(() => { t._pendingTouched = !0, "blur" === t.updateOn && t._pendingChange && cg(t, e), "submit" !== t.updateOn && t.markAsTouched() }) }(t, e), function (t, e) { if (e.valueAccessor.setDisabledState) { const i = t => { e.valueAccessor.setDisabledState(t) }; t.registerOnDisabledChange(i), e._registerOnDestroy(() => { t._unregisterOnDisabledChange(i) }) } }(t, e) } function rg(t, e, i = !0) { const n = () => { }; e.valueAccessor && (e.valueAccessor.registerOnChange(n), e.valueAccessor.registerOnTouched(n)), lg(t, e), t && (e._invokeOnDestroyCallbacks(), t._registerOnCollectionChange(() => { })) } function og(t, e) { t.forEach(t => { t.registerOnValidatorChange && t.registerOnValidatorChange(e) }) } function ag(t, e) { const i = Kf(t); null !== e.validator ? t.setValidators(Zf(i, e.validator)) : "function" == typeof i && t.setValidators([i]); const n = Yf(t); null !== e.asyncValidator ? t.setAsyncValidators(Zf(n, e.asyncValidator)) : "function" == typeof n && t.setAsyncValidators([n]); const s = () => t.updateValueAndValidity(); og(e._rawValidators, s), og(e._rawAsyncValidators, s) } function lg(t, e) { let i = !1; if (null !== t) { if (null !== e.validator) { const n = Kf(t); if (Array.isArray(n) && n.length > 0) { const s = n.filter(t => t !== e.validator); s.length !== n.length && (i = !0, t.setValidators(s)) } } if (null !== e.asyncValidator) { const n = Yf(t); if (Array.isArray(n) && n.length > 0) { const s = n.filter(t => t !== e.asyncValidator); s.length !== n.length && (i = !0, t.setAsyncValidators(s)) } } } const n = () => { }; return og(e._rawValidators, n), og(e._rawAsyncValidators, n), i } function cg(t, e) { t._pendingDirty && t.markAsDirty(), t.setValue(t._pendingValue, { emitModelToViewChange: !1 }), e.viewToModelUpdate(t._pendingValue), t._pendingChange = !1 } function hg(t, e) { ag(t, e) } function ug(t, e) { if (!t.hasOwnProperty("model")) return !1; const i = t.model; return !!i.isFirstChange() || !Object.is(e, i.currentValue) } function dg(t, e) { t._syncPendingControls(), e.forEach(t => { const e = t.control; "submit" === e.updateOn && e._pendingChange && (t.viewToModelUpdate(e._pendingValue), e._pendingChange = !1) }) } function pg(t, e) { if (!e) return null; let i, n, s; return Array.isArray(e), e.forEach(t => { t.constructor === Of ? i = t : Object.getPrototypeOf(t.constructor) === Tf ? n = t : s = t }), s || n || i || null } function fg(t, e) { const i = t.indexOf(e); i > -1 && t.splice(i, 1) } const gg = "VALID", mg = "INVALID", _g = "PENDING", vg = "DISABLED"; function yg(t) { return (Sg(t) ? t.validators : t) || null } function bg(t) { return Array.isArray(t) ? Wf(t) : t || null } function wg(t, e) { return (Sg(e) ? e.asyncValidators : t) || null } function xg(t) { return Array.isArray(t) ? Gf(t) : t || null } function Sg(t) { return null != t && !Array.isArray(t) && "object" == typeof t } class kg { constructor(t, e) { this._hasOwnPendingAsyncValidator = !1, this._onCollectionChange = () => { }, this._parent = null, this.pristine = !0, this.touched = !1, this._onDisabledChange = [], this._rawValidators = t, this._rawAsyncValidators = e, this._composedValidatorFn = bg(this._rawValidators), this._composedAsyncValidatorFn = xg(this._rawAsyncValidators) } get validator() { return this._composedValidatorFn } set validator(t) { this._rawValidators = this._composedValidatorFn = t } get asyncValidator() { return this._composedAsyncValidatorFn } set asyncValidator(t) { this._rawAsyncValidators = this._composedAsyncValidatorFn = t } get parent() { return this._parent } get valid() { return this.status === gg } get invalid() { return this.status === mg } get pending() { return this.status == _g } get disabled() { return this.status === vg } get enabled() { return this.status !== vg } get dirty() { return !this.pristine } get untouched() { return !this.touched } get updateOn() { return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : "change" } setValidators(t) { this._rawValidators = t, this._composedValidatorFn = bg(t) } setAsyncValidators(t) { this._rawAsyncValidators = t, this._composedAsyncValidatorFn = xg(t) } clearValidators() { this.validator = null } clearAsyncValidators() { this.asyncValidator = null } markAsTouched(t = {}) { this.touched = !0, this._parent && !t.onlySelf && this._parent.markAsTouched(t) } markAllAsTouched() { this.markAsTouched({ onlySelf: !0 }), this._forEachChild(t => t.markAllAsTouched()) } markAsUntouched(t = {}) { this.touched = !1, this._pendingTouched = !1, this._forEachChild(t => { t.markAsUntouched({ onlySelf: !0 }) }), this._parent && !t.onlySelf && this._parent._updateTouched(t) } markAsDirty(t = {}) { this.pristine = !1, this._parent && !t.onlySelf && this._parent.markAsDirty(t) } markAsPristine(t = {}) { this.pristine = !0, this._pendingDirty = !1, this._forEachChild(t => { t.markAsPristine({ onlySelf: !0 }) }), this._parent && !t.onlySelf && this._parent._updatePristine(t) } markAsPending(t = {}) { this.status = _g, !1 !== t.emitEvent && this.statusChanges.emit(this.status), this._parent && !t.onlySelf && this._parent.markAsPending(t) } disable(t = {}) { const e = this._parentMarkedDirty(t.onlySelf); this.status = vg, this.errors = null, this._forEachChild(e => { e.disable(Object.assign(Object.assign({}, t), { onlySelf: !0 })) }), this._updateValue(), !1 !== t.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._updateAncestors(Object.assign(Object.assign({}, t), { skipPristineCheck: e })), this._onDisabledChange.forEach(t => t(!0)) } enable(t = {}) { const e = this._parentMarkedDirty(t.onlySelf); this.status = gg, this._forEachChild(e => { e.enable(Object.assign(Object.assign({}, t), { onlySelf: !0 })) }), this.updateValueAndValidity({ onlySelf: !0, emitEvent: t.emitEvent }), this._updateAncestors(Object.assign(Object.assign({}, t), { skipPristineCheck: e })), this._onDisabledChange.forEach(t => t(!1)) } _updateAncestors(t) { this._parent && !t.onlySelf && (this._parent.updateValueAndValidity(t), t.skipPristineCheck || this._parent._updatePristine(), this._parent._updateTouched()) } setParent(t) { this._parent = t } updateValueAndValidity(t = {}) { this._setInitialStatus(), this._updateValue(), this.enabled && (this._cancelExistingSubscription(), this.errors = this._runValidator(), this.status = this._calculateStatus(), this.status !== gg && this.status !== _g || this._runAsyncValidator(t.emitEvent)), !1 !== t.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._parent && !t.onlySelf && this._parent.updateValueAndValidity(t) } _updateTreeValidity(t = { emitEvent: !0 }) { this._forEachChild(e => e._updateTreeValidity(t)), this.updateValueAndValidity({ onlySelf: !0, emitEvent: t.emitEvent }) } _setInitialStatus() { this.status = this._allControlsDisabled() ? vg : gg } _runValidator() { return this.validator ? this.validator(this) : null } _runAsyncValidator(t) { if (this.asyncValidator) { this.status = _g, this._hasOwnPendingAsyncValidator = !0; const e = Bf(this.asyncValidator(this)); this._asyncValidationSubscription = e.subscribe(e => { this._hasOwnPendingAsyncValidator = !1, this.setErrors(e, { emitEvent: t }) }) } } _cancelExistingSubscription() { this._asyncValidationSubscription && (this._asyncValidationSubscription.unsubscribe(), this._hasOwnPendingAsyncValidator = !1) } setErrors(t, e = {}) { this.errors = t, this._updateControlsErrors(!1 !== e.emitEvent) } get(t) { return function (t, e, i) { if (null == e) return null; if (Array.isArray(e) || (e = e.split(".")), Array.isArray(e) && 0 === e.length) return null; let n = t; return e.forEach(t => { n = n instanceof Eg ? n.controls.hasOwnProperty(t) ? n.controls[t] : null : n instanceof Tg && n.at(t) || null }), n }(this, t) } getError(t, e) { const i = e ? this.get(e) : this; return i && i.errors ? i.errors[t] : null } hasError(t, e) { return !!this.getError(t, e) } get root() { let t = this; for (; t._parent;)t = t._parent; return t } _updateControlsErrors(t) { this.status = this._calculateStatus(), t && this.statusChanges.emit(this.status), this._parent && this._parent._updateControlsErrors(t) } _initObservables() { this.valueChanges = new Ja, this.statusChanges = new Ja } _calculateStatus() { return this._allControlsDisabled() ? vg : this.errors ? mg : this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(_g) ? _g : this._anyControlsHaveStatus(mg) ? mg : gg } _anyControlsHaveStatus(t) { return this._anyControls(e => e.status === t) } _anyControlsDirty() { return this._anyControls(t => t.dirty) } _anyControlsTouched() { return this._anyControls(t => t.touched) } _updatePristine(t = {}) { this.pristine = !this._anyControlsDirty(), this._parent && !t.onlySelf && this._parent._updatePristine(t) } _updateTouched(t = {}) { this.touched = this._anyControlsTouched(), this._parent && !t.onlySelf && this._parent._updateTouched(t) } _isBoxedValue(t) { return "object" == typeof t && null !== t && 2 === Object.keys(t).length && "value" in t && "disabled" in t } _registerOnCollectionChange(t) { this._onCollectionChange = t } _setUpdateStrategy(t) { Sg(t) && null != t.updateOn && (this._updateOn = t.updateOn) } _parentMarkedDirty(t) { return !t && !(!this._parent || !this._parent.dirty) && !this._parent._anyControlsDirty() } } class Cg extends kg { constructor(t = null, e, i) { super(yg(e), wg(i, e)), this._onChange = [], this._applyFormState(t), this._setUpdateStrategy(e), this._initObservables(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }) } setValue(t, e = {}) { this.value = this._pendingValue = t, this._onChange.length && !1 !== e.emitModelToViewChange && this._onChange.forEach(t => t(this.value, !1 !== e.emitViewToModelChange)), this.updateValueAndValidity(e) } patchValue(t, e = {}) { this.setValue(t, e) } reset(t = null, e = {}) { this._applyFormState(t), this.markAsPristine(e), this.markAsUntouched(e), this.setValue(this.value, e), this._pendingChange = !1 } _updateValue() { } _anyControls(t) { return !1 } _allControlsDisabled() { return this.disabled } registerOnChange(t) { this._onChange.push(t) } _unregisterOnChange(t) { fg(this._onChange, t) } registerOnDisabledChange(t) { this._onDisabledChange.push(t) } _unregisterOnDisabledChange(t) { fg(this._onDisabledChange, t) } _forEachChild(t) { } _syncPendingControls() { return !("submit" !== this.updateOn || (this._pendingDirty && this.markAsDirty(), this._pendingTouched && this.markAsTouched(), !this._pendingChange) || (this.setValue(this._pendingValue, { onlySelf: !0, emitModelToViewChange: !1 }), 0)) } _applyFormState(t) { this._isBoxedValue(t) ? (this.value = this._pendingValue = t.value, t.disabled ? this.disable({ onlySelf: !0, emitEvent: !1 }) : this.enable({ onlySelf: !0, emitEvent: !1 })) : this.value = this._pendingValue = t } } class Eg extends kg { constructor(t, e, i) { super(yg(e), wg(i, e)), this.controls = t, this._initObservables(), this._setUpdateStrategy(e), this._setUpControls(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }) } registerControl(t, e) { return this.controls[t] ? this.controls[t] : (this.controls[t] = e, e.setParent(this), e._registerOnCollectionChange(this._onCollectionChange), e) } addControl(t, e, i = {}) { this.registerControl(t, e), this.updateValueAndValidity({ emitEvent: i.emitEvent }), this._onCollectionChange() } removeControl(t, e = {}) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => { }), delete this.controls[t], this.updateValueAndValidity({ emitEvent: e.emitEvent }), this._onCollectionChange() } setControl(t, e, i = {}) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => { }), delete this.controls[t], e && this.registerControl(t, e), this.updateValueAndValidity({ emitEvent: i.emitEvent }), this._onCollectionChange() } contains(t) { return this.controls.hasOwnProperty(t) && this.controls[t].enabled } setValue(t, e = {}) { this._checkAllValuesPresent(t), Object.keys(t).forEach(i => { this._throwIfControlMissing(i), this.controls[i].setValue(t[i], { onlySelf: !0, emitEvent: e.emitEvent }) }), this.updateValueAndValidity(e) } patchValue(t, e = {}) { null != t && (Object.keys(t).forEach(i => { this.controls[i] && this.controls[i].patchValue(t[i], { onlySelf: !0, emitEvent: e.emitEvent }) }), this.updateValueAndValidity(e)) } reset(t = {}, e = {}) { this._forEachChild((i, n) => { i.reset(t[n], { onlySelf: !0, emitEvent: e.emitEvent }) }), this._updatePristine(e), this._updateTouched(e), this.updateValueAndValidity(e) } getRawValue() { return this._reduceChildren({}, (t, e, i) => (t[i] = e instanceof Cg ? e.value : e.getRawValue(), t)) } _syncPendingControls() { let t = this._reduceChildren(!1, (t, e) => !!e._syncPendingControls() || t); return t && this.updateValueAndValidity({ onlySelf: !0 }), t } _throwIfControlMissing(t) { if (!Object.keys(this.controls).length) throw new Error("\n        There are no form controls registered with this group yet. If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      "); if (!this.controls[t]) throw new Error(`Cannot find form control with name: ${t}.`) } _forEachChild(t) { Object.keys(this.controls).forEach(e => { const i = this.controls[e]; i && t(i, e) }) } _setUpControls() { this._forEachChild(t => { t.setParent(this), t._registerOnCollectionChange(this._onCollectionChange) }) } _updateValue() { this.value = this._reduceValue() } _anyControls(t) { for (const e of Object.keys(this.controls)) { const i = this.controls[e]; if (this.contains(e) && t(i)) return !0 } return !1 } _reduceValue() { return this._reduceChildren({}, (t, e, i) => ((e.enabled || this.disabled) && (t[i] = e.value), t)) } _reduceChildren(t, e) { let i = t; return this._forEachChild((t, n) => { i = e(i, t, n) }), i } _allControlsDisabled() { for (const t of Object.keys(this.controls)) if (this.controls[t].enabled) return !1; return Object.keys(this.controls).length > 0 || this.disabled } _checkAllValuesPresent(t) { this._forEachChild((e, i) => { if (void 0 === t[i]) throw new Error(`Must supply a value for form control with name: '${i}'.`) }) } } class Tg extends kg { constructor(t, e, i) { super(yg(e), wg(i, e)), this.controls = t, this._initObservables(), this._setUpdateStrategy(e), this._setUpControls(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }) } at(t) { return this.controls[t] } push(t, e = {}) { this.controls.push(t), this._registerControl(t), this.updateValueAndValidity({ emitEvent: e.emitEvent }), this._onCollectionChange() } insert(t, e, i = {}) { this.controls.splice(t, 0, e), this._registerControl(e), this.updateValueAndValidity({ emitEvent: i.emitEvent }) } removeAt(t, e = {}) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => { }), this.controls.splice(t, 1), this.updateValueAndValidity({ emitEvent: e.emitEvent }) } setControl(t, e, i = {}) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => { }), this.controls.splice(t, 1), e && (this.controls.splice(t, 0, e), this._registerControl(e)), this.updateValueAndValidity({ emitEvent: i.emitEvent }), this._onCollectionChange() } get length() { return this.controls.length } setValue(t, e = {}) { this._checkAllValuesPresent(t), t.forEach((t, i) => { this._throwIfControlMissing(i), this.at(i).setValue(t, { onlySelf: !0, emitEvent: e.emitEvent }) }), this.updateValueAndValidity(e) } patchValue(t, e = {}) { null != t && (t.forEach((t, i) => { this.at(i) && this.at(i).patchValue(t, { onlySelf: !0, emitEvent: e.emitEvent }) }), this.updateValueAndValidity(e)) } reset(t = [], e = {}) { this._forEachChild((i, n) => { i.reset(t[n], { onlySelf: !0, emitEvent: e.emitEvent }) }), this._updatePristine(e), this._updateTouched(e), this.updateValueAndValidity(e) } getRawValue() { return this.controls.map(t => t instanceof Cg ? t.value : t.getRawValue()) } clear(t = {}) { this.controls.length < 1 || (this._forEachChild(t => t._registerOnCollectionChange(() => { })), this.controls.splice(0), this.updateValueAndValidity({ emitEvent: t.emitEvent })) } _syncPendingControls() { let t = this.controls.reduce((t, e) => !!e._syncPendingControls() || t, !1); return t && this.updateValueAndValidity({ onlySelf: !0 }), t } _throwIfControlMissing(t) { if (!this.controls.length) throw new Error("\n        There are no form controls registered with this array yet. If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      "); if (!this.at(t)) throw new Error(`Cannot find form control at index ${t}`) } _forEachChild(t) { this.controls.forEach((e, i) => { t(e, i) }) } _updateValue() { this.value = this.controls.filter(t => t.enabled || this.disabled).map(t => t.value) } _anyControls(t) { return this.controls.some(e => e.enabled && t(e)) } _setUpControls() { this._forEachChild(t => this._registerControl(t)) } _checkAllValuesPresent(t) { this._forEachChild((e, i) => { if (void 0 === t[i]) throw new Error(`Must supply a value for form control at index: ${i}.`) }) } _allControlsDisabled() { for (const t of this.controls) if (t.enabled) return !1; return this.controls.length > 0 || this.disabled } _registerControl(t) { t.setParent(this), t._registerOnCollectionChange(this._onCollectionChange) } } const Pg = { provide: Xf, useExisting: rt(() => Ag) }, Dg = (() => Promise.resolve(null))(); let Ag = (() => { class t extends Xf { constructor(t, e) { super(), this.submitted = !1, this._directives = [], this.ngSubmit = new Ja, this.form = new Eg({}, Wf(t), Gf(e)) } ngAfterViewInit() { this._setUpdateStrategy() } get formDirective() { return this } get control() { return this.form } get path() { return [] } get controls() { return this.form.controls } addControl(t) { Dg.then(() => { const e = this._findContainer(t.path); t.control = e.registerControl(t.name, t.control), sg(t.control, t), t.control.updateValueAndValidity({ emitEvent: !1 }), this._directives.push(t) }) } getControl(t) { return this.form.get(t.path) } removeControl(t) { Dg.then(() => { const e = this._findContainer(t.path); e && e.removeControl(t.name), fg(this._directives, t) }) } addFormGroup(t) { Dg.then(() => { const e = this._findContainer(t.path), i = new Eg({}); hg(i, t), e.registerControl(t.name, i), i.updateValueAndValidity({ emitEvent: !1 }) }) } removeFormGroup(t) { Dg.then(() => { const e = this._findContainer(t.path); e && e.removeControl(t.name) }) } getFormGroup(t) { return this.form.get(t.path) } updateModel(t, e) { Dg.then(() => { this.form.get(t.path).setValue(e) }) } setValue(t) { this.control.setValue(t) } onSubmit(t) { return this.submitted = !0, dg(this.form, this._directives), this.ngSubmit.emit(t), !1 } onReset() { this.resetForm() } resetForm(t) { this.form.reset(t), this.submitted = !1 } _setUpdateStrategy() { this.options && null != this.options.updateOn && (this.form._updateOn = this.options.updateOn) } _findContainer(t) { return t.pop(), t.length ? this.form.get(t) : this.form } } return t.\u0275fac = function (e) { return new (e || t)(Ur(If, 10), Ur(Lf, 10)) }, t.\u0275dir = Kt({ type: t, selectors: [["form", 3, "ngNoForm", "", 3, "formGroup", ""], ["ng-form"], ["", "ngForm", ""]], hostBindings: function (t, e) { 1 & t && Jr("submit", function (t) { return e.onSubmit(t) })("reset", function () { return e.onReset() }) }, inputs: { options: ["ngFormOptions", "options"] }, outputs: { ngSubmit: "ngSubmit" }, exportAs: ["ngForm"], features: [zo([Pg]), Ar] }), t })(); const Og = { provide: Jf, useExisting: rt(() => Mg) }, Rg = (() => Promise.resolve(null))(); let Mg = (() => { class t extends Jf { constructor(t, e, i, n) { super(), this.control = new Cg, this._registered = !1, this.update = new Ja, this._parent = t, this._setValidators(e), this._setAsyncValidators(i), this.valueAccessor = pg(0, n) } ngOnChanges(t) { this._checkForErrors(), this._registered || this._setUpControl(), "isDisabled" in t && this._updateDisabled(t), ug(t, this.viewModel) && (this._updateValue(this.model), this.viewModel = this.model) } ngOnDestroy() { this.formDirective && this.formDirective.removeControl(this) } get path() { return this._parent ? ng(this.name, this._parent) : [this.name] } get formDirective() { return this._parent ? this._parent.formDirective : null } viewToModelUpdate(t) { this.viewModel = t, this.update.emit(t) } _setUpControl() { this._setUpdateStrategy(), this._isStandalone() ? this._setUpStandalone() : this.formDirective.addControl(this), this._registered = !0 } _setUpdateStrategy() { this.options && null != this.options.updateOn && (this.control._updateOn = this.options.updateOn) } _isStandalone() { return !this._parent || !(!this.options || !this.options.standalone) } _setUpStandalone() { sg(this.control, this), this.control.updateValueAndValidity({ emitEvent: !1 }) } _checkForErrors() { this._isStandalone() || this._checkParentType(), this._checkName() } _checkParentType() { } _checkName() { this.options && this.options.name && (this.name = this.options.name), this._isStandalone() } _updateValue(t) { Rg.then(() => { this.control.setValue(t, { emitViewToModelChange: !1 }) }) } _updateDisabled(t) { const e = t.isDisabled.currentValue, i = "" === e || e && "false" !== e; Rg.then(() => { i && !this.control.disabled ? this.control.disable() : !i && this.control.disabled && this.control.enable() }) } } return t.\u0275fac = function (e) { return new (e || t)(Ur(Xf, 9), Ur(If, 10), Ur(Lf, 10), Ur(Pf, 10)) }, t.\u0275dir = Kt({ type: t, selectors: [["", "ngModel", "", 3, "formControlName", "", 3, "formControl", ""]], inputs: { name: "name", isDisabled: ["disabled", "isDisabled"], model: ["ngModel", "model"], options: ["ngModelOptions", "options"] }, outputs: { update: "ngModelChange" }, exportAs: ["ngModel"], features: [zo([Og]), Ar, le] }), t })(), Ig = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = Kt({ type: t, selectors: [["form", 3, "ngNoForm", "", 3, "ngNativeValidate", ""]], hostAttrs: ["novalidate", ""] }), t })(), Lg = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Gt({ type: t }), t.\u0275inj = pt({}), t })(); const Fg = new Wi("NgModelWithFormControlWarning"), Ng = { provide: Xf, useExisting: rt(() => jg) }; let jg = (() => { class t extends Xf { constructor(t, e) { super(), this.validators = t, this.asyncValidators = e, this.submitted = !1, this._onCollectionChange = () => this._updateDomValue(), this.directives = [], this.form = null, this.ngSubmit = new Ja, this._setValidators(t), this._setAsyncValidators(e) } ngOnChanges(t) { this._checkFormPresent(), t.hasOwnProperty("form") && (this._updateValidators(), this._updateDomValue(), this._updateRegistrations(), this._oldForm = this.form) } ngOnDestroy() { this.form && (lg(this.form, this), this.form._onCollectionChange === this._onCollectionChange && this.form._registerOnCollectionChange(() => { })) } get formDirective() { return this } get control() { return this.form } get path() { return [] } addControl(t) { const e = this.form.get(t.path); return sg(e, t), e.updateValueAndValidity({ emitEvent: !1 }), this.directives.push(t), e } getControl(t) { return this.form.get(t.path) } removeControl(t) { rg(t.control || null, t, !1), fg(this.directives, t) } addFormGroup(t) { this._setUpFormContainer(t) } removeFormGroup(t) { this._cleanUpFormContainer(t) } getFormGroup(t) { return this.form.get(t.path) } addFormArray(t) { this._setUpFormContainer(t) } removeFormArray(t) { this._cleanUpFormContainer(t) } getFormArray(t) { return this.form.get(t.path) } updateModel(t, e) { this.form.get(t.path).setValue(e) } onSubmit(t) { return this.submitted = !0, dg(this.form, this.directives), this.ngSubmit.emit(t), !1 } onReset() { this.resetForm() } resetForm(t) { this.form.reset(t), this.submitted = !1 } _updateDomValue() { this.directives.forEach(t => { const e = t.control, i = this.form.get(t.path); e !== i && (rg(e || null, t), i instanceof Cg && (sg(i, t), t.control = i)) }), this.form._updateTreeValidity({ emitEvent: !1 }) } _setUpFormContainer(t) { const e = this.form.get(t.path); hg(e, t), e.updateValueAndValidity({ emitEvent: !1 }) } _cleanUpFormContainer(t) { if (this.form) { const e = this.form.get(t.path); e && function (t, e) { return lg(t, e) }(e, t) && e.updateValueAndValidity({ emitEvent: !1 }) } } _updateRegistrations() { this.form._registerOnCollectionChange(this._onCollectionChange), this._oldForm && this._oldForm._registerOnCollectionChange(() => { }) } _updateValidators() { ag(this.form, this), this._oldForm && lg(this._oldForm, this) } _checkFormPresent() { } } return t.\u0275fac = function (e) { return new (e || t)(Ur(If, 10), Ur(Lf, 10)) }, t.\u0275dir = Kt({ type: t, selectors: [["", "formGroup", ""]], hostBindings: function (t, e) { 1 & t && Jr("submit", function (t) { return e.onSubmit(t) })("reset", function () { return e.onReset() }) }, inputs: { form: ["formGroup", "form"] }, outputs: { ngSubmit: "ngSubmit" }, exportAs: ["ngForm"], features: [zo([Ng]), Ar, le] }), t })(); const Vg = { provide: Jf, useExisting: rt(() => Bg) }; let Bg = (() => { class t extends Jf { constructor(t, e, i, n, s) { super(), this._ngModelWarningConfig = s, this._added = !1, this.update = new Ja, this._ngModelWarningSent = !1, this._parent = t, this._setValidators(e), this._setAsyncValidators(i), this.valueAccessor = pg(0, n) } set isDisabled(t) { } ngOnChanges(t) { this._added || this._setUpControl(), ug(t, this.viewModel) && (this.viewModel = this.model, this.formDirective.updateModel(this, this.model)) } ngOnDestroy() { this.formDirective && this.formDirective.removeControl(this) } viewToModelUpdate(t) { this.viewModel = t, this.update.emit(t) } get path() { return ng(null == this.name ? this.name : this.name.toString(), this._parent) } get formDirective() { return this._parent ? this._parent.formDirective : null } _checkParentType() { } _setUpControl() { this._checkParentType(), this.control = this.formDirective.addControl(this), this.control.disabled && this.valueAccessor.setDisabledState && this.valueAccessor.setDisabledState(!0), this._added = !0 } } return t.\u0275fac = function (e) { return new (e || t)(Ur(Xf, 13), Ur(If, 10), Ur(Lf, 10), Ur(Pf, 10), Ur(Fg, 8)) }, t.\u0275dir = Kt({ type: t, selectors: [["", "formControlName", ""]], inputs: { isDisabled: ["disabled", "isDisabled"], name: ["formControlName", "name"], model: ["ngModel", "model"] }, outputs: { update: "ngModelChange" }, features: [zo([Vg]), Ar, le] }), t._ngModelWarningSentOnce = !1, t })(); const Hg = { provide: Pf, useExisting: rt(() => $g), multi: !0 }; function zg(t, e) { return null == t ? `${e}` : (e && "object" == typeof e && (e = "Object"), `${t}: ${e}`.slice(0, 50)) } let $g = (() => { class t extends Tf { constructor() { super(...arguments), this._optionMap = new Map, this._idCounter = 0, this._compareWith = Object.is } set compareWith(t) { this._compareWith = t } writeValue(t) { this.value = t; const e = this._getOptionId(t); null == e && this.setProperty("selectedIndex", -1); const i = zg(e, t); this.setProperty("value", i) } registerOnChange(t) { this.onChange = e => { this.value = this._getOptionValue(e), t(this.value) } } _registerOption() { return (this._idCounter++).toString() } _getOptionId(t) { for (const e of Array.from(this._optionMap.keys())) if (this._compareWith(this._optionMap.get(e), t)) return e; return null } _getOptionValue(t) { const e = function (t) { return t.split(":")[0] }(t); return this._optionMap.has(e) ? this._optionMap.get(e) : t } } return t.\u0275fac = function () { let e; return function (i) { return (e || (e = Hi(t)))(i || t) } }(), t.\u0275dir = Kt({ type: t, selectors: [["select", "formControlName", "", 3, "multiple", ""], ["select", "formControl", "", 3, "multiple", ""], ["select", "ngModel", "", 3, "multiple", ""]], hostBindings: function (t, e) { 1 & t && Jr("change", function (t) { return e.onChange(t.target.value) })("blur", function () { return e.onTouched() }) }, inputs: { compareWith: "compareWith" }, features: [zo([Hg]), Ar] }), t })(), Ug = (() => { class t { constructor(t, e, i) { this._element = t, this._renderer = e, this._select = i, this._select && (this.id = this._select._registerOption()) } set ngValue(t) { null != this._select && (this._select._optionMap.set(this.id, t), this._setElementValue(zg(this.id, t)), this._select.writeValue(this._select.value)) } set value(t) { this._setElementValue(t), this._select && this._select.writeValue(this._select.value) } _setElementValue(t) { this._renderer.setProperty(this._element.nativeElement, "value", t) } ngOnDestroy() { this._select && (this._select._optionMap.delete(this.id), this._select.writeValue(this._select.value)) } } return t.\u0275fac = function (e) { return new (e || t)(Ur(Ko), Ur(Xo), Ur($g, 9)) }, t.\u0275dir = Kt({ type: t, selectors: [["option"]], inputs: { ngValue: "ngValue", value: "value" } }), t })(); const Wg = { provide: Pf, useExisting: rt(() => Gg), multi: !0 }; function qg(t, e) { return null == t ? `${e}` : ("string" == typeof e && (e = `'${e}'`), e && "object" == typeof e && (e = "Object"), `${t}: ${e}`.slice(0, 50)) } let Gg = (() => { class t extends Tf { constructor() { super(...arguments), this._optionMap = new Map, this._idCounter = 0, this._compareWith = Object.is } set compareWith(t) { this._compareWith = t } writeValue(t) { let e; if (this.value = t, Array.isArray(t)) { const i = t.map(t => this._getOptionId(t)); e = (t, e) => { t._setSelected(i.indexOf(e.toString()) > -1) } } else e = (t, e) => { t._setSelected(!1) }; this._optionMap.forEach(e) } registerOnChange(t) { this.onChange = e => { const i = []; if (void 0 !== e.selectedOptions) { const t = e.selectedOptions; for (let e = 0; e < t.length; e++) { const n = t.item(e), s = this._getOptionValue(n.value); i.push(s) } } else { const t = e.options; for (let e = 0; e < t.length; e++) { const n = t.item(e); if (n.selected) { const t = this._getOptionValue(n.value); i.push(t) } } } this.value = i, t(i) } } _registerOption(t) { const e = (this._idCounter++).toString(); return this._optionMap.set(e, t), e } _getOptionId(t) { for (const e of Array.from(this._optionMap.keys())) if (this._compareWith(this._optionMap.get(e)._value, t)) return e; return null } _getOptionValue(t) { const e = function (t) { return t.split(":")[0] }(t); return this._optionMap.has(e) ? this._optionMap.get(e)._value : t } } return t.\u0275fac = function () { let e; return function (i) { return (e || (e = Hi(t)))(i || t) } }(), t.\u0275dir = Kt({ type: t, selectors: [["select", "multiple", "", "formControlName", ""], ["select", "multiple", "", "formControl", ""], ["select", "multiple", "", "ngModel", ""]], hostBindings: function (t, e) { 1 & t && Jr("change", function (t) { return e.onChange(t.target) })("blur", function () { return e.onTouched() }) }, inputs: { compareWith: "compareWith" }, features: [zo([Wg]), Ar] }), t })(), Zg = (() => { class t { constructor(t, e, i) { this._element = t, this._renderer = e, this._select = i, this._select && (this.id = this._select._registerOption(this)) } set ngValue(t) { null != this._select && (this._value = t, this._setElementValue(qg(this.id, t)), this._select.writeValue(this._select.value)) } set value(t) { this._select ? (this._value = t, this._setElementValue(qg(this.id, t)), this._select.writeValue(this._select.value)) : this._setElementValue(t) } _setElementValue(t) { this._renderer.setProperty(this._element.nativeElement, "value", t) } _setSelected(t) { this._renderer.setProperty(this._element.nativeElement, "selected", t) } ngOnDestroy() { this._select && (this._select._optionMap.delete(this.id), this._select.writeValue(this._select.value)) } } return t.\u0275fac = function (e) { return new (e || t)(Ur(Ko), Ur(Xo), Ur(Gg, 9)) }, t.\u0275dir = Kt({ type: t, selectors: [["option"]], inputs: { ngValue: "ngValue", value: "value" } }), t })(), Kg = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Gt({ type: t }), t.\u0275inj = pt({ imports: [[Lg]] }), t })(), Yg = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Gt({ type: t }), t.\u0275inj = pt({ imports: [Kg] }), t })(), Qg = (() => { class t { static withConfig(e) { return { ngModule: t, providers: [{ provide: Fg, useValue: e.warnOnNgModelWithFormControl }] } } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Gt({ type: t }), t.\u0275inj = pt({ imports: [Kg] }), t })(), Xg = (() => { class t { group(t, e = null) { const i = this._reduceControls(t); let n, s = null, r = null; return null != e && (function (t) { return void 0 !== t.asyncValidators || void 0 !== t.validators || void 0 !== t.updateOn }(e) ? (s = null != e.validators ? e.validators : null, r = null != e.asyncValidators ? e.asyncValidators : null, n = null != e.updateOn ? e.updateOn : void 0) : (s = null != e.validator ? e.validator : null, r = null != e.asyncValidator ? e.asyncValidator : null)), new Eg(i, { asyncValidators: r, updateOn: n, validators: s }) } control(t, e, i) { return new Cg(t, e, i) } array(t, e, i) { const n = t.map(t => this._createControl(t)); return new Tg(n, e, i) } _reduceControls(t) { const e = {}; return Object.keys(t).forEach(i => { e[i] = this._createControl(t[i]) }), e } _createControl(t) { return t instanceof Cg || t instanceof Eg || t instanceof Tg ? t : Array.isArray(t) ? this.control(t[0], t.length > 1 ? t[1] : null, t.length > 2 ? t[2] : null) : this.control(t) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = dt({ factory: function () { return new t }, token: t, providedIn: Qg }), t })(), Jg = (() => { class t { constructor(t, e) { this.tokenService = t, this.router = e } ngOnInit() { } logOut() { this.tokenService.signOut(), this.tokenService.remove(), this.router.navigate(["/"]) } } return t.\u0275fac = function (e) { return new (e || t)(Ur(kf), Ur(Xp)) }, t.\u0275cmp = $t({ type: t, selectors: [["app-home"]], decls: 131, vars: 0, consts: [[1, "wrapper"], [1, "iq-sidebar", "sidebar-default"], [1, "iq-sidebar-logo", "d-flex", "align-items-center"], ["href", "backend/index.html", 1, "header-logo"], ["src", "assets/images/logo.svg", "alt", "logo"], [1, "logo-title", "light-logo"], [1, "iq-menu-bt-sidebar", "ml-0"], [1, "las", "la-bars", "wrapper-menu"], ["data-scroll", "1", 1, "data-scrollbar"], [1, "iq-sidebar-menu"], ["id", "iq-sidebar-toggle", 1, "iq-menu"], [1, "active"], ["routerLink", "/homeAdmin/DashbordAdmin", 1, "svg-icon"], ["width", "25", "height", "25", "xmlns", "http://www.w3.org/2000/svg", "viewBox", "0 0 24 24", "fill", "none", "stroke", "currentColor", "stroke-width", "2", "stroke-linecap", "round", "stroke-linejoin", "round", 1, "svg-icon"], ["d", "M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"], ["points", "9 22 9 12 15 12 15 22"], [1, "ml-4"], [1, ""], ["routerLink", "/homeAdmin/employees", 1, "svg-icon"], ["d", "M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"], ["x", "8", "y", "2", "width", "8", "height", "4", "rx", "1", "ry", "1"], ["routerLink", "/homeAdmin/listProjet", 1, "svg-icon"], ["points", "6 9 6 2 18 2 18 9"], ["d", "M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"], ["x", "6", "y", "14", "width", "12", "height", "8"], ["routerLink", "/homeAdmin/listTasks", 1, "svg-icon"], ["routerLink", "/homeAdmin/listTasksHidenForAdmin", 1, "svg-icon"], [1, "fas", "fa-trash", 2, "font-size", "20px", "margin-left", "5px"], [1, "pt-5", "pb-2"], [1, "iq-top-navbar"], [1, "iq-navbar-custom"], [1, "navbar", "navbar-expand-lg", "navbar-light", "p-0"], [1, "iq-navbar-logo", "d-flex", "align-items-center", "justify-content-between"], [1, "ri-menu-line", "wrapper-menu"], [1, "logo-title", "text-uppercase"], [1, "navbar-breadcrumb"], [1, "d-flex", "align-items-center"], ["type", "button", "data-toggle", "collapse", "data-target", "#navbarSupportedContent", "aria-controls", "navbarSupportedContent", "aria-label", "Toggle navigation", 1, "navbar-toggler"], [1, "ri-menu-3-line"], ["id", "navbarSupportedContent", 1, "collapse", "navbar-collapse"], [1, "navbar-nav", "ml-auto", "navbar-list", "align-items-center"], [1, "iq-search-bar", "device-search"], ["action", "#", 1, "searchbox"], ["href", "#", 1, "search-link"], [1, "ri-search-line"], ["type", "text", "placeholder", "Search here...", 1, "text", "search-input"], [1, "nav-item", "nav-icon", "search-content"], ["href", "#", "id", "dropdownSearch", "data-toggle", "dropdown", "aria-haspopup", "true", "aria-expanded", "false", 1, "search-toggle", "rounded"], ["aria-labelledby", "dropdownSearch", 1, "iq-search-bar", "iq-sub-dropdown", "dropdown-menu"], ["action", "#", 1, "searchbox", "p-2"], [1, "form-group", "mb-0", "position-relative"], ["type", "text", "placeholder", "type here to search...", 1, "text", "search-input", "font-size-12"], [1, "las", "la-search"], [1, "nav-item", "nav-icon", "dropdown", "caption-content"], ["href", "#", "id", "dropdownMenuButton4", "data-toggle", "dropdown", "aria-haspopup", "true", "aria-expanded", "false", 1, "search-toggle", "dropdown-toggle", "d-flex", "align-items-center"], ["src", "assets/images/user/1.jpg", "alt", "user", 1, "img-fluid", "rounded-circle"], [1, "caption", "ml-3"], [1, "mb-0", "line-height"], [1, "las", "la-angle-down", "ml-2"], ["aria-labelledby", "dropdownMenuButton", 1, "dropdown-menu", "dropdown-menu-right", "border-none"], [1, "dropdown-item", "d-flex", "svg-icon"], ["id", "h-01-p", "width", "20", "xmlns", "http://www.w3.org/2000/svg", "fill", "none", "viewBox", "0 0 24 24", "stroke", "currentColor", 1, "svg-icon", "mr-0", "text-primary"], ["stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "2", "d", "M5.121 17.804A13.937 13.937 0 0112 16c2.5 0 4.847.655 6.879 1.804M15 10a3 3 0 11-6 0 3 3 0 016 0zm6 2a9 9 0 11-18 0 9 9 0 0118 0z"], ["href", "../app/user-profile.html"], ["id", "h-02-p", "width", "20", "xmlns", "http://www.w3.org/2000/svg", "fill", "none", "viewBox", "0 0 24 24", "stroke", "currentColor", 1, "svg-icon", "mr-0", "text-primary"], ["stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "2", "d", "M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"], ["href", "../app/user-profile-edit.html"], ["id", "h-03-p", "width", "20", "xmlns", "http://www.w3.org/2000/svg", "fill", "none", "viewBox", "0 0 24 24", "stroke", "currentColor", 1, "svg-icon", "mr-0", "text-primary"], ["stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "2", "d", "M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"], ["stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "2", "d", "M15 12a3 3 0 11-6 0 3 3 0 016 0z"], ["href", "../app/user-account-setting.html"], ["id", "h-04-p", "width", "20", "xmlns", "http://www.w3.org/2000/svg", "fill", "none", "viewBox", "0 0 24 24", "stroke", "currentColor", 1, "svg-icon", "mr-0", "text-primary"], ["stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "2", "d", "M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z"], ["href", "../app/user-privacy-setting.html"], [1, "dropdown-item", "d-flex", "svg-icon", "border-top"], ["id", "h-05-p", "width", "20", "xmlns", "http://www.w3.org/2000/svg", "fill", "none", "viewBox", "0 0 24 24", "stroke", "currentColor", 1, "svg-icon", "mr-0", "text-primary"], ["stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "2", "d", "M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1"], [3, "click"], [1, "content-page"], [1, "container-fluid"], [1, "row"], [1, "col-lg-12"], [1, "card-transparent", "mb-0"], [1, "card-header", "d-flex", "align-items-center", "justify-content-between", "p-0", "pb-3"], [1, "card-header-toolbar", "d-flex", "align-items-center"], ["id", "top-project-slick-arrow", 1, "slick-aerrow-block"], [1, "card-body", "p-0"], [1, "iq-footer"], [1, "col-lg-6", "text-end"], [1, "mr-1"], ["href", "https://www.linkedin.com/in/farah-dridi-it-engineer/", 1, ""]], template: function (t, e) { 1 & t && (Gr(0, "div", 0), Gr(1, "div", 1), Gr(2, "div", 2), Gr(3, "a", 3), Kr(4, "img", 4), Gr(5, "h4", 5), xo(6, "Task Management"), Zr(), Zr(), Gr(7, "div", 6), Kr(8, "i", 7), Zr(), Zr(), Gr(9, "div", 8), Gr(10, "nav", 9), Gr(11, "ul", 10), Gr(12, "li", 11), Gr(13, "a", 12), si(), Gr(14, "svg", 13), Kr(15, "path", 14), Kr(16, "polyline", 15), Zr(), ri(), Gr(17, "span", 16), xo(18, "Dashboards"), Zr(), Zr(), Zr(), Gr(19, "li", 17), Gr(20, "a", 18), si(), Gr(21, "svg", 13), Kr(22, "path", 19), Kr(23, "rect", 20), Zr(), ri(), Gr(24, "span", 16), xo(25, "Employees"), Zr(), Zr(), Zr(), Gr(26, "li", 17), Gr(27, "a", 21), si(), Gr(28, "svg", 13), Kr(29, "polyline", 22), Kr(30, "path", 23), Kr(31, "rect", 24), Zr(), ri(), Gr(32, "span", 16), xo(33, "Projects"), Zr(), Zr(), Zr(), Gr(34, "li", 17), Gr(35, "a", 25), si(), Gr(36, "svg", 13), Kr(37, "path", 19), Kr(38, "rect", 20), Zr(), ri(), Gr(39, "span", 16), xo(40, "All Tasks"), Zr(), Zr(), Zr(), Gr(41, "li", 17), Gr(42, "a", 26), Kr(43, "i", 27), Gr(44, "span", 16), xo(45, "Trash"), Zr(), Zr(), Zr(), Zr(), Zr(), Kr(46, "div", 28), Zr(), Zr(), Gr(47, "div", 29), Gr(48, "div", 30), Gr(49, "nav", 31), Gr(50, "div", 32), Kr(51, "i", 33), Gr(52, "a", 3), Gr(53, "h4", 34), xo(54, "Gestion des T\xe2ches"), Zr(), Zr(), Zr(), Kr(55, "div", 35), Gr(56, "div", 36), Gr(57, "button", 37), Kr(58, "i", 38), Zr(), Gr(59, "div", 39), Gr(60, "ul", 40), Gr(61, "li"), Gr(62, "div", 41), Gr(63, "form", 42), Gr(64, "a", 43), Kr(65, "i", 44), Zr(), Kr(66, "input", 45), Zr(), Zr(), Zr(), Gr(67, "li", 46), Gr(68, "a", 47), Kr(69, "i", 44), Zr(), Gr(70, "div", 48), Gr(71, "form", 49), Gr(72, "div", 50), Kr(73, "input", 51), Gr(74, "a", 43), Kr(75, "i", 52), Zr(), Zr(), Zr(), Zr(), Zr(), Gr(76, "li", 53), Gr(77, "a", 54), Kr(78, "img", 55), Gr(79, "div", 56), Gr(80, "h6", 57), xo(81, "Test Spring Boot"), Kr(82, "i", 58), Zr(), Zr(), Zr(), Gr(83, "ul", 59), Gr(84, "li", 60), si(), Gr(85, "svg", 61), Kr(86, "path", 62), Zr(), ri(), Gr(87, "a", 63), xo(88, "My Profile"), Zr(), Zr(), Gr(89, "li", 60), si(), Gr(90, "svg", 64), Kr(91, "path", 65), Zr(), ri(), Gr(92, "a", 66), xo(93, "Edit Profile"), Zr(), Zr(), Gr(94, "li", 60), si(), Gr(95, "svg", 67), Kr(96, "path", 68), Kr(97, "path", 69), Zr(), ri(), Gr(98, "a", 70), xo(99, "Account Settings"), Zr(), Zr(), Gr(100, "li", 60), si(), Gr(101, "svg", 71), Kr(102, "path", 72), Zr(), ri(), Gr(103, "a", 73), xo(104, "Privacy Settings"), Zr(), Zr(), Gr(105, "li", 74), si(), Gr(106, "svg", 75), Kr(107, "path", 76), Zr(), ri(), Gr(108, "a", 77), Jr("click", function () { return e.logOut() }), xo(109, "Logout"), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Gr(110, "div", 78), Gr(111, "div", 79), Gr(112, "div", 80), Gr(113, "div", 81), Gr(114, "div", 82), Gr(115, "div", 83), Gr(116, "div", 84), Kr(117, "div", 85), Zr(), Zr(), Gr(118, "div", 86), Kr(119, "router-outlet"), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Gr(120, "footer", 87), Gr(121, "div", 79), Gr(122, "div", 80), Gr(123, "div", 88), Gr(124, "span", 89), xo(125, "\xa9"), Zr(), Gr(126, "a", 90), xo(127, "Dridi Farah"), Zr(), xo(128, " & "), Gr(129, "a", 91), xo(130, "Dridi Farah"), Zr(), Zr(), Zr(), Zr(), Zr()) }, directives: [Jp, Ig, ig, Ag, ef], styles: [""] }), t })(); class tm { } let em = (() => { class t { constructor(t, e, i, n) { this.fb = t, this.fbAddProject = e, this.fbAddTask = i, this.fbAddEmp = n, this.formGroupLogin = this.fb.group({ username: ["", Nf.required], password: ["", Nf.required] }), this.formGroupAddProject = this.fbAddProject.group({ nameP: ["", [Nf.required, Nf.minLength(3), Nf.maxLength(20), Nf.pattern("[a-zA-Z ]*")]], descriptionP: ["", [Nf.required]] }), this.formGroupAddTask = this.fbAddTask.group({ nameT: ["", [Nf.required, Nf.minLength(3), Nf.maxLength(30), Nf.pattern("[a-zA-Z ]*")]], descriptionT: ["", [Nf.required]], dateStartT: [null, Nf.required], dueDateT: [null], statusT: ["", Nf.required], periortyT: [""] }), this.formGroupAddEmp = this.fbAddEmp.group({ nameEmp: ["", [Nf.required, Nf.minLength(3), Nf.maxLength(20), Nf.pattern("[a-zA-Z ]*")]], emailEmp: ["", [Nf.required, Nf.email]], usernameEmp: ["", [Nf.required, Nf.minLength(3), Nf.maxLength(20)]], phoneEmp: ["", [Nf.required, Nf.minLength(8), Nf.maxLength(8), Nf.pattern("[0-9]*")]], passwordEmp: ["", [Nf.required, Nf.minLength(3), Nf.maxLength(20)]] }) } get nameEmp() { return this.formGroupAddEmp.get("nameEmp") } get usernameEmp() { return this.formGroupAddEmp.get("usernameEmp") } get emailEmp() { return this.formGroupAddEmp.get("emailEmp") } get phoneEmp() { return this.formGroupAddEmp.get("phoneEmp") } get passwordEmp() { return this.formGroupAddEmp.get("passwordEmp") } get nameP() { return this.formGroupAddProject.get("nameP") } get descriptionP() { return this.formGroupAddProject.get("descriptionP") } get ownerP() { return this.formGroupAddProject.get("ownerP") } get username() { return this.formGroupLogin.get("username") } get password() { return this.formGroupLogin.get("password") } get nameT() { return this.formGroupAddTask.get("nameT") } get descriptionT() { return this.formGroupAddTask.get("descriptionT") } get dateStartT() { return this.formGroupAddTask.get("dateStartT") } get periortyT() { return this.formGroupAddTask.get("periortyT") } get dueDateT() { return this.formGroupAddTask.get("dueDateT") } get statusT() { return this.formGroupAddTask.get("statusT") } } return t.\u0275fac = function (e) { return new (e || t)(hn(Xg), hn(Xg), hn(Xg), hn(Xg)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(); class im { } class nm { } class sm { constructor(t) { this.normalizedNames = new Map, this.lazyUpdate = null, t ? this.lazyInit = "string" == typeof t ? () => { this.headers = new Map, t.split("\n").forEach(t => { const e = t.indexOf(":"); if (e > 0) { const i = t.slice(0, e), n = i.toLowerCase(), s = t.slice(e + 1).trim(); this.maybeSetNormalizedName(i, n), this.headers.has(n) ? this.headers.get(n).push(s) : this.headers.set(n, [s]) } }) } : () => { this.headers = new Map, Object.keys(t).forEach(e => { let i = t[e]; const n = e.toLowerCase(); "string" == typeof i && (i = [i]), i.length > 0 && (this.headers.set(n, i), this.maybeSetNormalizedName(e, n)) }) } : this.headers = new Map } has(t) { return this.init(), this.headers.has(t.toLowerCase()) } get(t) { this.init(); const e = this.headers.get(t.toLowerCase()); return e && e.length > 0 ? e[0] : null } keys() { return this.init(), Array.from(this.normalizedNames.values()) } getAll(t) { return this.init(), this.headers.get(t.toLowerCase()) || null } append(t, e) { return this.clone({ name: t, value: e, op: "a" }) } set(t, e) { return this.clone({ name: t, value: e, op: "s" }) } delete(t, e) { return this.clone({ name: t, value: e, op: "d" }) } maybeSetNormalizedName(t, e) { this.normalizedNames.has(e) || this.normalizedNames.set(e, t) } init() { this.lazyInit && (this.lazyInit instanceof sm ? this.copyFrom(this.lazyInit) : this.lazyInit(), this.lazyInit = null, this.lazyUpdate && (this.lazyUpdate.forEach(t => this.applyUpdate(t)), this.lazyUpdate = null)) } copyFrom(t) { t.init(), Array.from(t.headers.keys()).forEach(e => { this.headers.set(e, t.headers.get(e)), this.normalizedNames.set(e, t.normalizedNames.get(e)) }) } clone(t) { const e = new sm; return e.lazyInit = this.lazyInit && this.lazyInit instanceof sm ? this.lazyInit : this, e.lazyUpdate = (this.lazyUpdate || []).concat([t]), e } applyUpdate(t) { const e = t.name.toLowerCase(); switch (t.op) { case "a": case "s": let i = t.value; if ("string" == typeof i && (i = [i]), 0 === i.length) return; this.maybeSetNormalizedName(t.name, e); const n = ("a" === t.op ? this.headers.get(e) : void 0) || []; n.push(...i), this.headers.set(e, n); break; case "d": const s = t.value; if (s) { let t = this.headers.get(e); if (!t) return; t = t.filter(t => -1 === s.indexOf(t)), 0 === t.length ? (this.headers.delete(e), this.normalizedNames.delete(e)) : this.headers.set(e, t) } else this.headers.delete(e), this.normalizedNames.delete(e) } } forEach(t) { this.init(), Array.from(this.normalizedNames.keys()).forEach(e => t(this.normalizedNames.get(e), this.headers.get(e))) } } class rm { encodeKey(t) { return om(t) } encodeValue(t) { return om(t) } decodeKey(t) { return decodeURIComponent(t) } decodeValue(t) { return decodeURIComponent(t) } } function om(t) { return encodeURIComponent(t).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/gi, "$").replace(/%2C/gi, ",").replace(/%3B/gi, ";").replace(/%2B/gi, "+").replace(/%3D/gi, "=").replace(/%3F/gi, "?").replace(/%2F/gi, "/") } function am(t) { return `${t}` } class lm { constructor(t = {}) { if (this.updates = null, this.cloneFrom = null, this.encoder = t.encoder || new rm, t.fromString) { if (t.fromObject) throw new Error("Cannot specify both fromString and fromObject."); this.map = function (t, e) { const i = new Map; return t.length > 0 && t.replace(/^\?/, "").split("&").forEach(t => { const n = t.indexOf("="), [s, r] = -1 == n ? [e.decodeKey(t), ""] : [e.decodeKey(t.slice(0, n)), e.decodeValue(t.slice(n + 1))], o = i.get(s) || []; o.push(r), i.set(s, o) }), i }(t.fromString, this.encoder) } else t.fromObject ? (this.map = new Map, Object.keys(t.fromObject).forEach(e => { const i = t.fromObject[e]; this.map.set(e, Array.isArray(i) ? i : [i]) })) : this.map = null } has(t) { return this.init(), this.map.has(t) } get(t) { this.init(); const e = this.map.get(t); return e ? e[0] : null } getAll(t) { return this.init(), this.map.get(t) || null } keys() { return this.init(), Array.from(this.map.keys()) } append(t, e) { return this.clone({ param: t, value: e, op: "a" }) } appendAll(t) { const e = []; return Object.keys(t).forEach(i => { const n = t[i]; Array.isArray(n) ? n.forEach(t => { e.push({ param: i, value: t, op: "a" }) }) : e.push({ param: i, value: n, op: "a" }) }), this.clone(e) } set(t, e) { return this.clone({ param: t, value: e, op: "s" }) } delete(t, e) { return this.clone({ param: t, value: e, op: "d" }) } toString() { return this.init(), this.keys().map(t => { const e = this.encoder.encodeKey(t); return this.map.get(t).map(t => e + "=" + this.encoder.encodeValue(t)).join("&") }).filter(t => "" !== t).join("&") } clone(t) { const e = new lm({ encoder: this.encoder }); return e.cloneFrom = this.cloneFrom || this, e.updates = (this.updates || []).concat(t), e } init() { null === this.map && (this.map = new Map), null !== this.cloneFrom && (this.cloneFrom.init(), this.cloneFrom.keys().forEach(t => this.map.set(t, this.cloneFrom.map.get(t))), this.updates.forEach(t => { switch (t.op) { case "a": case "s": const e = ("a" === t.op ? this.map.get(t.param) : void 0) || []; e.push(am(t.value)), this.map.set(t.param, e); break; case "d": if (void 0 === t.value) { this.map.delete(t.param); break } { let e = this.map.get(t.param) || []; const i = e.indexOf(am(t.value)); -1 !== i && e.splice(i, 1), e.length > 0 ? this.map.set(t.param, e) : this.map.delete(t.param) } } }), this.cloneFrom = this.updates = null) } } class cm { constructor() { this.map = new Map } set(t, e) { return this.map.set(t, e), this } get(t) { return this.map.has(t) || this.map.set(t, t.defaultValue()), this.map.get(t) } delete(t) { return this.map.delete(t), this } keys() { return this.map.keys() } } function hm(t) { return "undefined" != typeof ArrayBuffer && t instanceof ArrayBuffer } function um(t) { return "undefined" != typeof Blob && t instanceof Blob } function dm(t) { return "undefined" != typeof FormData && t instanceof FormData } class pm { constructor(t, e, i, n) { let s; if (this.url = e, this.body = null, this.reportProgress = !1, this.withCredentials = !1, this.responseType = "json", this.method = t.toUpperCase(), function (t) { switch (t) { case "DELETE": case "GET": case "HEAD": case "OPTIONS": case "JSONP": return !1; default: return !0 } }(this.method) || n ? (this.body = void 0 !== i ? i : null, s = n) : s = i, s && (this.reportProgress = !!s.reportProgress, this.withCredentials = !!s.withCredentials, s.responseType && (this.responseType = s.responseType), s.headers && (this.headers = s.headers), s.context && (this.context = s.context), s.params && (this.params = s.params)), this.headers || (this.headers = new sm), this.context || (this.context = new cm), this.params) { const t = this.params.toString(); if (0 === t.length) this.urlWithParams = e; else { const i = e.indexOf("?"); this.urlWithParams = e + (-1 === i ? "?" : i < e.length - 1 ? "&" : "") + t } } else this.params = new lm, this.urlWithParams = e } serializeBody() { return null === this.body ? null : hm(this.body) || um(this.body) || dm(this.body) || "string" == typeof this.body ? this.body : this.body instanceof lm ? this.body.toString() : "object" == typeof this.body || "boolean" == typeof this.body || Array.isArray(this.body) ? JSON.stringify(this.body) : this.body.toString() } detectContentTypeHeader() { return null === this.body || dm(this.body) ? null : um(this.body) ? this.body.type || null : hm(this.body) ? null : "string" == typeof this.body ? "text/plain" : this.body instanceof lm ? "application/x-www-form-urlencoded;charset=UTF-8" : "object" == typeof this.body || "number" == typeof this.body || "boolean" == typeof this.body ? "application/json" : null } clone(t = {}) { var e; const i = t.method || this.method, n = t.url || this.url, s = t.responseType || this.responseType, r = void 0 !== t.body ? t.body : this.body, o = void 0 !== t.withCredentials ? t.withCredentials : this.withCredentials, a = void 0 !== t.reportProgress ? t.reportProgress : this.reportProgress; let l = t.headers || this.headers, c = t.params || this.params; const h = null !== (e = t.context) && void 0 !== e ? e : this.context; return void 0 !== t.setHeaders && (l = Object.keys(t.setHeaders).reduce((e, i) => e.set(i, t.setHeaders[i]), l)), t.setParams && (c = Object.keys(t.setParams).reduce((e, i) => e.set(i, t.setParams[i]), c)), new pm(i, n, r, { params: c, headers: l, context: h, reportProgress: a, responseType: s, withCredentials: o }) } } var fm = function (t) { return t[t.Sent = 0] = "Sent", t[t.UploadProgress = 1] = "UploadProgress", t[t.ResponseHeader = 2] = "ResponseHeader", t[t.DownloadProgress = 3] = "DownloadProgress", t[t.Response = 4] = "Response", t[t.User = 5] = "User", t }({}); class gm { constructor(t, e = 200, i = "OK") { this.headers = t.headers || new sm, this.status = void 0 !== t.status ? t.status : e, this.statusText = t.statusText || i, this.url = t.url || null, this.ok = this.status >= 200 && this.status < 300 } } class mm extends gm { constructor(t = {}) { super(t), this.type = fm.ResponseHeader } clone(t = {}) { return new mm({ headers: t.headers || this.headers, status: void 0 !== t.status ? t.status : this.status, statusText: t.statusText || this.statusText, url: t.url || this.url || void 0 }) } } class _m extends gm { constructor(t = {}) { super(t), this.type = fm.Response, this.body = void 0 !== t.body ? t.body : null } clone(t = {}) { return new _m({ body: void 0 !== t.body ? t.body : this.body, headers: t.headers || this.headers, status: void 0 !== t.status ? t.status : this.status, statusText: t.statusText || this.statusText, url: t.url || this.url || void 0 }) } } class vm extends gm { constructor(t) { super(t, 0, "Unknown Error"), this.name = "HttpErrorResponse", this.ok = !1, this.message = this.status >= 200 && this.status < 300 ? `Http failure during parsing for ${t.url || "(unknown url)"}` : `Http failure response for ${t.url || "(unknown url)"}: ${t.status} ${t.statusText}`, this.error = t.error || null } } function ym(t, e) { return { body: e, headers: t.headers, context: t.context, observe: t.observe, params: t.params, reportProgress: t.reportProgress, responseType: t.responseType, withCredentials: t.withCredentials } } let bm = (() => { class t { constructor(t) { this.handler = t } request(t, e, i = {}) { let n; if (t instanceof pm) n = t; else { let s, r; s = i.headers instanceof sm ? i.headers : new sm(i.headers), i.params && (r = i.params instanceof lm ? i.params : new lm({ fromObject: i.params })), n = new pm(t, e, void 0 !== i.body ? i.body : null, { headers: s, context: i.context, params: r, reportProgress: i.reportProgress, responseType: i.responseType || "json", withCredentials: i.withCredentials }) } const s = Dh(n).pipe(ru(t => this.handler.handle(t))); if (t instanceof pm || "events" === i.observe) return s; const r = s.pipe(Jh(t => t instanceof _m)); switch (i.observe || "body") { case "body": switch (n.responseType) { case "arraybuffer": return r.pipe(E(t => { if (null !== t.body && !(t.body instanceof ArrayBuffer)) throw new Error("Response is not an ArrayBuffer."); return t.body })); case "blob": return r.pipe(E(t => { if (null !== t.body && !(t.body instanceof Blob)) throw new Error("Response is not a Blob."); return t.body })); case "text": return r.pipe(E(t => { if (null !== t.body && "string" != typeof t.body) throw new Error("Response is not a string."); return t.body })); case "json": default: return r.pipe(E(t => t.body)) }case "response": return r; default: throw new Error(`Unreachable: unhandled observe type ${i.observe}}`) } } delete(t, e = {}) { return this.request("DELETE", t, e) } get(t, e = {}) { return this.request("GET", t, e) } head(t, e = {}) { return this.request("HEAD", t, e) } jsonp(t, e) { return this.request("JSONP", t, { params: (new lm).append(e, "JSONP_CALLBACK"), observe: "body", responseType: "json" }) } options(t, e = {}) { return this.request("OPTIONS", t, e) } patch(t, e, i = {}) { return this.request("PATCH", t, ym(i, e)) } post(t, e, i = {}) { return this.request("POST", t, ym(i, e)) } put(t, e, i = {}) { return this.request("PUT", t, ym(i, e)) } } return t.\u0275fac = function (e) { return new (e || t)(hn(im)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); class wm { constructor(t, e) { this.next = t, this.interceptor = e } handle(t) { return this.interceptor.intercept(t, this.next) } } const xm = new Wi("HTTP_INTERCEPTORS"); let Sm = (() => { class t { intercept(t, e) { return e.handle(t) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); const km = /^\)\]\}',?\n/; let Cm = (() => { class t { constructor(t) { this.xhrFactory = t } handle(t) { if ("JSONP" === t.method) throw new Error("Attempted to construct Jsonp request without HttpClientJsonpModule installed."); return new v(e => { const i = this.xhrFactory.build(); if (i.open(t.method, t.urlWithParams), t.withCredentials && (i.withCredentials = !0), t.headers.forEach((t, e) => i.setRequestHeader(t, e.join(","))), t.headers.has("Accept") || i.setRequestHeader("Accept", "application/json, text/plain, */*"), !t.headers.has("Content-Type")) { const e = t.detectContentTypeHeader(); null !== e && i.setRequestHeader("Content-Type", e) } if (t.responseType) { const e = t.responseType.toLowerCase(); i.responseType = "json" !== e ? e : "text" } const n = t.serializeBody(); let s = null; const r = () => { if (null !== s) return s; const e = 1223 === i.status ? 204 : i.status, n = i.statusText || "OK", r = new sm(i.getAllResponseHeaders()), o = function (t) { return "responseURL" in t && t.responseURL ? t.responseURL : /^X-Request-URL:/m.test(t.getAllResponseHeaders()) ? t.getResponseHeader("X-Request-URL") : null }(i) || t.url; return s = new mm({ headers: r, status: e, statusText: n, url: o }), s }, o = () => { let { headers: n, status: s, statusText: o, url: a } = r(), l = null; 204 !== s && (l = void 0 === i.response ? i.responseText : i.response), 0 === s && (s = l ? 200 : 0); let c = s >= 200 && s < 300; if ("json" === t.responseType && "string" == typeof l) { const t = l; l = l.replace(km, ""); try { l = "" !== l ? JSON.parse(l) : null } catch (h) { l = t, c && (c = !1, l = { error: h, text: l }) } } c ? (e.next(new _m({ body: l, headers: n, status: s, statusText: o, url: a || void 0 })), e.complete()) : e.error(new vm({ error: l, headers: n, status: s, statusText: o, url: a || void 0 })) }, a = t => { const { url: n } = r(), s = new vm({ error: t, status: i.status || 0, statusText: i.statusText || "Unknown Error", url: n || void 0 }); e.error(s) }; let l = !1; const c = n => { l || (e.next(r()), l = !0); let s = { type: fm.DownloadProgress, loaded: n.loaded }; n.lengthComputable && (s.total = n.total), "text" === t.responseType && i.responseText && (s.partialText = i.responseText), e.next(s) }, h = t => { let i = { type: fm.UploadProgress, loaded: t.loaded }; t.lengthComputable && (i.total = t.total), e.next(i) }; return i.addEventListener("load", o), i.addEventListener("error", a), i.addEventListener("timeout", a), i.addEventListener("abort", a), t.reportProgress && (i.addEventListener("progress", c), null !== n && i.upload && i.upload.addEventListener("progress", h)), i.send(n), e.next({ type: fm.Sent }), () => { i.removeEventListener("error", a), i.removeEventListener("abort", a), i.removeEventListener("load", o), i.removeEventListener("timeout", a), t.reportProgress && (i.removeEventListener("progress", c), null !== n && i.upload && i.upload.removeEventListener("progress", h)), i.readyState !== i.DONE && i.abort() } }) } } return t.\u0275fac = function (e) { return new (e || t)(hn(Xc)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); const Em = new Wi("XSRF_COOKIE_NAME"), Tm = new Wi("XSRF_HEADER_NAME"); class Pm { } let Dm = (() => { class t { constructor(t, e, i) { this.doc = t, this.platform = e, this.cookieName = i, this.lastCookieString = "", this.lastToken = null, this.parseCount = 0 } getToken() { if ("server" === this.platform) return null; const t = this.doc.cookie || ""; return t !== this.lastCookieString && (this.parseCount++, this.lastToken = Vc(t, this.cookieName), this.lastCookieString = t), this.lastToken } } return t.\u0275fac = function (e) { return new (e || t)(hn(vc), hn(kl), hn(Em)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), Am = (() => { class t { constructor(t, e) { this.tokenService = t, this.headerName = e } intercept(t, e) { const i = t.url.toLowerCase(); if ("GET" === t.method || "HEAD" === t.method || i.startsWith("http://") || i.startsWith("https://")) return e.handle(t); const n = this.tokenService.getToken(); return null === n || t.headers.has(this.headerName) || (t = t.clone({ headers: t.headers.set(this.headerName, n) })), e.handle(t) } } return t.\u0275fac = function (e) { return new (e || t)(hn(Pm), hn(Tm)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), Om = (() => { class t { constructor(t, e) { this.backend = t, this.injector = e, this.chain = null } handle(t) { if (null === this.chain) { const t = this.injector.get(xm, []); this.chain = t.reduceRight((t, e) => new wm(t, e), this.backend) } return this.chain.handle(t) } } return t.\u0275fac = function (e) { return new (e || t)(hn(nm), hn(Pr)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), Rm = (() => { class t { static disable() { return { ngModule: t, providers: [{ provide: Am, useClass: Sm }] } } static withOptions(e = {}) { return { ngModule: t, providers: [e.cookieName ? { provide: Em, useValue: e.cookieName } : [], e.headerName ? { provide: Tm, useValue: e.headerName } : []] } } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Gt({ type: t }), t.\u0275inj = pt({ providers: [Am, { provide: xm, useExisting: Am, multi: !0 }, { provide: Pm, useClass: Dm }, { provide: Em, useValue: "XSRF-TOKEN" }, { provide: Tm, useValue: "X-XSRF-TOKEN" }] }), t })(), Mm = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Gt({ type: t }), t.\u0275inj = pt({ providers: [bm, { provide: im, useClass: Om }, Cm, { provide: nm, useExisting: Cm }], imports: [[Rm.withOptions({ cookieName: "XSRF-TOKEN", headerName: "X-XSRF-TOKEN" })]] }), t })(), Im = (() => { class t { constructor(t) { this.http = t, this.apiUrl = "http://devazure.eastus.cloudapp.azure.com:8085/api/projects" } getProjectList() { return this.http.get(this.apiUrl) } updateProject(t) { return this.http.put(this.apiUrl, t) } deleteProject(t) { return this.http.delete(this.apiUrl + "/" + t) } getProjectById(t) { return this.http.get(this.apiUrl + "/" + t) } addProject(t) { return this.http.post(this.apiUrl, t) } assignTask(t, e) { return this.http.put(this.apiUrl + "/" + t + "/assignTask/" + e, null) } } return t.\u0275fac = function (e) { return new (e || t)(hn(bm)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(); function Lm(t, e) { if (1 & t) { const t = Yr(); Gr(0, "div", 34), Gr(1, "div", 35), Gr(2, "div", 4), Gr(3, "h5", 36), xo(4), Zr(), Gr(5, "p", 37), xo(6), Zr(), Gr(7, "div", 38), Gr(8, "a", 39), Jr("click", function () { const e = Oe(t).$implicit; return so().seeProject(e.id) }), Kr(9, "i", 40), Zr(), Gr(10, "a", 41), Jr("click", function () { const e = Oe(t).$implicit; return so().getProjectById(e.id) }), Kr(11, "i", 42), Zr(), Gr(12, "a", 43), Jr("click", function () { const e = Oe(t).$implicit; return so().getProjectById(e.id) }), Kr(13, "i", 44), Zr(), Zr(), Zr(), Zr(), Zr() } if (2 & t) { const t = e.$implicit; vs(4), So(t.name), vs(2), So(t.description) } } function Fm(t, e) { 1 & t && (Gr(0, "div"), xo(1, " Please enter the title of your project* "), Zr()) } function Nm(t, e) { 1 & t && (Gr(0, "div"), xo(1, " The title of project must be at least 3 characters long "), Zr()) } function jm(t, e) { 1 & t && (Gr(0, "div"), xo(1, " The title of project cannot exceed 50 characters* "), Zr()) } function Vm(t, e) { if (1 & t && (Gr(0, "div", 45), zr(1, Fm, 2, 0, "div", 46), zr(2, Nm, 2, 0, "div", 46), zr(3, jm, 2, 0, "div", 46), Zr()), 2 & t) { const t = so(); vs(1), Wr("ngIf", t.formService.nameP.errors.required), vs(1), Wr("ngIf", t.formService.nameP.errors.minlength), vs(1), Wr("ngIf", t.formService.nameP.errors.maxlength) } } function Bm(t, e) { 1 & t && (Gr(0, "div", 45), xo(1, " The title of project must be a lettre* "), Zr()) } function Hm(t, e) { 1 & t && (Gr(0, "div"), xo(1, " Please enter a description for your project*"), Zr()) } function zm(t, e) { if (1 & t && (Gr(0, "div", 45), zr(1, Hm, 2, 0, "div", 46), Zr()), 2 & t) { const t = so(); vs(1), Wr("ngIf", t.formService.descriptionP.errors.required) } } function $m(t, e) { 1 & t && (Gr(0, "div"), xo(1, " Please enter the title of your project* "), Zr()) } function Um(t, e) { 1 & t && (Gr(0, "div"), xo(1, " The title of project must be at least 3 characters long "), Zr()) } function Wm(t, e) { 1 & t && (Gr(0, "div"), xo(1, " The title of project cannot exceed 50 characters* "), Zr()) } function qm(t, e) { if (1 & t && (Gr(0, "div", 45), zr(1, $m, 2, 0, "div", 46), zr(2, Um, 2, 0, "div", 46), zr(3, Wm, 2, 0, "div", 46), Zr()), 2 & t) { const t = so(); vs(1), Wr("ngIf", t.formService.nameP.errors.required), vs(1), Wr("ngIf", t.formService.nameP.errors.minlength), vs(1), Wr("ngIf", t.formService.nameP.errors.maxlength) } } function Gm(t, e) { 1 & t && (Gr(0, "div", 45), xo(1, " The title of project must be a lettre* "), Zr()) } function Zm(t, e) { 1 & t && (Gr(0, "div"), xo(1, " Please enter a description for your project*"), Zr()) } function Km(t, e) { if (1 & t && (Gr(0, "div", 45), zr(1, Zm, 2, 0, "div", 46), Zr()), 2 & t) { const t = so(); vs(1), Wr("ngIf", t.formService.descriptionP.errors.required) } } const Ym = function (t) { return { "is-invalid": t } }; let Qm = (() => { class t { constructor(t, e, i) { this.router = t, this.formService = e, this.projectService = i, this.project = new tm, this.listProject = [], this.editProject = new tm } ngOnInit() { this.getProjects() } getProjects() { this.projectService.getProjectList().subscribe(t => { this.listProject = t }) } seeProject(t) { console.log("id : ", t), this.router.navigate(["homeAdmin/detailsProject/", t]) } onSubmit() { this.formService.formGroupAddProject.valid ? (console.log("Valid form"), this.project.description = this.formService.formGroupAddProject.value.descriptionP, this.project.name = this.formService.formGroupAddProject.value.nameP, console.log("project : ", this.project), this.projectService.addProject(this.project).subscribe(t => { console.log("data : ", t), this.formService.formGroupAddProject.reset(), this.project = new tm, window.location.reload() }, t => { console.log("error : ", t) })) : (console.log("Invalid form"), console.log(this.formService.formGroupAddProject.controls.validate), this.validateAllFormFields(this.formService.formGroupAddProject)) } validateAllFormFields(t) { Object.keys(t.controls).forEach(e => { const i = t.get(e); i instanceof Cg ? i.markAsTouched({ onlySelf: !0 }) : i instanceof Eg && this.validateAllFormFields(i) }) } onCancel() { this.formService.formGroupAddProject.reset(), this.editProject = new tm, this.project = new tm } deleteProject(t) { this.projectService.deleteProject(t).subscribe(() => { console.log("success delete !"), window.location.reload() }, t => { console.log("error : ", t) }) } getProjectById(t) { this.projectService.getProjectById(t).subscribe(t => { console.log("data : ", t), this.editProject = t, console.log("editProject : ", this.editProject), this.formService.formGroupAddProject.patchValue({ nameP: this.editProject.name, descriptionP: this.editProject.description }) }, t => { console.log("error : ", t) }) } updateProject(t) { this.formService.formGroupAddProject.valid ? (console.log("Valid form"), console.log("form group value : ", this.formService.formGroupAddProject.value), this.editProject.description = this.formService.formGroupAddProject.value.descriptionP, this.editProject.name = this.formService.formGroupAddProject.value.nameP, console.log("project to update : ", this.editProject), this.projectService.updateProject(this.editProject).subscribe(t => { console.log("data api: ", t), this.formService.formGroupAddProject.reset(), window.location.reload() }, t => { console.log("error : ", t) })) : (console.log("Invalid form"), this.validateAllFormFields(this.formService.formGroupAddProject)) } } return t.\u0275fac = function (e) { return new (e || t)(Ur(Xp), Ur(em), Ur(Im)) }, t.\u0275cmp = $t({ type: t, selectors: [["app-listprojet"]], decls: 102, vars: 21, consts: [[1, "container-fluid"], [1, "row"], [1, "col-lg-12"], [1, "card"], [1, "card-body"], [1, "d-flex", "flex-wrap", "align-items-center", "justify-content-between", "breadcrumb-content"], [1, "d-flex", "flex-wrap", "align-items-center", "justify-content-between"], [1, "pl-3", "border-left", "btn-new"], ["href", "#", "data-target", "#new-project-modal", "data-toggle", "modal", 1, "btn", "btn-primary"], ["id", "grid", "data-toggle-extra", "tab-content", "data-test", "project-grid", 1, "item-content", "animate__animated", "animate__fadeIn", "active"], ["class", "col-lg-4 col-md-6", "data-test", "project-card", 4, "ngFor", "ngForOf"], ["role", "dialog", "aria-modal", "true", "id", "new-project-modal", 1, "modal", "fade"], ["role", "document", 1, "modal-dialog", "modal-dialog-centered"], [1, "modal-content"], [1, "modal-header", "d-block", "text-center", "pb-3", "border-bttom"], ["id", "exampleModalCenterTitle01", 1, "modal-title"], [1, "modal-body"], [1, "mb-3", 3, "formGroup"], [1, "form-group", "mb-3"], [1, "h5"], ["type", "text", "formControlName", "nameP", "placeholder", "Project Name", 1, "form-control", 3, "ngClass"], ["class", "invalid-feedback", 4, "ngIf"], ["type", "text", "formControlName", "descriptionP", "placeholder", "Describe your project", "row", "5", 1, "form-control", 3, "ngClass"], ["name", "type", "data-style", "py-0", 1, "selectpicker", "form-control"], [1, "d-flex", "flex-wrap", "align-items-center", "justify-content-center", "mt-2"], ["type", "submit", 1, "btn", "btn-primary", "mr-3", 3, "click"], ["data-dismiss", "modal", 1, "btn", "btn-danger", 3, "click"], ["role", "dialog", "aria-modal", "true", "id", "edit-project-modal", 1, "modal", "fade"], [1, "modal-title"], ["role", "dialog", "aria-modal", "true", "id", "deleteProjet", 1, "modal", "fade", "bd-example-modal-lg"], ["role", "document", 1, "modal-dialog", "modal-dialog-centered", "modal-lg"], [1, "h5", "justify-content-center"], [1, "d-flex", "flex-wrap", "align-items-ceter", "justify-content-center", "mt-2"], ["data-dismiss", "modal", 1, "btn", "btn-primary", "mr-3", 3, "click"], ["data-test", "project-card", 1, "col-lg-4", "col-md-6"], [1, "card", "card-block", "card-stretch", "card-height"], [1, "mb-1"], [1, "mb-3"], [1, "d-flex", "justify-content-end", "pt-3", "border-top"], [1, "btn", "btn-white", "text-primary", "link-shadow", 3, "click"], [1, "fa", "fa-eye"], ["data-target", "#edit-project-modal", "data-toggle", "modal", 1, "btn", "btn-white", "text-warning", "link-shadow", 3, "click"], [1, "fa", "fa-edit"], ["data-target", "#deleteProjet", "data-toggle", "modal", 1, "btn", "btn-white", "text-danger", "link-shadow", 3, "click"], [1, "fa", "fa-trash"], [1, "invalid-feedback"], [4, "ngIf"]], template: function (t, e) { 1 & t && (Gr(0, "div", 0), Gr(1, "div", 1), Gr(2, "div", 2), Gr(3, "div", 3), Gr(4, "div", 4), Gr(5, "div", 5), Gr(6, "h5"), xo(7, "Your Projects"), Zr(), Gr(8, "div", 6), Gr(9, "div", 7), Gr(10, "a", 8), xo(11, "New Project"), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Gr(12, "div", 9), Gr(13, "div", 1), zr(14, Lm, 14, 2, "div", 10), Zr(), Zr(), Zr(), Gr(15, "div", 11), Gr(16, "div", 12), Gr(17, "div", 13), Gr(18, "div", 14), Gr(19, "h3", 15), xo(20, "New Project"), Zr(), Zr(), Gr(21, "div", 16), Gr(22, "form", 17), Gr(23, "div", 1), Gr(24, "div", 2), Gr(25, "div", 18), Gr(26, "label", 19), xo(27, "Project Name"), Zr(), Kr(28, "input", 20), zr(29, Vm, 4, 3, "div", 21), zr(30, Bm, 2, 0, "div", 21), Zr(), Zr(), Gr(31, "div", 2), Gr(32, "div", 18), Gr(33, "label", 19), xo(34, "Description"), Zr(), Gr(35, "textarea", 22), xo(36, "                "), Zr(), zr(37, zm, 2, 1, "div", 21), Zr(), Zr(), Gr(38, "div", 2), Gr(39, "div", 18), Gr(40, "label", 19), xo(41, "Owner "), Zr(), Gr(42, "select", 23), Gr(43, "option"), xo(44, "Owner 1"), Zr(), Gr(45, "option"), xo(46, "Owner 2"), Zr(), Gr(47, "option"), xo(48, "Owner 3"), Zr(), Zr(), Zr(), Zr(), Gr(49, "div", 2), Gr(50, "div", 24), Gr(51, "button", 25), Jr("click", function () { return e.onSubmit() }), xo(52, "Save"), Zr(), Gr(53, "button", 26), Jr("click", function () { return e.onCancel() }), xo(54, "Cancel"), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Gr(55, "div", 27), Gr(56, "div", 12), Gr(57, "div", 13), Gr(58, "div", 14), Gr(59, "h3", 28), xo(60, "Edit Project"), Zr(), Zr(), Gr(61, "div", 16), Gr(62, "form", 17), Gr(63, "div", 1), Gr(64, "div", 2), Gr(65, "div", 18), Gr(66, "label", 19), xo(67, "Project Name"), Zr(), Kr(68, "input", 20), zr(69, qm, 4, 3, "div", 21), zr(70, Gm, 2, 0, "div", 21), Zr(), Zr(), Gr(71, "div", 2), Gr(72, "div", 18), Gr(73, "label", 19), xo(74, "Description"), Zr(), Gr(75, "textarea", 22), xo(76, "                "), Zr(), zr(77, Km, 2, 1, "div", 21), Zr(), Zr(), Gr(78, "div", 2), Gr(79, "div", 24), Gr(80, "button", 25), Jr("click", function () { return e.updateProject(e.editProject.id) }), xo(81, "Save"), Zr(), Gr(82, "button", 26), Jr("click", function () { return e.onCancel() }), xo(83, "Cancel"), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Gr(84, "div", 29), Gr(85, "div", 30), Gr(86, "div", 13), Gr(87, "div", 14), Gr(88, "h3", 28), xo(89, "Delete Project"), Zr(), Zr(), Gr(90, "div", 16), Gr(91, "div", 1), Gr(92, "div", 2), Gr(93, "div", 18), Gr(94, "label", 31), xo(95, "Are you sure you want to delete this project ?"), Zr(), Zr(), Zr(), Gr(96, "div", 2), Gr(97, "div", 32), Gr(98, "div", 33), Jr("click", function () { return e.deleteProject(e.editProject.id) }), xo(99, "Yes"), Zr(), Gr(100, "div", 26), Jr("click", function () { return e.onCancel() }), xo(101, "No"), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr()), 2 & t && (vs(14), Wr("ngForOf", e.listProject), vs(8), Wr("formGroup", e.formService.formGroupAddProject), vs(6), Wr("ngClass", Ka(13, Ym, e.formService.nameP && e.formService.nameP.errors && e.formService.nameP.touched)), vs(1), Wr("ngIf", e.formService.nameP && e.formService.nameP.errors), vs(1), Wr("ngIf", e.formService.nameP && e.formService.nameP.hasError("pattern")), vs(5), Wr("ngClass", Ka(15, Ym, e.formService.descriptionP && e.formService.descriptionP.errors && e.formService.descriptionP.touched)), vs(2), Wr("ngIf", e.formService.descriptionP && e.formService.descriptionP.errors), vs(25), Wr("formGroup", e.formService.formGroupAddProject), vs(6), Wr("ngClass", Ka(17, Ym, e.formService.nameP && e.formService.nameP.errors && e.formService.nameP.touched)), vs(1), Wr("ngIf", e.formService.nameP && e.formService.nameP.errors), vs(1), Wr("ngIf", e.formService.nameP && e.formService.nameP.hasError("pattern")), vs(5), Wr("ngClass", Ka(19, Ym, e.formService.descriptionP && e.formService.descriptionP.errors && e.formService.descriptionP.touched)), vs(2), Wr("ngIf", e.formService.descriptionP && e.formService.descriptionP.errors)) }, directives: [zc, Ig, ig, jg, Of, eg, Bg, Bc, Uc, Ug, Zg], styles: [""] }), t })(), Xm = (() => { class t { constructor(t) { this.http = t, this.apiUrl = "http://devazure.eastus.cloudapp.azure.com:8085/api/tasks" } getAllTasks() { return this.http.get(this.apiUrl) } updateTask(t) { return this.http.put(this.apiUrl, t) } deleteTask(t) { return this.http.delete(this.apiUrl + "/" + t) } addTask(t) { return this.http.post(this.apiUrl, t) } hideTask(t) { return this.http.put(this.apiUrl + "/" + t + "/to-trash", null) } fromTrashToListTask(t) { return this.http.put(this.apiUrl + "/" + t + "/to-list-task", null) } getTasksByProjectId(t) { return this.http.get(this.apiUrl + "/" + t + "/tasks") } taskById(t) { return this.http.get(this.apiUrl + "/" + t) } getTasksWithSearch(t, e, i) { const n = (new lm).set("searchTerm", t).set("page", e.toString()).set("pageSize", i.toString()); return this.http.get(`${this.apiUrl}/search`, { params: n }) } getLabels() { return this.http.get(this.apiUrl + "/labels") } getTaskByStatusAndMemberId(t, e) { return this.http.get(this.apiUrl + "/getByStatusAndMemberId?status=" + t + "&memberId=" + e) } getTaskByLabelId(t) { return this.http.get(this.apiUrl + "/label/" + t + "/tasks") } getFilterTasks(t, e, i, n, s, r, o, a) { return this.http.get(this.apiUrl + "/filter?labelIds=" + t + "&keyword=" + e + "&projectId=" + i + "&completed=" + n + "&minStartDate=" + s + "&maxStartDate=" + r + "&minDueDate=" + o + "&maxDueDate=" + a) } getArchivedTasks() { return this.http.post(this.apiUrl + "/archived", null) } } return t.\u0275fac = function (e) { return new (e || t)(hn(bm)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(); class Jm { constructor(t, e) { this.open = t, this.close = e || t } isManual() { return "manual" === this.open || "manual" === this.close } } const t_ = { hover: ["mouseover", "mouseout"], focus: ["focusin", "focusout"] }, e_ = "undefined" != typeof window && window || {}; let i_; function n_() { return void 0 === e_ || (void 0 === e_.__theme ? (i_ || (i_ = function () { if ("undefined" == typeof document) return "bs4"; const t = document.createElement("span"); t.innerText = "testing bs version", document.body.appendChild(t), t.classList.add("d-none"); const e = t.getBoundingClientRect(); return document.body.removeChild(t), e && 0 === e.top ? "bs4" : "bs3" }()), "bs3" === i_) : "bs4" !== e_.__theme) } function s_(t, e, i, s) { return n(i) && (s = i, i = void 0), s ? s_(t, e, i).pipe(E(t => l(t) ? s(...t) : s(t))) : new v(n => { r_(t, e, function (t) { n.next(arguments.length > 1 ? Array.prototype.slice.call(arguments) : t) }, n, i) }) } function r_(t, e, i, n, s) { let r; if (function (t) { return t && "function" == typeof t.addEventListener && "function" == typeof t.removeEventListener }(t)) { const n = t; t.addEventListener(e, i, s), r = () => n.removeEventListener(e, i, s) } else if (function (t) { return t && "function" == typeof t.on && "function" == typeof t.off }(t)) { const n = t; t.on(e, i), r = () => n.off(e, i) } else if (function (t) { return t && "function" == typeof t.addListener && "function" == typeof t.removeListener }(t)) { const n = t; t.addListener(e, i), r = () => n.removeListener(e, i) } else { if (!t || !t.length) throw new TypeError("Invalid event target"); for (let r = 0, o = t.length; r < o; r++)r_(t[r], e, i, n, s) } n.add(r) } "undefined" == typeof console || console; class o_ extends u { constructor(t, e) { super() } schedule(t, e = 0) { return this } } class a_ extends o_ { constructor(t, e) { super(t, e), this.scheduler = t, this.work = e, this.pending = !1 } schedule(t, e = 0) { if (this.closed) return this; this.state = t; const i = this.id, n = this.scheduler; return null != i && (this.id = this.recycleAsyncId(n, i, e)), this.pending = !0, this.delay = e, this.id = this.id || this.requestAsyncId(n, this.id, e), this } requestAsyncId(t, e, i = 0) { return setInterval(t.flush.bind(t, this), i) } recycleAsyncId(t, e, i = 0) { if (null !== i && this.delay === i && !1 === this.pending) return e; clearInterval(e) } execute(t, e) { if (this.closed) return new Error("executing a cancelled action"); this.pending = !1; const i = this._execute(t, e); if (i) return i; !1 === this.pending && null != this.id && (this.id = this.recycleAsyncId(this.scheduler, this.id, null)) } _execute(t, e) { let i, n = !1; try { this.work(t) } catch (s) { n = !0, i = !!s && s || new Error(s) } if (n) return this.unsubscribe(), i } _unsubscribe() { const t = this.id, e = this.scheduler, i = e.actions, n = i.indexOf(this); this.work = null, this.state = null, this.pending = !1, this.scheduler = null, -1 !== n && i.splice(n, 1), null != t && (this.id = this.recycleAsyncId(e, t, null)), this.delay = null } } class l_ extends a_ { constructor(t, e) { super(t, e), this.scheduler = t, this.work = e } requestAsyncId(t, e, i = 0) { return null !== i && i > 0 ? super.requestAsyncId(t, e, i) : (t.actions.push(this), t.scheduled || (t.scheduled = requestAnimationFrame(() => t.flush(null)))) } recycleAsyncId(t, e, i = 0) { if (null !== i && i > 0 || null === i && this.delay > 0) return super.recycleAsyncId(t, e, i); 0 === t.actions.length && (cancelAnimationFrame(e), t.scheduled = void 0) } } let c_ = (() => { class t { constructor(e, i = t.now) { this.SchedulerAction = e, this.now = i } schedule(t, e = 0, i) { return new this.SchedulerAction(this, t).schedule(i, e) } } return t.now = () => Date.now(), t })(); class h_ extends c_ { constructor(t, e = c_.now) { super(t, () => h_.delegate && h_.delegate !== this ? h_.delegate.now() : e()), this.actions = [], this.active = !1, this.scheduled = void 0 } schedule(t, e = 0, i) { return h_.delegate && h_.delegate !== this ? h_.delegate.schedule(t, e, i) : super.schedule(t, e, i) } flush(t) { const { actions: e } = this; if (this.active) return void e.push(t); let i; this.active = !0; do { if (i = t.execute(t.state, t.delay)) break } while (t = e.shift()); if (this.active = !1, i) { for (; t = e.shift();)t.unsubscribe(); throw i } } } class u_ extends h_ { flush(t) { this.active = !0, this.scheduled = void 0; const { actions: e } = this; let i, n = -1, s = e.length; t = t || e.shift(); do { if (i = t.execute(t.state, t.delay)) break } while (++n < s && (t = e.shift())); if (this.active = !1, i) { for (; ++n < s && (t = e.shift());)t.unsubscribe(); throw i } } } const d_ = new u_(l_); function p_(t, e) { if (1 !== t.nodeType) return []; const i = t.ownerDocument.defaultView, n = null == i ? void 0 : i.getComputedStyle(t, null); return e ? n && n[e] : n } const f_ = "undefined" != typeof window && "undefined" != typeof document, g_ = f_ && !(!window.MSInputMethodContext || !document.documentMode), m_ = f_ && !(!window.MSInputMethodContext || !/MSIE 10/.test(navigator.userAgent)); function __(t) { return 11 === t ? g_ : 10 === t ? m_ : g_ || m_ } function v_(t) { if (!t) return document.documentElement; const e = __(10) ? document.body : null; let i, n = null == t ? void 0 : t.offsetParent; for (; n === e && t.nextElementSibling && i !== t.nextElementSibling;)i = t.nextElementSibling, n = i.offsetParent; const s = n && n.nodeName; return s && "BODY" !== s && "HTML" !== s ? n && -1 !== ["TH", "TD", "TABLE"].indexOf(n.nodeName) && "static" === p_(n, "position") ? v_(n) : n : i ? i.ownerDocument.documentElement : document.documentElement } function y_(t) { return null !== t.parentNode ? y_(t.parentNode) : t } function b_(t, e) { if (!(t && t.nodeType && e && e.nodeType)) return document.documentElement; const i = t.compareDocumentPosition(e) & Node.DOCUMENT_POSITION_FOLLOWING, n = i ? t : e, s = i ? e : t, r = document.createRange(); r.setStart(n, 0), r.setEnd(s, 0); const o = r.commonAncestorContainer; if (t !== o && e !== o || n.contains(s)) return function (t) { const { nodeName: e } = t; return "BODY" !== e && ("HTML" === e || v_(t.firstElementChild) === t) }(o) ? o : v_(o); const a = y_(t); return a.host ? b_(a.host, e) : b_(t, y_(e).host) } function w_(t) { if (!t || !t.parentElement || __()) return document.documentElement; let e = t.parentElement; for (; (null == e ? void 0 : e.parentElement) && "none" === p_(e, "transform");)e = e.parentElement; return e || document.documentElement } function x_(t, e) { const i = "x" === e ? "Left" : "Top", n = "Left" === i ? "Right" : "Bottom"; return parseFloat(t[`border${i}Width`]) + parseFloat(t[`border${n}Width`]) } function S_(t, e, i, n) { const s = i, r = n; return Math.max(e[`offset${t}`], e[`scroll${t}`], s[`client${t}`], s[`offset${t}`], s[`scroll${t}`], __(10) ? parseInt(s[`offset${t}`], 10) + parseInt(r["margin" + ("Height" === t ? "Top" : "Left")], 10) + parseInt(r["margin" + ("Height" === t ? "Bottom" : "Right")], 10) : 0) } function k_(t) { const e = t.body, i = t.documentElement, n = __(10) ? getComputedStyle(i) : void 0; return { height: S_("Height", e, i, n), width: S_("Width", e, i, n) } } function C_(t, e = "top") { const i = "top" === e ? "scrollTop" : "scrollLeft", n = t.nodeName; if ("BODY" === n || "HTML" === n) { const e = t.ownerDocument.documentElement; return (t.ownerDocument.scrollingElement || e)[i] } return t[i] } function E_(t) { return Object.assign(Object.assign({}, t), { right: (t.left || 0) + t.width, bottom: (t.top || 0) + t.height }) } function T_(t) { return "number" == typeof t || "[object Number]" === Object.prototype.toString.call(t) } function P_(t) { const e = t.getBoundingClientRect(); try { if (__(10)) { const i = C_(t, "top"), n = C_(t, "left"); e && T_(e.top) && T_(e.left) && T_(e.bottom) && T_(e.right) && (e.top += i, e.left += n, e.bottom += i, e.right += n) } } catch (l) { return e } if (!(e && T_(e.top) && T_(e.left) && T_(e.bottom) && T_(e.right))) return e; const i = { left: e.left, top: e.top, width: e.right - e.left, height: e.bottom - e.top }, n = "HTML" === t.nodeName ? k_(t.ownerDocument) : void 0, s = (null == n ? void 0 : n.width) || t.clientWidth || T_(i.right) && T_(i.left) && i.right - i.left || 0, r = (null == n ? void 0 : n.height) || t.clientHeight || T_(i.bottom) && T_(i.top) && i.bottom - i.top || 0; let o = t.offsetWidth - s, a = t.offsetHeight - r; if (o || a) { const e = p_(t); o -= x_(e, "x"), a -= x_(e, "y"), i.width -= o, i.height -= a } return E_(i) } function D_(t) { return "HTML" === t.nodeName ? t : t.parentNode || t.host } function A_(t) { if (!t) return document.body; switch (t.nodeName) { case "HTML": case "BODY": return t.ownerDocument.body; case "#document": return t.body }const { overflow: e, overflowX: i, overflowY: n } = p_(t); return /(auto|scroll|overlay)/.test(String(e) + String(n) + String(i)) ? t : A_(D_(t)) } function O_(t, e, i = !1) { var n, s, r, o, a, l; const c = __(10), h = "HTML" === e.nodeName, u = P_(t), d = P_(e), p = A_(t), f = p_(e), g = parseFloat(f.borderTopWidth), m = parseFloat(f.borderLeftWidth); i && h && (d.top = Math.max(null !== (n = d.top) && void 0 !== n ? n : 0, 0), d.left = Math.max(null !== (s = d.left) && void 0 !== s ? s : 0, 0)); let _ = E_({ top: (null !== (r = u.top) && void 0 !== r ? r : 0) - (null !== (o = d.top) && void 0 !== o ? o : 0) - g, left: (null !== (a = u.left) && void 0 !== a ? a : 0) - (null !== (l = d.left) && void 0 !== l ? l : 0) - m, width: u.width, height: u.height }); if (_.marginTop = 0, _.marginLeft = 0, !c && h) { const t = parseFloat(f.marginTop), e = parseFloat(f.marginLeft); T_(_.top) && (_.top -= g - t), T_(_.bottom) && (_.bottom -= g - t), T_(_.left) && (_.left -= m - e), T_(_.right) && (_.right -= m - e), _.marginTop = t, _.marginLeft = e } return (c && !i ? e.contains(p) : e === p && "BODY" !== p.nodeName) && (_ = function (t, e, i = !1) { const n = C_(e, "top"), s = C_(e, "left"), r = i ? -1 : 1; return T_(t.top) && (t.top += n * r), T_(t.bottom) && (t.bottom += n * r), T_(t.left) && (t.left += s * r), T_(t.right) && (t.right += s * r), t }(_, e)), _ } function R_(t) { const e = t.nodeName; return "BODY" !== e && "HTML" !== e && ("fixed" === p_(t, "position") || R_(D_(t))) } function M_(t, e, i = 0, n, s = !1) { let r = { top: 0, left: 0 }; const o = s ? w_(t) : b_(t, e); if ("viewport" === n) r = function (t, e = !1) { const i = t.ownerDocument.documentElement, n = O_(t, i), s = Math.max(i.clientWidth, window.innerWidth || 0), r = Math.max(i.clientHeight, window.innerHeight || 0), o = e ? 0 : C_(i), a = e ? 0 : C_(i, "left"); return E_({ top: o - Number(null == n ? void 0 : n.top) + Number(null == n ? void 0 : n.marginTop), left: a - Number(null == n ? void 0 : n.left) + Number(null == n ? void 0 : n.marginLeft), width: s, height: r }) }(o, s); else { let i; "scrollParent" === n ? (i = A_(D_(e)), "BODY" === i.nodeName && (i = t.ownerDocument.documentElement)) : i = "window" === n ? t.ownerDocument.documentElement : n; const a = O_(i, o, s); if (a && "HTML" === i.nodeName && !R_(o)) { const { height: e, width: i } = k_(t.ownerDocument); T_(r.top) && T_(a.top) && T_(a.marginTop) && (r.top += a.top - a.marginTop), T_(r.top) && (r.bottom = Number(e) + Number(a.top)), T_(r.left) && T_(a.left) && T_(a.marginLeft) && (r.left += a.left - a.marginLeft), T_(r.top) && (r.right = Number(i) + Number(a.left)) } else a && (r = a) } return T_(r.left) && (r.left += i), T_(r.top) && (r.top += i), T_(r.right) && (r.right -= i), T_(r.bottom) && (r.bottom -= i), r } function I_({ width: t, height: e }) { return t * e } function L_(t, e, i, n, s = ["top", "bottom", "right", "left"], r = "viewport", o = 0) { var a, l, c, h; if (-1 === t.indexOf("auto")) return t; const u = M_(i, n, o, r), d = { top: { width: null !== (a = u.width) && void 0 !== a ? a : 0, height: e.top && u.top ? e.top - u.top : 0 }, right: { width: u.right && e.right ? u.right - e.right : 0, height: null !== (l = u.height) && void 0 !== l ? l : 0 }, bottom: { width: null !== (c = u.width) && void 0 !== c ? c : 0, height: u.bottom && e.bottom ? u.bottom - e.bottom : 0 }, left: { width: e.left && u.left ? e.left - u.left : 0, height: null !== (h = u.height) && void 0 !== h ? h : 0 } }, p = Object.keys(d).map(t => Object.assign(Object.assign({ key: t }, d[t]), { area: I_(d[t]) })).sort((t, e) => e.area - t.area); let f = p.filter(({ width: t, height: e }) => t >= i.clientWidth && e >= i.clientHeight); f = f.filter(t => s.some(e => e === t.key)); const g = f.length > 0 ? f[0].key : p[0].key, m = t.split(" ")[1]; return i.className = i.className.replace(/bs-tooltip-auto/g, `bs-tooltip-${g}`), g + (m ? `-${m}` : "") } const F_ = (t, e = 0) => t ? parseFloat(t) : e; function N_(t) { const e = t.ownerDocument.defaultView, i = null == e ? void 0 : e.getComputedStyle(t), n = F_(null == i ? void 0 : i.marginTop) + F_(null == i ? void 0 : i.marginBottom), s = F_(null == i ? void 0 : i.marginLeft) + F_(null == i ? void 0 : i.marginRight); return { width: Number(t.offsetWidth) + s, height: Number(t.offsetHeight) + n } } function j_(t, e, i) { return O_(e, i ? w_(t) : b_(t, e), i) } function V_(t, e, i) { var n, s, r; const o = i.split(" ")[0], a = N_(t), l = { width: a.width, height: a.height }, c = -1 !== ["right", "left"].indexOf(o), h = c ? "top" : "left", u = c ? "left" : "top", d = c ? "height" : "width", p = c ? "width" : "height"; return l[h] = (null !== (n = e[h]) && void 0 !== n ? n : 0) + e[d] / 2 - a[d] / 2, l[u] = o === u ? (null !== (s = e[u]) && void 0 !== s ? s : 0) - a[p] : null !== (r = e[function (t) { const e = { left: "right", right: "left", bottom: "top", top: "bottom" }; return t.replace(/left|right|bottom|top/g, t => e[t]) }(u)]) && void 0 !== r ? r : 0, l } function B_(t, e) { var i; return !!(null === (i = t.modifiers[e]) || void 0 === i ? void 0 : i.enabled) } function H_(t, e, i) { t && e && Object.keys(e).forEach(n => { let s = ""; var r; -1 !== ["width", "height", "top", "right", "bottom", "left"].indexOf(n) && "" !== (r = e[n]) && !isNaN(parseFloat(r)) && isFinite(Number(r)) && (s = "px"), i ? i.setStyle(t, n, `${String(e[n])}${s}`) : t.style[n] = String(e[n]) + s }) } function z_(t) { var e, i, n, s, r, o; let a = t.offsets.target; const l = t.instance.target.querySelector(".arrow"); if (!l) return t; const c = -1 !== ["left", "right"].indexOf(t.placement.split(" ")[0]), h = c ? "height" : "width", u = c ? "Top" : "Left", d = u.toLowerCase(), p = c ? "left" : "top", f = c ? "bottom" : "right", g = N_(l)[h], m = t.placement.split(" ")[1]; (null !== (e = t.offsets.host[f]) && void 0 !== e ? e : 0) - g < (null !== (i = a[d]) && void 0 !== i ? i : 0) && (a[d] -= (null !== (n = a[d]) && void 0 !== n ? n : 0) - ((null !== (s = t.offsets.host[f]) && void 0 !== s ? s : 0) - g)), Number(t.offsets.host[d]) + Number(g) > (null !== (r = a[f]) && void 0 !== r ? r : 0) && (a[d] += Number(t.offsets.host[d]) + Number(g) - Number(a[f])), a = E_(a); const _ = p_(t.instance.target), v = parseFloat(_[`margin${u}`]), y = parseFloat(_[`border${u}Width`]); let b; if (m) { const e = parseFloat(_.borderRadius), i = Number(v + y + e); b = d === m ? Number(t.offsets.host[d]) + i : Number(t.offsets.host[d]) + Number(t.offsets.host[h] - i) } else b = Number(t.offsets.host[d]) + Number(t.offsets.host[h] / 2 - g / 2); let w = b - (null !== (o = a[d]) && void 0 !== o ? o : 0) - v - y; return w = Math.max(Math.min(a[h] - g, w), 0), t.offsets.arrow = { [d]: Math.round(w), [p]: "" }, t.instance.arrow = l, t } function $_(t) { if (t.offsets.target = E_(t.offsets.target), !B_(t.options, "flip")) return t.offsets.target = Object.assign(Object.assign({}, t.offsets.target), V_(t.instance.target, t.offsets.host, t.placement)), t; const e = M_(t.instance.target, t.instance.host, 0, "viewport", !1); let i = t.placement.split(" ")[0], n = t.placement.split(" ")[1] || ""; const s = L_("auto", t.offsets.host, t.instance.target, t.instance.host, t.options.allowedPositions), r = [i, s]; return r.forEach((s, o) => { var a, l, c, h, u, d, p, f, g, m, _, v, y, b, w, x; if (i !== s || r.length === o + 1) return; i = t.placement.split(" ")[0]; const S = "left" === i && Math.floor(null !== (a = t.offsets.target.right) && void 0 !== a ? a : 0) > Math.floor(null !== (l = t.offsets.host.left) && void 0 !== l ? l : 0) || "right" === i && Math.floor(null !== (c = t.offsets.target.left) && void 0 !== c ? c : 0) < Math.floor(null !== (h = t.offsets.host.right) && void 0 !== h ? h : 0) || "top" === i && Math.floor(null !== (u = t.offsets.target.bottom) && void 0 !== u ? u : 0) > Math.floor(null !== (d = t.offsets.host.top) && void 0 !== d ? d : 0) || "bottom" === i && Math.floor(null !== (p = t.offsets.target.top) && void 0 !== p ? p : 0) < Math.floor(null !== (f = t.offsets.host.bottom) && void 0 !== f ? f : 0), k = Math.floor(null !== (g = t.offsets.target.left) && void 0 !== g ? g : 0) < Math.floor(null !== (m = e.left) && void 0 !== m ? m : 0), C = Math.floor(null !== (_ = t.offsets.target.right) && void 0 !== _ ? _ : 0) > Math.floor(null !== (v = e.right) && void 0 !== v ? v : 0), E = Math.floor(null !== (y = t.offsets.target.top) && void 0 !== y ? y : 0) < Math.floor(null !== (b = e.top) && void 0 !== b ? b : 0), T = Math.floor(null !== (w = t.offsets.target.bottom) && void 0 !== w ? w : 0) > Math.floor(null !== (x = e.bottom) && void 0 !== x ? x : 0), P = "left" === i && k || "right" === i && C || "top" === i && E || "bottom" === i && T, D = -1 !== ["top", "bottom"].indexOf(i), A = D && "left" === n && k || D && "right" === n && C || !D && "left" === n && E || !D && "right" === n && T; (S || P || A) && ((S || P) && (i = r[o + 1]), A && (n = function (t) { return "right" === t ? "left" : "left" === t ? "right" : t }(n)), t.placement = i + (n ? ` ${n}` : ""), t.offsets.target = Object.assign(Object.assign({}, t.offsets.target), V_(t.instance.target, t.offsets.host, t.placement))) }), t } function U_(t) { var e; if (!B_(t.options, "preventOverflow")) return t; const i = "transform", n = t.instance.target.style, { top: s, left: r, [i]: o } = n; n.top = "", n.left = "", n[i] = ""; const a = M_(t.instance.target, t.instance.host, 0, (null === (e = t.options.modifiers.preventOverflow) || void 0 === e ? void 0 : e.boundariesElement) || "scrollParent", !1); n.top = s, n.left = r, n[i] = o; const l = { primary(e) { var i, n, s, r; let o = t.offsets.target[e]; return (null !== (i = t.offsets.target[e]) && void 0 !== i ? i : 0) < (null !== (n = a[e]) && void 0 !== n ? n : 0) && (o = Math.max(null !== (s = t.offsets.target[e]) && void 0 !== s ? s : 0, null !== (r = a[e]) && void 0 !== r ? r : 0)), { [e]: o } }, secondary(e) { var i, n, s, r; const o = "right" === e ? "left" : "top"; let l = t.offsets.target[o]; return (null !== (i = t.offsets.target[e]) && void 0 !== i ? i : 0) < (null !== (n = a[e]) && void 0 !== n ? n : 0) && (l = Math.min(null !== (s = t.offsets.target[o]) && void 0 !== s ? s : 0, (null !== (r = a[e]) && void 0 !== r ? r : 0) - ("right" === e ? t.offsets.target.width : t.offsets.target.height))), { [o]: l } } }; return ["left", "right", "top", "bottom"].forEach(e => { const i = -1 !== ["left", "top"].indexOf(e) ? l.primary : l.secondary; t.offsets.target = Object.assign(Object.assign({}, t.offsets.target), i(e)) }), t } function W_(t) { var e; const i = t.placement, n = i.split(" ")[0], s = i.split(" ")[1]; if (s) { const { host: i, target: r } = t.offsets, o = -1 !== ["bottom", "top"].indexOf(n), a = o ? "left" : "top", l = o ? "width" : "height", c = { start: { [a]: i[a] }, end: { [a]: (null !== (e = i[a]) && void 0 !== e ? e : 0) + i[l] - r[l] } }; t.offsets.target = Object.assign(Object.assign({}, r), { [a]: a === s ? c.start[a] : c.end[a] }) } return t } const q_ = new class { position(t, e) { return this.offset(t, e) } offset(t, e) { return j_(e, t) } positionElements(t, e, i, n, s) { const r = [$_, W_, U_, z_], o = function (t, e, i, n) { if (!t || !e) return; const s = j_(t, e); i.match(/^(auto)*\s*(left|right|top|bottom)*$/) || i.match(/^(left|right|top|bottom)*(?: (left|right|top|bottom))?\s*(start|end)*$/) || (i = "auto"); const r = !!i.match(/auto/g); let o = i.match(/auto\s(left|right|top|bottom)/) ? i.split(" ")[1] || "auto" : i; const a = o.match(/^(left|right|top|bottom)* ?(?!\1)(left|right|top|bottom)?/); a && (o = a[1] + (a[2] ? ` ${a[2]}` : "")), -1 !== ["left right", "right left", "top bottom", "bottom top"].indexOf(o) && (o = "auto"); const l = V_(t, s, o); return o = L_(o, s, t, e, n ? n.allowedPositions : void 0), { options: n || { modifiers: {} }, instance: { target: t, host: e, arrow: void 0 }, offsets: { target: l, host: s, arrow: void 0 }, positionFixed: !1, placement: o, placementAuto: r } }(e, t, i, s); if (o) return r.reduce((t, e) => e(t), o) } }; let G_ = (() => { class t { constructor(t, e, i) { this.update$$ = new S, this.positionElements = new Map, this.isDisabled = !1, Zc(i) && t.runOutsideAngular(() => { this.triggerEvent$ = q(s_(window, "scroll", { passive: !0 }), s_(window, "resize", { passive: !0 }), Dh(0, d_), this.update$$), this.triggerEvent$.subscribe(() => { this.isDisabled || this.positionElements.forEach(t => { !function (t, e, i, n, s, r) { const o = q_.positionElements(t, e, i, n, s); if (!o) return; const a = function (t) { var e, i, n, s; return { width: t.offsets.target.width, height: t.offsets.target.height, left: Math.floor(null !== (e = t.offsets.target.left) && void 0 !== e ? e : 0), top: Math.round(null !== (i = t.offsets.target.top) && void 0 !== i ? i : 0), bottom: Math.round(null !== (n = t.offsets.target.bottom) && void 0 !== n ? n : 0), right: Math.floor(null !== (s = t.offsets.target.right) && void 0 !== s ? s : 0) } }(o); H_(e, { "will-change": "transform", top: "0px", left: "0px", transform: `translate3d(${a.left}px, ${a.top}px, 0px)` }, r), o.instance.arrow && H_(o.instance.arrow, o.offsets.arrow, r), function (t, e) { const i = t.instance.target; let n = i.className; t.placementAuto && (n = n.replace(/bs-popover-auto/g, `bs-popover-${t.placement}`), n = n.replace(/bs-tooltip-auto/g, `bs-tooltip-${t.placement}`), n = n.replace(/\sauto/g, ` ${t.placement}`), -1 !== n.indexOf("popover") && -1 === n.indexOf("popover-auto") && (n += " popover-auto"), -1 !== n.indexOf("tooltip") && -1 === n.indexOf("tooltip-auto") && (n += " tooltip-auto")), n = n.replace(/left|right|top|bottom/g, `${t.placement.split(" ")[0]}`), e ? e.setAttribute(i, "class", n) : i.className = n }(o, r) }(Z_(t.target), Z_(t.element), t.attachment, t.appendToBody, this.options, e.createRenderer(null, null)) }) }) }) } position(t) { this.addPositionElement(t) } get event$() { return this.triggerEvent$ } disable() { this.isDisabled = !0 } enable() { this.isDisabled = !1 } addPositionElement(t) { this.positionElements.set(Z_(t.element), t) } calcPosition() { this.update$$.next() } deletePositionElement(t) { this.positionElements.delete(Z_(t)) } setOptions(t) { this.options = t } } return t.\u0275fac = function (e) { return new (e || t)(hn(Vl), hn(Qo), hn(kl)) }, t.\u0275prov = dt({ factory: function () { return new t(hn(Vl), hn(Qo), hn(kl)) }, token: t, providedIn: "root" }), t })(); function Z_(t) { return "string" == typeof t ? document.querySelector(t) : t instanceof Ko ? t.nativeElement : null != t ? t : null } class K_ { constructor(t, e, i) { this.nodes = t, this.viewRef = e, this.componentRef = i } } class Y_ { constructor(t, e, i, n, s, r, o, a) { this._viewContainerRef = t, this._renderer = e, this._elementRef = i, this._injector = n, this._componentFactoryResolver = s, this._ngZone = r, this._applicationRef = o, this._posService = a, this.onBeforeShow = new Ja, this.onShown = new Ja, this.onBeforeHide = new Ja, this.onHidden = new Ja, this._providers = [], this._isHiding = !1, this.containerDefaultSelector = "body", this._listenOpts = {}, this._globalListener = Function.prototype } get isShown() { return !this._isHiding && !!this._componentRef } attach(t) { return this._componentFactory = this._componentFactoryResolver.resolveComponentFactory(t), this } to(t) { return this.container = t || this.container, this } position(t) { return t ? (this.attachment = t.attachment || this.attachment, this._elementRef = t.target || this._elementRef, this) : this } provide(t) { return this._providers.push(t), this } show(t = {}) { if (this._subscribePositioning(), this._innerComponent = void 0, !this._componentRef) { this.onBeforeShow.emit(), this._contentRef = this._getContentRef(t.content, t.context, t.initialState); const e = Pr.create({ providers: this._providers, parent: this._injector }); if (!this._componentFactory) return; if (this._componentRef = this._componentFactory.create(e, this._contentRef.nodes), this._applicationRef.attachView(this._componentRef.hostView), this.instance = this._componentRef.instance, Object.assign(this._componentRef.instance, t), this.container instanceof Ko && this.container.nativeElement.appendChild(this._componentRef.location.nativeElement), "string" == typeof this.container && "undefined" != typeof document) { const t = document.querySelector(this.container) || document.querySelector(this.containerDefaultSelector); if (!t) return; t.appendChild(this._componentRef.location.nativeElement) } !this.container && this._elementRef && this._elementRef.nativeElement.parentElement && this._elementRef.nativeElement.parentElement.appendChild(this._componentRef.location.nativeElement), this._contentRef.componentRef && (this._innerComponent = this._contentRef.componentRef.instance, this._contentRef.componentRef.changeDetectorRef.markForCheck(), this._contentRef.componentRef.changeDetectorRef.detectChanges()), this._componentRef.changeDetectorRef.markForCheck(), this._componentRef.changeDetectorRef.detectChanges(), this.onShown.emit(t.id ? { id: t.id } : this._componentRef.instance) } return this._registerOutsideClick(), this._componentRef } hide(t) { var e, i, n; if (!this._componentRef) return this; this._posService.deletePositionElement(this._componentRef.location), this.onBeforeHide.emit(this._componentRef.instance); const s = this._componentRef.location.nativeElement; return s.parentNode.removeChild(s), (null === (e = this._contentRef) || void 0 === e ? void 0 : e.componentRef) && this._contentRef.componentRef.destroy(), this._viewContainerRef && (null === (i = this._contentRef) || void 0 === i ? void 0 : i.viewRef) && this._viewContainerRef.remove(this._viewContainerRef.indexOf(this._contentRef.viewRef)), (null === (n = this._contentRef) || void 0 === n ? void 0 : n.viewRef) && this._contentRef.viewRef.destroy(), this._contentRef = void 0, this._componentRef = void 0, this._removeGlobalListener(), this.onHidden.emit(t ? { id: t } : null), this } toggle() { this.isShown ? this.hide() : this.show() } dispose() { this.isShown && this.hide(), this._unsubscribePositioning(), this._unregisterListenersFn && this._unregisterListenersFn() } listen(t) { var e; this.triggers = t.triggers || this.triggers, this._listenOpts.outsideClick = t.outsideClick, this._listenOpts.outsideEsc = t.outsideEsc, t.target = t.target || (null === (e = this._elementRef) || void 0 === e ? void 0 : e.nativeElement); const i = this._listenOpts.hide = () => t.hide ? t.hide() : void this.hide(), n = this._listenOpts.show = e => { t.show ? t.show(e) : this.show(e), e() }; return this._renderer && (this._unregisterListenersFn = function (t, e) { const i = function (t, e = t_) { const i = (t || "").trim(); if (0 === i.length) return []; const n = i.split(/\s+/).map(t => t.split(":")).map(t => { const i = e[t[0]] || t; return new Jm(i[0], i[1]) }), s = n.filter(t => t.isManual()); if (s.length > 1) throw new Error("Triggers parse error: only one manual trigger is allowed"); if (1 === s.length && n.length > 1) throw new Error("Triggers parse error: manual trigger can't be mixed with other triggers"); return n }(e.triggers), n = e.target; if (1 === i.length && i[0].isManual()) return Function.prototype; const s = [], r = [], o = () => { r.forEach(t => s.push(t())), r.length = 0 }; return i.forEach(i => { const a = i.open === i.close, l = a ? e.toggle : e.show; if (!a && i.close && e.hide) { const s = t.listen(n, i.close, e.hide); r.push(() => s) } l && s.push(t.listen(n, i.open, () => l(o))) }), () => { s.forEach(t => t()) } }(this._renderer, { target: t.target, triggers: t.triggers, show: n, hide: i, toggle: t => { this.isShown ? i() : n(t) } })), this } _removeGlobalListener() { this._globalListener && (this._globalListener(), this._globalListener = Function.prototype) } attachInline(t, e) { return t && e && (this._inlineViewRef = t.createEmbeddedView(e)), this } _registerOutsideClick() { if (this._componentRef && this._componentRef.location) { if (this._listenOpts.outsideClick) { const t = this._componentRef.location.nativeElement; setTimeout(() => { var e; this._renderer && this._elementRef && (this._globalListener = (e = { targets: [t, this._elementRef.nativeElement], outsideClick: this._listenOpts.outsideClick, hide: () => this._listenOpts.hide && this._listenOpts.hide() }).outsideClick ? this._renderer.listen("document", "click", t => { e.target && e.target.contains(t.target) || e.targets && e.targets.some(e => e.contains(t.target)) || e.hide && e.hide() }) : Function.prototype) }) } var t; this._listenOpts.outsideEsc && this._renderer && this._elementRef && (this._globalListener = (t = { targets: [this._componentRef.location.nativeElement, this._elementRef.nativeElement], outsideEsc: this._listenOpts.outsideEsc, hide: () => this._listenOpts.hide && this._listenOpts.hide() }).outsideEsc ? this._renderer.listen("document", "keyup.esc", e => { t.target && t.target.contains(e.target) || t.targets && t.targets.some(t => t.contains(e.target)) || t.hide && t.hide() }) : Function.prototype) } } getInnerComponent() { return this._innerComponent } _subscribePositioning() { !this._zoneSubscription && this.attachment && (this.onShown.subscribe(() => { var t; this._posService.position({ element: null === (t = this._componentRef) || void 0 === t ? void 0 : t.location, target: this._elementRef, attachment: this.attachment, appendToBody: "body" === this.container }) }), this._zoneSubscription = this._ngZone.onStable.subscribe(() => { this._componentRef && this._posService.calcPosition() })) } _unsubscribePositioning() { this._zoneSubscription && (this._zoneSubscription.unsubscribe(), this._zoneSubscription = void 0) } _getContentRef(t, e, i) { if (!t) return new K_([]); if (t instanceof Ea) { if (this._viewContainerRef) { const i = this._viewContainerRef.createEmbeddedView(t, e); return i.markForCheck(), new K_([i.rootNodes], i) } const i = t.createEmbeddedView({}); return this._applicationRef.attachView(i), new K_([i.rootNodes], i) } if ("function" == typeof t) { const e = this._componentFactoryResolver.resolveComponentFactory(t), n = Pr.create({ providers: this._providers, parent: this._injector }), s = e.create(n); return Object.assign(s.instance, i), this._applicationRef.attachView(s.hostView), new K_([[s.location.nativeElement]], s.hostView, s) } const n = this._renderer ? [this._renderer.createText(`${t}`)] : []; return new K_([n]) } } let Q_, X_ = (() => { class t { constructor(t, e, i, n, s) { this._componentFactoryResolver = t, this._ngZone = e, this._injector = i, this._posService = n, this._applicationRef = s } createLoader(t, e, i) { return new Y_(e, i, t, this._injector, this._componentFactoryResolver, this._ngZone, this._applicationRef, this._posService) } } return t.\u0275fac = function (e) { return new (e || t)(hn(Wo), hn(Vl), hn(Pr), hn(G_), hn(oc)) }, t.\u0275prov = dt({ factory: function () { return new t(hn(Wo), hn(Vl), hn(pr), hn(G_), hn(oc)) }, token: t, providedIn: "root" }), t })(), J_ = (() => { class t { constructor() { this._focusTrapStack = [] } register(t) { this._focusTrapStack = this._focusTrapStack.filter(e => e !== t); let e = this._focusTrapStack; e.length && e[e.length - 1]._disable(), e.push(t), t._enable() } deregister(t) { t._disable(); const e = this._focusTrapStack, i = e.indexOf(t); -1 !== i && (e.splice(i, 1), e.length && e[e.length - 1]._enable()) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = dt({ factory: function () { return new t }, token: t, providedIn: "root" }), t })(); try { Q_ = "undefined" != typeof Intl && Intl.v8BreakIterator } catch (SM) { Q_ = !1 } let tv = (() => { class t { constructor(t) { this._platformId = t, this.isBrowser = this._platformId ? Zc(this._platformId) : "object" == typeof document && !!document, this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent), this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent), this.BLINK = this.isBrowser && !(!window.chrome && !Q_) && "undefined" != typeof CSS && !this.EDGE && !this.TRIDENT, this.WEBKIT = this.isBrowser && /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT, this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !("MSStream" in window), this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent), this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT, this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT } } return t.\u0275fac = function (e) { return new (e || t)(hn(kl)) }, t.\u0275prov = dt({ factory: function () { return new t(hn(kl)) }, token: t, providedIn: "root" }), t })(), ev = (() => { class t { constructor(t) { this._platform = t } isDisabled(t) { return t.hasAttribute("disabled") } isVisible(t) { return function (t) { return !!(t.offsetWidth || t.offsetHeight || "function" == typeof t.getClientRects && t.getClientRects().length) }(t) && "visible" === getComputedStyle(t).visibility } isTabbable(t) { if (!this._platform.isBrowser) return !1; const e = function (t) { try { return t.frameElement } catch (SM) { return null } }((i = t).ownerDocument && i.ownerDocument.defaultView || window); var i; if (e) { if (-1 === nv(e)) return !1; if (!this.isVisible(e)) return !1 } let n = t.nodeName.toLowerCase(), s = nv(t); return t.hasAttribute("contenteditable") ? -1 !== s : "iframe" !== n && "object" !== n && !(this._platform.WEBKIT && this._platform.IOS && !function (t) { let e = t.nodeName.toLowerCase(), i = "input" === e && t.type; return "text" === i || "password" === i || "select" === e || "textarea" === e }(t)) && ("audio" === n ? !!t.hasAttribute("controls") && -1 !== s : "video" === n ? -1 !== s && (null !== s || this._platform.FIREFOX || t.hasAttribute("controls")) : t.tabIndex >= 0) } isFocusable(t, e) { return function (t) { return !function (t) { return function (t) { return "input" == t.nodeName.toLowerCase() }(t) && "hidden" == t.type }(t) && (function (t) { let e = t.nodeName.toLowerCase(); return "input" === e || "select" === e || "button" === e || "textarea" === e }(t) || function (t) { return function (t) { return "a" == t.nodeName.toLowerCase() }(t) && t.hasAttribute("href") }(t) || t.hasAttribute("contenteditable") || iv(t)) }(t) && !this.isDisabled(t) && ((null == e ? void 0 : e.ignoreVisibility) || this.isVisible(t)) } } return t.\u0275fac = function (e) { return new (e || t)(hn(tv)) }, t.\u0275prov = dt({ factory: function () { return new t(hn(tv)) }, token: t, providedIn: "root" }), t })(); function iv(t) { if (!t.hasAttribute("tabindex") || void 0 === t.tabIndex) return !1; let e = t.getAttribute("tabindex"); return "-32768" != e && !(!e || isNaN(parseInt(e, 10))) } function nv(t) { if (!iv(t)) return null; const e = parseInt(t.getAttribute("tabindex") || "", 10); return isNaN(e) ? -1 : e } function sv(t) { return null != t && "false" != `${t}` } class rv { constructor(t, e, i, n, s = !1) { this._element = t, this._checker = e, this._ngZone = i, this._document = n, this._hasAttached = !1, this.startAnchorListener = () => this.focusLastTabbableElement(), this.endAnchorListener = () => this.focusFirstTabbableElement(), this._enabled = !0, s || this.attachAnchors() } get enabled() { return this._enabled } set enabled(t) { this._enabled = t, this._startAnchor && this._endAnchor && (this._toggleAnchorTabIndex(t, this._startAnchor), this._toggleAnchorTabIndex(t, this._endAnchor)) } destroy() { const t = this._startAnchor, e = this._endAnchor; t && (t.removeEventListener("focus", this.startAnchorListener), t.parentNode && t.parentNode.removeChild(t)), e && (e.removeEventListener("focus", this.endAnchorListener), e.parentNode && e.parentNode.removeChild(e)), this._startAnchor = this._endAnchor = null, this._hasAttached = !1 } attachAnchors() { return !!this._hasAttached || (this._ngZone.runOutsideAngular(() => { this._startAnchor || (this._startAnchor = this._createAnchor(), this._startAnchor.addEventListener("focus", this.startAnchorListener)), this._endAnchor || (this._endAnchor = this._createAnchor(), this._endAnchor.addEventListener("focus", this.endAnchorListener)) }), this._element.parentNode && (this._element.parentNode.insertBefore(this._startAnchor, this._element), this._element.parentNode.insertBefore(this._endAnchor, this._element.nextSibling), this._hasAttached = !0), this._hasAttached) } focusInitialElementWhenReady() { return new Promise(t => { this._executeOnStable(() => t(this.focusInitialElement())) }) } focusFirstTabbableElementWhenReady() { return new Promise(t => { this._executeOnStable(() => t(this.focusFirstTabbableElement())) }) } focusLastTabbableElementWhenReady() { return new Promise(t => { this._executeOnStable(() => t(this.focusLastTabbableElement())) }) } _getRegionBoundary(t) { let e = this._element.querySelectorAll(`[cdk-focus-region-${t}], [cdkFocusRegion${t}], [cdk-focus-${t}]`); for (let i = 0; i < e.length; i++)e[i].hasAttribute(`cdk-focus-${t}`) ? console.warn(`Found use of deprecated attribute 'cdk-focus-${t}', use 'cdkFocusRegion${t}' instead. The deprecated attribute will be removed in 8.0.0.`, e[i]) : e[i].hasAttribute(`cdk-focus-region-${t}`) && console.warn(`Found use of deprecated attribute 'cdk-focus-region-${t}', use 'cdkFocusRegion${t}' instead. The deprecated attribute will be removed in 8.0.0.`, e[i]); return "start" == t ? e.length ? e[0] : this._getFirstTabbableElement(this._element) : e.length ? e[e.length - 1] : this._getLastTabbableElement(this._element) } focusInitialElement() { const t = this._element.querySelector("[cdk-focus-initial], [cdkFocusInitial]"); if (t) { if (t.hasAttribute("cdk-focus-initial") && console.warn("Found use of deprecated attribute 'cdk-focus-initial', use 'cdkFocusInitial' instead. The deprecated attribute will be removed in 8.0.0", t), !this._checker.isFocusable(t)) { const e = this._getFirstTabbableElement(t); return null == e || e.focus(), !!e } return t.focus(), !0 } return this.focusFirstTabbableElement() } focusFirstTabbableElement() { const t = this._getRegionBoundary("start"); return t && t.focus(), !!t } focusLastTabbableElement() { const t = this._getRegionBoundary("end"); return t && t.focus(), !!t } hasAttached() { return this._hasAttached } _getFirstTabbableElement(t) { if (this._checker.isFocusable(t) && this._checker.isTabbable(t)) return t; let e = t.children || t.childNodes; for (let i = 0; i < e.length; i++) { let t = e[i].nodeType === this._document.ELEMENT_NODE ? this._getFirstTabbableElement(e[i]) : null; if (t) return t } return null } _getLastTabbableElement(t) { if (this._checker.isFocusable(t) && this._checker.isTabbable(t)) return t; let e = t.children || t.childNodes; for (let i = e.length - 1; i >= 0; i--) { let t = e[i].nodeType === this._document.ELEMENT_NODE ? this._getLastTabbableElement(e[i]) : null; if (t) return t } return null } _createAnchor() { const t = this._document.createElement("div"); return this._toggleAnchorTabIndex(this._enabled, t), t.classList.add("cdk-visually-hidden"), t.classList.add("cdk-focus-trap-anchor"), t.setAttribute("aria-hidden", "true"), t } _toggleAnchorTabIndex(t, e) { t ? e.setAttribute("tabindex", "0") : e.removeAttribute("tabindex") } toggleAnchors(t) { this._startAnchor && this._endAnchor && (this._toggleAnchorTabIndex(t, this._startAnchor), this._toggleAnchorTabIndex(t, this._endAnchor)) } _executeOnStable(t) { this._ngZone.isStable ? t() : this._ngZone.onStable.pipe(qh(1)).subscribe(t) } } let ov = (() => { class t { constructor(t, e, i) { this._checker = t, this._ngZone = e, this._document = i } create(t, e = !1) { return new rv(t, this._checker, this._ngZone, this._document, e) } } return t.\u0275fac = function (e) { return new (e || t)(hn(ev), hn(Vl), hn(vc)) }, t.\u0275prov = dt({ factory: function () { return new t(hn(ev), hn(Vl), hn(vc)) }, token: t, providedIn: "root" }), t })(), av = (() => { class t { constructor(t, e, i) { this._elementRef = t, this._focusTrapFactory = e, this._previouslyFocusedElement = null, this._document = i, this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, !0) } get enabled() { return this.focusTrap.enabled } set enabled(t) { this.focusTrap.enabled = sv(t) } get autoCapture() { return this._autoCapture } set autoCapture(t) { this._autoCapture = sv(t) } ngOnDestroy() { this.focusTrap.destroy(), this._previouslyFocusedElement && (this._previouslyFocusedElement.focus(), this._previouslyFocusedElement = null) } ngAfterContentInit() { this.focusTrap.attachAnchors(), this.autoCapture && this._captureFocus() } ngDoCheck() { this.focusTrap.hasAttached() || this.focusTrap.attachAnchors() } ngOnChanges(t) { const e = t.autoCapture; e && !e.firstChange && this.autoCapture && this.focusTrap.hasAttached() && this._captureFocus() } _captureFocus() { this._previouslyFocusedElement = this._document.activeElement, this.focusTrap.focusInitialElementWhenReady() } } return t.\u0275fac = function (e) { return new (e || t)(Ur(Ko), Ur(ov), Ur(vc)) }, t.\u0275dir = Kt({ type: t, selectors: [["", "focusTrap", ""]], inputs: { enabled: ["cdkTrapFocus", "enabled"], autoCapture: ["cdkTrapFocusAutoCapture", "autoCapture"] }, exportAs: ["focusTrap"], features: [le] }), t })(), lv = (() => { class t { static forRoot() { return { ngModule: t, providers: [J_, tv, ev] } } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Gt({ type: t }), t.\u0275inj = pt({ imports: [[Gc]] }), t })(); const cv = ["*"]; let hv = (() => { class t { constructor() { this.hide = () => { }, this.setClass = () => { } } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), uv = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); const dv = { backdrop: !0, keyboard: !0, focus: !0, show: !1, ignoreBackdropClick: !1, class: "", animated: !0, initialState: {}, closeInterceptor: void 0 }, pv = new Wi("override-default-config"), fv = "modal-open", gv = "show"; let mv = (() => { class t { constructor(t, e, i) { this._element = e, this._renderer = i, this.isShown = !1, this.isAnimated = !1, this.isModalHiding = !1, this.clickStartedInContent = !1, this.config = Object.assign({}, t) } ngOnInit() { this.isAnimated && this._renderer.addClass(this._element.nativeElement, "fade"), this._renderer.setStyle(this._element.nativeElement, "display", "block"), setTimeout(() => { this.isShown = !0, this._renderer.addClass(this._element.nativeElement, n_() ? "in" : gv) }, this.isAnimated ? 150 : 0), document && document.body && (this.bsModalService && 1 === this.bsModalService.getModalsCount() && (this.bsModalService.checkScrollbar(), this.bsModalService.setScrollbar()), this._renderer.addClass(document.body, fv)), this._element.nativeElement && this._element.nativeElement.focus() } onClickStarted(t) { this.clickStartedInContent = t.target !== this._element.nativeElement } onClickStop(t) { var e; this.config.ignoreBackdropClick || "static" === this.config.backdrop || t.target !== this._element.nativeElement || this.clickStartedInContent ? this.clickStartedInContent = !1 : (null === (e = this.bsModalService) || void 0 === e || e.setDismissReason("backdrop-click"), this.hide()) } onPopState() { var t; null === (t = this.bsModalService) || void 0 === t || t.setDismissReason("browser-back-navigation-clicked"), this.hide() } onEsc(t) { var e, i; this.isShown && (27 !== t.keyCode && "Escape" !== t.key || t.preventDefault(), this.config.keyboard && this.level === (null === (e = this.bsModalService) || void 0 === e ? void 0 : e.getModalsCount()) && (null === (i = this.bsModalService) || void 0 === i || i.setDismissReason("esc"), this.hide())) } ngOnDestroy() { this.isShown && this._hide() } hide() { !this.isModalHiding && this.isShown && (this.config.closeInterceptor ? this.config.closeInterceptor().then(() => this._hide(), () => { }) : this._hide()) } _hide() { this.isModalHiding = !0, this._renderer.removeClass(this._element.nativeElement, n_() ? "in" : gv), setTimeout(() => { var t, e; this.isShown = !1, document && document.body && 1 === (null === (t = this.bsModalService) || void 0 === t ? void 0 : t.getModalsCount()) && this._renderer.removeClass(document.body, fv), null === (e = this.bsModalService) || void 0 === e || e.hide(this.config.id), this.isModalHiding = !1 }, this.isAnimated ? 300 : 0) } } return t.\u0275fac = function (e) { return new (e || t)(Ur(uv), Ur(Ko), Ur(Xo)) }, t.\u0275cmp = $t({ type: t, selectors: [["modal-container"]], hostAttrs: ["role", "dialog", "tabindex", "-1", 1, "modal"], hostVars: 3, hostBindings: function (t, e) { 1 & t && Jr("mousedown", function (t) { return e.onClickStarted(t) })("click", function (t) { return e.onClickStop(t) })("popstate", function () { return e.onPopState() }, !1, An)("keydown.esc", function (t) { return e.onEsc(t) }, !1, An), 2 & t && Hr("aria-modal", !0)("aria-labelledby", e.config.ariaLabelledBy)("aria-describedby", e.config.ariaDescribedby) }, ngContentSelectors: cv, decls: 3, vars: 2, consts: [["role", "document", "focusTrap", ""], [1, "modal-content"]], template: function (t, e) { 1 & t && (function (t) { const e = De()[16][6]; if (!e.projection) { const t = e.projection = Xi(1, null), i = t.slice(); let n = e.child; for (; null !== n;) { const e = 0; null !== e && (i[e] ? i[e].projectionNext = n : t[e] = n, i[e] = n), n = n.next } } }(), Gr(0, "div", 0), Gr(1, "div", 1), function (t, e = 0, i) { const n = De(), s = Ae(), r = Ps(s, Xt + t, 16, null, i || null); null === r.projection && (r.projection = e), Fe(), 64 != (64 & r.flags) && function (t, e, i) { ns(e[11], 0, e, i, Un(t, i, e), Kn(i.parent || e[6], i, e)) }(s, n, r) }(2), Zr(), Zr()), 2 & t && function (t, e, i, n) { const s = Ae(), r = He(2); s.firstUpdatePass && go(s, null, r, n); const o = De(); if (i !== _s && Br(o, r, i)) { const a = s.data[ei()]; if (wo(a, n) && !fo(s, r)) { let t = a.classesWithoutHost; null !== t && (i = nt(t, i || "")), qr(s, a, o, i, n) } else !function (t, e, i, n, s, r, o, a) { s === _s && (s = It); let l = 0, c = 0, h = 0 < s.length ? s[0] : null, u = 0 < r.length ? r[0] : null; for (; null !== h || null !== u;) { const o = l < s.length ? s[l + 1] : void 0, d = c < r.length ? r[c + 1] : void 0; let p, f = null; h === u ? (l += 2, c += 2, o !== d && (f = u, p = d)) : null === u || null !== h && h < u ? (l += 2, f = h) : (c += 2, f = u, p = d), null !== f && vo(t, e, i, n, f, p, !0, a), h = l < s.length ? s[l] : null, u = c < r.length ? r[c] : null } }(s, a, o, o[11], o[r + 1], o[r + 1] = function (t, e, i) { if (null == i || "" === i) return It; const n = [], s = vn(i); if (Array.isArray(s)) for (let r = 0; r < s.length; r++)t(n, s[r], !0); else if ("object" == typeof s) for (const r in s) s.hasOwnProperty(r) && t(n, r, s[r]); else "string" == typeof s && e(n, s); return n }(t, e, i), 0, r) } }(Ji, po, "modal-dialog" + (e.config.class ? " " + e.config.class : ""), !0) }, directives: [av], encapsulation: 2 }), t })(), _v = (() => { class t { constructor(t, e) { this._isAnimated = !1, this._isShown = !1, this.element = t, this.renderer = e } get isAnimated() { return this._isAnimated } set isAnimated(t) { this._isAnimated = t } get isShown() { return this._isShown } set isShown(t) { this._isShown = t, t ? this.renderer.addClass(this.element.nativeElement, "in") : this.renderer.removeClass(this.element.nativeElement, "in"), n_() || (t ? this.renderer.addClass(this.element.nativeElement, "show") : this.renderer.removeClass(this.element.nativeElement, "show")) } ngOnInit() { this.isAnimated && (this.renderer.addClass(this.element.nativeElement, "fade"), class { static reflow(t) { } static getStyles(t) { let e = t.ownerDocument.defaultView; return e && e.opener || (e = e_), e.getComputedStyle(t) } }.reflow(this.element.nativeElement)), this.isShown = !0 } } return t.\u0275fac = function (e) { return new (e || t)(Ur(Ko), Ur(Xo)) }, t.\u0275cmp = $t({ type: t, selectors: [["bs-modal-backdrop"]], hostAttrs: [1, "modal-backdrop"], decls: 0, vars: 0, template: function (t, e) { }, encapsulation: 2 }), t })(), vv = (() => { class t { constructor(t, e, i) { this.clf = e, this.modalDefaultOption = i, this.onShow = new Ja, this.onShown = new Ja, this.onHide = new Ja, this.onHidden = new Ja, this.isBodyOverflowing = !1, this.originalBodyPadding = 0, this.scrollbarWidth = 0, this.modalsCount = 0, this.loaders = [], this._backdropLoader = this.clf.createLoader(), this._renderer = t.createRenderer(null, null), this.config = i ? Object.assign({}, dv, i) : dv } show(t, e) { this.modalsCount++, this._createLoaders(); const i = (null == e ? void 0 : e.id) || (new Date).getUTCMilliseconds(); return this.config = this.modalDefaultOption ? Object.assign({}, dv, this.modalDefaultOption, e) : Object.assign({}, dv, e), this.config.id = i, this._showBackdrop(), this.lastDismissReason = void 0, this._showModal(t) } hide(t) { 1 !== this.modalsCount && null != t || (this._hideBackdrop(), this.resetScrollbar()), this.modalsCount = this.modalsCount >= 1 && null != t ? this.modalsCount - 1 : 0, setTimeout(() => { this._hideModal(t), this.removeLoaders(t) }, this.config.animated ? 150 : 0) } _showBackdrop() { const t = !0 === this.config.backdrop || "static" === this.config.backdrop, e = !this.backdropRef || !this.backdropRef.instance.isShown; 1 === this.modalsCount && (this.removeBackdrop(), t && e && (this._backdropLoader.attach(_v).to("body").show({ isAnimated: this.config.animated }), this.backdropRef = this._backdropLoader._componentRef)) } _hideBackdrop() { this.backdropRef && (this.backdropRef.instance.isShown = !1, setTimeout(() => this.removeBackdrop(), this.config.animated ? 150 : 0)) } _showModal(t) { var e; const i = this.loaders[this.loaders.length - 1]; if (this.config && this.config.providers) for (const r of this.config.providers) i.provide(r); const n = new hv, s = i.provide({ provide: uv, useValue: this.config }).provide({ provide: hv, useValue: n }).attach(mv).to("body"); return n.hide = () => { var t; return null === (t = s.instance) || void 0 === t ? void 0 : t.hide() }, n.setClass = t => { s.instance && (s.instance.config.class = t) }, n.onHidden = new Ja, n.onHide = new Ja, this.copyEvent(i.onBeforeHide, n.onHide), this.copyEvent(i.onHidden, n.onHidden), s.show({ content: t, isAnimated: this.config.animated, initialState: this.config.initialState, bsModalService: this, id: this.config.id }), s.instance && (s.instance.level = this.getModalsCount(), n.content = i.getInnerComponent(), n.id = null === (e = s.instance.config) || void 0 === e ? void 0 : e.id), n } _hideModal(t) { if (null != t) { const e = this.loaders.findIndex(e => { var i; return (null === (i = e.instance) || void 0 === i ? void 0 : i.config.id) === t }), i = this.loaders[e]; i && i.hide(t) } else this.loaders.forEach(t => { t.instance && t.hide(t.instance.config.id) }) } getModalsCount() { return this.modalsCount } setDismissReason(t) { this.lastDismissReason = t } removeBackdrop() { this._renderer.removeClass(document.body, fv), this._backdropLoader.hide(), this.backdropRef = void 0 } checkScrollbar() { this.isBodyOverflowing = document.body.clientWidth < window.innerWidth, this.scrollbarWidth = this.getScrollbarWidth() } setScrollbar() { document && (this.originalBodyPadding = parseInt(window.getComputedStyle(document.body).getPropertyValue("padding-right") || "0", 10), this.isBodyOverflowing && (document.body.style.paddingRight = `${this.originalBodyPadding + this.scrollbarWidth}px`)) } resetScrollbar() { document.body.style.paddingRight = `${this.originalBodyPadding}px` } getScrollbarWidth() { const t = this._renderer.createElement("div"); this._renderer.addClass(t, "modal-scrollbar-measure"), this._renderer.appendChild(document.body, t); const e = t.offsetWidth - t.clientWidth; return this._renderer.removeChild(document.body, t), e } _createLoaders() { const t = this.clf.createLoader(); this.copyEvent(t.onBeforeShow, this.onShow), this.copyEvent(t.onShown, this.onShown), this.copyEvent(t.onBeforeHide, this.onHide), this.copyEvent(t.onHidden, this.onHidden), this.loaders.push(t) } removeLoaders(t) { if (null != t) { const e = this.loaders.findIndex(e => { var i; return (null === (i = e.instance) || void 0 === i ? void 0 : i.config.id) === t }); e >= 0 && (this.loaders.splice(e, 1), this.loaders.forEach((t, e) => { t.instance && (t.instance.level = e + 1) })) } else this.loaders.splice(0, this.loaders.length) } copyEvent(t, e) { t.subscribe(t => { e.emit(this.lastDismissReason || t) }) } } return t.\u0275fac = function (e) { return new (e || t)(hn(Qo), hn(X_), hn(pv, 8)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); lv.forRoot(); const yv = "http://devazure.eastus.cloudapp.azure.com:8085/api/members"; let bv = (() => { class t { constructor(t) { this.http = t } getAllMembers() { return this.http.get(yv) } getMemberById(t) { return this.http.get(yv + "/" + t) } addMember(t) { return this.http.post(yv, t) } updateMember(t) { return this.http.put(yv, t) } deleteMember(t) { return this.http.delete(yv + "/" + t) } affecterMemberToProject(t, e) { return this.http.put(yv + "/" + t + "/assignProject/" + e, null) } getTaskMemberByUsername(t) { return this.http.get(yv + "/tasks/" + t) } } return t.\u0275fac = function (e) { return new (e || t)(hn(bm)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(); var wv = function () { function t(t, e, i) { this.el = t, this.vcr = e, this.renderer = i, this.dtOptions = {} } return t.prototype.ngOnInit = function () { var t = this; this.dtTrigger ? this.dtTrigger.subscribe(function () { t.displayTable() }) : this.displayTable() }, t.prototype.ngOnDestroy = function () { this.dtTrigger && this.dtTrigger.unsubscribe(), this.dt && this.dt.destroy(!0) }, t.prototype.displayTable = function () { var t = this, e = this; this.dtInstance = new Promise(function (i, n) { Promise.resolve(t.dtOptions).then(function (n) { setTimeout(function () { var s = { rowCallback: function (i, s, r) { if (n.columns) { var o = n.columns; o.filter(function (t) { return t.ngPipeInstance && !t.ngTemplateRef }).forEach(function (t) { var e = t.ngPipeInstance, n = o.findIndex(function (e) { return e.data == t.data }), s = i.childNodes.item(n), r = $(s).text(), a = e.transform(r); $(s).text(a) }), o.filter(function (t) { return t.ngTemplateRef && !t.ngPipeInstance }).forEach(function (t) { var n = t.ngTemplateRef, r = n.ref, a = n.context, l = o.findIndex(function (e) { return e.data == t.data }), c = i.childNodes.item(l), h = Object.assign({}, a, null == a ? void 0 : a.userData, { adtData: s }), u = e.vcr.createEmbeddedView(r, h); e.renderer.appendChild(c, u.rootNodes[0]) }) } t.dtOptions.rowCallback && t.dtOptions.rowCallback(i, s, r) } }; s = Object.assign({}, n, s), t.dt = $(t.el.nativeElement).DataTable(s), i(t.dt) }) }) }) }, t.\u0275fac = function (e) { return new (e || t)(Ur(Ko), Ur(Ma), Ur(Xo)) }, t.\u0275dir = Kt({ type: t, selectors: [["", "datatable", ""]], inputs: { dtOptions: "dtOptions", dtTrigger: "dtTrigger" } }), t }(); function xv(t, e) { 1 & t && (Gr(0, "tbody"), Gr(1, "tr"), Gr(2, "td", 21), xo(3, "Loading data..."), Zr(), Zr(), Zr()) } function Sv(t, e) { if (1 & t) { const t = Yr(); Gr(0, "tr"), Gr(1, "td"), xo(2), Zr(), Gr(3, "td"), xo(4), Zr(), Gr(5, "td"), xo(6), Zr(), Gr(7, "td"), xo(8), Zr(), Gr(9, "td"), xo(10), Zr(), Gr(11, "td"), xo(12), Zr(), Gr(13, "td"), Gr(14, "a", 22), Jr("click", function () { const e = Oe(t).$implicit; return so(2).openSeeTaskModal(e) }), Kr(15, "i", 23), Zr(), Gr(16, "a", 24), Jr("click", function () { const e = Oe(t).$implicit, i = so(2), n = $r(55); return i.openEditTaskModal(n, e) }), Kr(17, "i", 25), Zr(), Gr(18, "a", 26), Jr("click", function () { const e = Oe(t).$implicit, i = so(2), n = $r(57); return i.openDeleteTaskModal(n, e) }), Kr(19, "i", 27), Zr(), Zr(), Zr() } if (2 & t) { const t = e.$implicit; vs(2), So(t.id), vs(2), So(t.title), vs(2), So(t.description), vs(2), So(t.startDate), vs(2), So(t.dueDate), vs(2), So(t.status) } } function kv(t, e) { if (1 & t && (Gr(0, "tbody"), zr(1, Sv, 20, 6, "tr", 18), Zr()), 2 & t) { const t = so(); vs(1), Wr("ngForOf", t.tasks) } } function Cv(t, e) { if (1 & t && (Gr(0, "li"), xo(1), Zr()), 2 & t) { const t = e.$implicit; vs(1), So(t.fullname) } } function Ev(t, e) { if (1 & t && (Gr(0, "option", 42), xo(1), Zr()), 2 & t) { const t = e.$implicit; Wr("ngValue", t.id), vs(1), So(t.name) } } function Tv(t, e) { if (1 & t) { const t = Yr(); Gr(0, "div"), Gr(1, "div", 43), Gr(2, "input", 44), Jr("change", function () { const e = Oe(t).$implicit; return so(2).toggleMemberSelection(e) }), Zr(), Gr(3, "label", 45), xo(4), Zr(), Zr(), Zr() } if (2 & t) { const t = e.$implicit, i = so(2); vs(2), Wr("id", "member-" + t.id)("value", t)("checked", i.isMemberSelected(t)), vs(1), Wr("for", "member-" + t.id), vs(1), ko(" ", t.fullname, " ") } } const Pv = function () { return { standalone: !0 } }; function Dv(t, e) { if (1 & t) { const t = Yr(); Gr(0, "div"), Gr(1, "div", 12), Gr(2, "div", 13), Gr(3, "h5", 28), xo(4, "Edit Task"), Zr(), Gr(5, "button", 15), Gr(6, "span", 16), xo(7, "\xd7"), Zr(), Zr(), Zr(), Gr(8, "div", 17), Gr(9, "form"), Gr(10, "div", 29), Gr(11, "label", 30), xo(12, "Title"), Zr(), Gr(13, "input", 31), Jr("ngModelChange", function (e) { return Oe(t), so().selectedTask.title = e }), Zr(), Zr(), Gr(14, "div", 29), Gr(15, "label", 32), xo(16, "Description"), Zr(), Gr(17, "textarea", 33), Jr("ngModelChange", function (e) { return Oe(t), so().selectedTask.description = e }), Zr(), Zr(), Gr(18, "div", 29), Gr(19, "label", 34), xo(20, "Start Date"), Zr(), Gr(21, "input", 35), Jr("ngModelChange", function (e) { return Oe(t), so().selectedTask.startDate = e }), Zr(), Zr(), Gr(22, "div", 29), Gr(23, "label", 36), xo(24, "Due Date"), Zr(), Gr(25, "input", 37), Jr("ngModelChange", function (e) { return Oe(t), so().selectedTask.dueDate = e }), Zr(), Zr(), Gr(26, "div", 29), Gr(27, "label", 38), xo(28, "Status"), Zr(), Gr(29, "select", 39), Jr("ngModelChange", function (e) { return Oe(t), so().selectedTask.status = e }), zr(30, Ev, 2, 2, "option", 40), Zr(), Zr(), Gr(31, "div", 29), Gr(32, "label"), xo(33, "Assigned Members"), Zr(), zr(34, Tv, 5, 5, "div", 18), Zr(), Gr(35, "button", 41), Jr("click", function () { return Oe(t), so().saveEditedTask() }), xo(36, "Save Changes"), Zr(), Zr(), Zr(), Zr(), Zr() } if (2 & t) { const t = so(); vs(13), Wr("ngModel", t.selectedTask.title)("ngModelOptions", Za(12, Pv)), vs(4), Wr("ngModel", t.selectedTask.description)("ngModelOptions", Za(13, Pv)), vs(4), Wr("ngModel", t.selectedTask.startDate)("ngModelOptions", Za(14, Pv)), vs(4), Wr("ngModel", t.selectedTask.dueDate)("ngModelOptions", Za(15, Pv)), vs(4), Wr("ngModel", t.selectedTask.status)("ngModelOptions", Za(16, Pv)), vs(1), Wr("ngForOf", t.listStatus), vs(4), Wr("ngForOf", t.listMembers) } } function Av(t, e) { if (1 & t) { const t = Yr(); Gr(0, "div", 12), Gr(1, "div", 13), Gr(2, "h5", 46), xo(3, "Delete Task"), Zr(), Gr(4, "button", 15), Gr(5, "span", 16), xo(6, "\xd7"), Zr(), Zr(), Zr(), Gr(7, "div", 17), Gr(8, "p"), xo(9), Zr(), Zr(), Gr(10, "div", 47), Gr(11, "button", 48), xo(12, "Close"), Zr(), Gr(13, "button", 49), Jr("click", function () { Oe(t); const e = so(); return e.MoveToTrash(e.selectedTask.id) }), xo(14, "Delete Task"), Zr(), Zr(), Zr() } if (2 & t) { const t = so(); vs(9), ko('Are you sure you want to delete the task "', t.selectedTask.title, '"?') } } let Ov = (() => { class t { constructor(t, e, i, n, s) { this.router = t, this.taskService = e, this.http = i, this.modalService = n, this.memberService = s, this.dtOptions = {}, this.dtTrigger = new S, this.loadingData = !1, this.selectedTask = {}, this.listMembers = [], this.listStatus = [{ id: "TODO", name: "Todo" }, { id: "DOING", name: "Doing" }, { id: "DONE", name: "Done" }, { id: "ARCHIVED", name: "Archived" }, { id: "PENDING", name: "Pending" }, { id: "IN_PROGRESS", name: "In Progress" }] } ngAfterViewInit() { } ngOnDestroy() { } ngOnInit() { this.memberService.getAllMembers().subscribe(t => { this.listMembers = t }, t => { console.log(t) }); let t = 0, e = ""; this.dtOptions = { pagingType: "full_numbers", pageLength: 3, displayStart: t, search: { search: e }, serverSide: !0, processing: !0, lengthMenu: [5, 10, 25], ajax: (i, n) => { t = i.start, e = i.search.value, this.loadingData = !0, this.request = this.http.post("http://devazure.eastus.cloudapp.azure.com:8085/api/tasks/search", i, {}).subscribe(t => { this.loadingData = !1, this.tasks = t.data, n({ recordsTotal: t.recordsTotal, recordsFiltered: t.recordsFiltered, data: [] }) }) }, columns: [{ data: "id" }, { data: "title" }, { data: "description" }, { data: "startDate" }, { data: "dueDate" }, { data: "status" }] } } loadAll() { this.taskService.getAllTasks().subscribe(t => { this.tasks = t, this.dtTrigger.next() }, t => { console.log(t) }) } openSeeTaskModal(t) { this.selectedTask = t } openEditTaskModal(t, e) { this.selectedTask = e, console.log(this.selectedTask), this.modalRef = this.modalService.show(t) } openDeleteTaskModal(t, e) { this.selectedTask = e, this.modalRef = this.modalService.show(t) } saveEditedTask() { this.taskService.updateTask(this.selectedTask).subscribe(t => { var e; console.log("Task updated successfully"), this.loadAll(), null === (e = this.modalRef) || void 0 === e || e.hide() }, t => { console.log("Error updating task: ", t) }) } MoveToTrash(t) { this.taskService.hideTask(t).subscribe(() => { console.log("task hide succesfully !"), setTimeout(() => { window.location.reload() }, 1e3) }, t => { console.log(t) }) } isMemberSelected(t) { return this.selectedTask.members.some(e => e.id === t.id) } toggleMemberSelection(t) { const e = this.selectedTask.members.findIndex(e => e.id === t.id); e > -1 ? this.selectedTask.members.splice(e, 1) : this.selectedTask.members.push(t) } } return t.\u0275fac = function (e) { return new (e || t)(Ur(Xp), Ur(Xm), Ur(bm), Ur(vv), Ur(bv)) }, t.\u0275cmp = $t({ type: t, selectors: [["app-list-tasks"]], decls: 58, vars: 9, consts: [[1, "header-title"], [1, "container-fluid"], [1, "row"], [1, "col-sm-12"], [1, "card"], [1, "card-header", "d-flex", "justify-content-between"], [1, "card-body"], [1, "table-responsive"], ["id", "table", "datatable", "", 1, "display", 2, "width", "100%", 3, "dtOptions"], [4, "ngIf"], ["id", "seeTaskModal", "tabindex", "-1", "role", "dialog", "aria-labelledby", "seeTaskModalLabel", "aria-hidden", "true", 1, "modal", "fade"], ["role", "document", 1, "modal-dialog"], [1, "modal-content"], [1, "modal-header"], ["id", "seeTaskModalLabel", 1, "modal-title"], ["type", "button", "data-dismiss", "modal", "aria-label", "Close", 1, "close"], ["aria-hidden", "true"], [1, "modal-body"], [4, "ngFor", "ngForOf"], ["editTaskModal", ""], ["deleteTaskModal", ""], ["colspan", "8", 1, "loading-indicator-cell", 2, "text-align", "center"], ["data-toggle", "modal", "data-target", "#seeTaskModal", 1, "btn", "bg-primary-light", "m-1", 3, "click"], [1, "ri-eye-2-line", "m-1"], [1, "btn", "bg-warning-light", "m-1", 3, "click"], [1, "ri-edit-box-line", "m-1"], [1, "btn", "bg-danger-light", "m-1", "delete-button", 3, "click"], [1, "ri-delete-bin-2-fill", "m-1"], ["id", "editTaskModalLabel", 1, "modal-title"], [1, "form-group"], ["for", "editTitle"], ["type", "text", "id", "editTitle", 1, "form-control", 3, "ngModel", "ngModelOptions", "ngModelChange"], ["for", "editDescription"], ["id", "editDescription", 1, "form-control", 3, "ngModel", "ngModelOptions", "ngModelChange"], ["for", "editStartDate"], ["type", "date", "id", "editStartDate", 1, "form-control", 3, "ngModel", "ngModelOptions", "ngModelChange"], ["for", "editDueDate"], ["type", "date", "id", "editDueDate", 1, "form-control", 3, "ngModel", "ngModelOptions", "ngModelChange"], ["for", "editStatus"], ["id", "editStatus", 1, "form-control", 3, "ngModel", "ngModelOptions", "ngModelChange"], [3, "ngValue", 4, "ngFor", "ngForOf"], ["type", "button", 1, "btn", "btn-primary", 3, "click"], [3, "ngValue"], [1, "form-check"], ["type", "checkbox", 1, "form-check-input", 3, "id", "value", "checked", "change"], [1, "form-check-label", 3, "for"], ["id", "deleteTaskModalLabel", 1, "modal-title"], [1, "modal-footer"], ["type", "button", "data-dismiss", "modal", 1, "btn", "btn-secondary"], ["type", "button", 1, "btn", "btn-danger", 3, "click"]], template: function (t, e) { 1 & t && (Gr(0, "div", 0), Gr(1, "h4"), xo(2, "All tasks"), Zr(), Zr(), Kr(3, "br"), Gr(4, "div", 1), Gr(5, "div", 2), Gr(6, "div", 3), Gr(7, "div", 4), Kr(8, "div", 5), Gr(9, "div", 6), Gr(10, "div", 7), Gr(11, "table", 8), Gr(12, "thead"), Gr(13, "tr"), Gr(14, "th"), xo(15, "ID"), Zr(), Gr(16, "th"), xo(17, "Title"), Zr(), Gr(18, "th"), xo(19, "Description"), Zr(), Gr(20, "th"), xo(21, "Start Date"), Zr(), Gr(22, "th"), xo(23, "Due Date"), Zr(), Gr(24, "th"), xo(25, "Status"), Zr(), Gr(26, "th"), xo(27, "Actions"), Zr(), Zr(), Zr(), zr(28, xv, 4, 0, "tbody", 9), zr(29, kv, 2, 1, "tbody", 9), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Gr(30, "div", 10), Gr(31, "div", 11), Gr(32, "div", 12), Gr(33, "div", 13), Gr(34, "h5", 14), xo(35, "See Task"), Zr(), Gr(36, "button", 15), Gr(37, "span", 16), xo(38, "\xd7"), Zr(), Zr(), Zr(), Gr(39, "div", 17), Gr(40, "p"), xo(41), Zr(), Gr(42, "p"), xo(43), Zr(), Gr(44, "p"), xo(45), Zr(), Gr(46, "p"), xo(47), Zr(), Gr(48, "p"), xo(49), Zr(), Gr(50, "p"), xo(51, "Members:"), Zr(), Gr(52, "ul"), zr(53, Cv, 2, 1, "li", 18), Zr(), Zr(), Zr(), Zr(), Zr(), zr(54, Dv, 37, 17, "ng-template", null, 19, _l), zr(56, Av, 15, 1, "ng-template", null, 20, _l)), 2 & t && (vs(11), Wr("dtOptions", e.dtOptions), vs(17), Wr("ngIf", e.loadingData), vs(1), Wr("ngIf", !e.loadingData), vs(12), ko("Title: ", e.selectedTask.title, ""), vs(2), ko("Description: ", e.selectedTask.description, ""), vs(2), ko("Start Date: ", e.selectedTask.startDate, ""), vs(2), ko("Due Date: ", e.selectedTask.dueDate, ""), vs(2), ko("Status: ", e.selectedTask.status, ""), vs(4), Wr("ngForOf", e.selectedTask.members)) }, directives: [wv, Uc, zc, Ig, ig, Ag, Of, eg, Mg, $g, Ug, Zg], styles: [""] }), t })(), Rv = (() => { class t { constructor(t, e) { this.tokenService = t, this.router = e } ngOnInit() { } logOut() { this.tokenService.signOut(), this.tokenService.remove(), this.router.navigate(["/"]) } } return t.\u0275fac = function (e) { return new (e || t)(Ur(kf), Ur(Xp)) }, t.\u0275cmp = $t({ type: t, selectors: [["app-home-user"]], decls: 119, vars: 0, consts: [[1, "wrapper"], [1, "iq-sidebar", "sidebar-default"], [1, "iq-sidebar-logo", "d-flex", "align-items-center"], ["href", "backend/index.html", 1, "header-logo"], ["src", "assets/images/logo.svg", "alt", "logo"], [1, "logo-title", "light-logo"], [1, "iq-menu-bt-sidebar", "ml-0"], [1, "las", "la-bars", "wrapper-menu"], ["data-scroll", "1", 1, "data-scrollbar"], [1, "iq-sidebar-menu"], ["id", "iq-sidebar-toggle", 1, "iq-menu"], [1, "active"], ["routerLink", "/homeUser/DashbordUser", 1, "svg-icon"], ["width", "25", "height", "25", "xmlns", "http://www.w3.org/2000/svg", "viewBox", "0 0 24 24", "fill", "none", "stroke", "currentColor", "stroke-width", "2", "stroke-linecap", "round", "stroke-linejoin", "round", 1, "svg-icon"], ["d", "M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"], ["points", "9 22 9 12 15 12 15 22"], [1, "ml-4"], [1, ""], ["routerLink", "/homeUser/listProjetUser", 1, "svg-icon"], ["points", "6 9 6 2 18 2 18 9"], ["d", "M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"], ["x", "6", "y", "14", "width", "12", "height", "8"], ["routerLink", "/homeUser/listAllTasks", 1, "svg-icon"], ["d", "M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"], ["x", "8", "y", "2", "width", "8", "height", "4", "rx", "1", "ry", "1"], [1, "pt-5", "pb-2"], [1, "iq-top-navbar"], [1, "iq-navbar-custom"], [1, "navbar", "navbar-expand-lg", "navbar-light", "p-0"], [1, "iq-navbar-logo", "d-flex", "align-items-center", "justify-content-between"], [1, "ri-menu-line", "wrapper-menu"], ["href", "../backend/index.html", 1, "header-logo"], [1, "logo-title", "text-uppercase"], [1, "navbar-breadcrumb"], [1, "d-flex", "align-items-center"], ["type", "button", "data-toggle", "collapse", "data-target", "#navbarSupportedContent", "aria-controls", "navbarSupportedContent", "aria-label", "Toggle navigation", 1, "navbar-toggler"], [1, "ri-menu-3-line"], ["id", "navbarSupportedContent", 1, "collapse", "navbar-collapse"], [1, "navbar-nav", "ml-auto", "navbar-list", "align-items-center"], [1, "iq-search-bar", "device-search"], ["action", "#", 1, "searchbox"], ["href", "#", 1, "search-link"], [1, "ri-search-line"], ["type", "text", "placeholder", "Search here...", 1, "text", "search-input"], [1, "nav-item", "nav-icon", "search-content"], ["href", "#", "id", "dropdownSearch", "data-toggle", "dropdown", "aria-haspopup", "true", "aria-expanded", "false", 1, "search-toggle", "rounded"], ["aria-labelledby", "dropdownSearch", 1, "iq-search-bar", "iq-sub-dropdown", "dropdown-menu"], ["action", "#", 1, "searchbox", "p-2"], [1, "form-group", "mb-0", "position-relative"], ["type", "text", "placeholder", "type here to search...", 1, "text", "search-input", "font-size-12"], [1, "las", "la-search"], [1, "nav-item", "nav-icon", "dropdown", "caption-content"], ["href", "#", "id", "dropdownMenuButton4", "data-toggle", "dropdown", "aria-haspopup", "true", "aria-expanded", "false", 1, "search-toggle", "dropdown-toggle", "d-flex", "align-items-center"], ["src", "assets/images/user/1.jpg", "alt", "user", 1, "img-fluid", "rounded-circle"], [1, "caption", "ml-3"], [1, "mb-0", "line-height"], [1, "las", "la-angle-down", "ml-2"], ["aria-labelledby", "dropdownMenuButton", 1, "dropdown-menu", "dropdown-menu-right", "border-none"], [1, "dropdown-item", "d-flex", "svg-icon"], ["id", "h-01-p", "width", "20", "xmlns", "http://www.w3.org/2000/svg", "fill", "none", "viewBox", "0 0 24 24", "stroke", "currentColor", 1, "svg-icon", "mr-0", "text-primary"], ["stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "2", "d", "M5.121 17.804A13.937 13.937 0 0112 16c2.5 0 4.847.655 6.879 1.804M15 10a3 3 0 11-6 0 3 3 0 016 0zm6 2a9 9 0 11-18 0 9 9 0 0118 0z"], ["href", "../app/user-profile.html"], ["id", "h-02-p", "width", "20", "xmlns", "http://www.w3.org/2000/svg", "fill", "none", "viewBox", "0 0 24 24", "stroke", "currentColor", 1, "svg-icon", "mr-0", "text-primary"], ["stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "2", "d", "M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"], ["href", "../app/user-profile-edit.html"], ["id", "h-03-p", "width", "20", "xmlns", "http://www.w3.org/2000/svg", "fill", "none", "viewBox", "0 0 24 24", "stroke", "currentColor", 1, "svg-icon", "mr-0", "text-primary"], ["stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "2", "d", "M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"], ["stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "2", "d", "M15 12a3 3 0 11-6 0 3 3 0 016 0z"], ["href", "../app/user-account-setting.html"], ["id", "h-04-p", "width", "20", "xmlns", "http://www.w3.org/2000/svg", "fill", "none", "viewBox", "0 0 24 24", "stroke", "currentColor", 1, "svg-icon", "mr-0", "text-primary"], ["stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "2", "d", "M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z"], ["href", "../app/user-privacy-setting.html"], [1, "dropdown-item", "d-flex", "svg-icon", "border-top"], ["id", "h-05-p", "width", "20", "xmlns", "http://www.w3.org/2000/svg", "fill", "none", "viewBox", "0 0 24 24", "stroke", "currentColor", 1, "svg-icon", "mr-0", "text-primary"], ["stroke-linecap", "round", "stroke-linejoin", "round", "stroke-width", "2", "d", "M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1"], [3, "click"], [1, "content-page"], [1, "container-fluid"], [1, "row"], [1, "col-lg-12"], [1, "card-transparent", "mb-0"], [1, "card-header", "d-flex", "align-items-center", "justify-content-between", "p-0", "pb-3"], [1, "card-header-toolbar", "d-flex", "align-items-center"], ["id", "top-project-slick-arrow", 1, "slick-aerrow-block"], [1, "card-body", "p-0"], [1, "iq-footer"], [1, "col-lg-6", "text-end"], [1, "mr-1"], ["href", "https://www.linkedin.com/in/farah-dridi-it-engineer/", 1, ""]], template: function (t, e) { 1 & t && (Gr(0, "div", 0), Gr(1, "div", 1), Gr(2, "div", 2), Gr(3, "a", 3), Kr(4, "img", 4), Gr(5, "h4", 5), xo(6, "Gestion des T\xe2ches"), Zr(), Zr(), Gr(7, "div", 6), Kr(8, "i", 7), Zr(), Zr(), Gr(9, "div", 8), Gr(10, "nav", 9), Gr(11, "ul", 10), Gr(12, "li", 11), Gr(13, "a", 12), si(), Gr(14, "svg", 13), Kr(15, "path", 14), Kr(16, "polyline", 15), Zr(), ri(), Gr(17, "span", 16), xo(18, "Dashboards"), Zr(), Zr(), Zr(), Gr(19, "li", 17), Gr(20, "a", 18), si(), Gr(21, "svg", 13), Kr(22, "polyline", 19), Kr(23, "path", 20), Kr(24, "rect", 21), Zr(), ri(), Gr(25, "span", 16), xo(26, "Projects"), Zr(), Zr(), Zr(), Gr(27, "li", 17), Gr(28, "a", 22), si(), Gr(29, "svg", 13), Kr(30, "path", 23), Kr(31, "rect", 24), Zr(), ri(), Gr(32, "span", 16), xo(33, "All Tasks"), Zr(), Zr(), Zr(), Zr(), Zr(), Kr(34, "div", 25), Zr(), Zr(), Gr(35, "div", 26), Gr(36, "div", 27), Gr(37, "nav", 28), Gr(38, "div", 29), Kr(39, "i", 30), Gr(40, "a", 31), Gr(41, "h4", 32), xo(42, "Gestion des T\xe2ches"), Zr(), Zr(), Zr(), Kr(43, "div", 33), Gr(44, "div", 34), Gr(45, "button", 35), Kr(46, "i", 36), Zr(), Gr(47, "div", 37), Gr(48, "ul", 38), Gr(49, "li"), Gr(50, "div", 39), Gr(51, "form", 40), Gr(52, "a", 41), Kr(53, "i", 42), Zr(), Kr(54, "input", 43), Zr(), Zr(), Zr(), Gr(55, "li", 44), Gr(56, "a", 45), Kr(57, "i", 42), Zr(), Gr(58, "div", 46), Gr(59, "form", 47), Gr(60, "div", 48), Kr(61, "input", 49), Gr(62, "a", 41), Kr(63, "i", 50), Zr(), Zr(), Zr(), Zr(), Zr(), Gr(64, "li", 51), Gr(65, "a", 52), Kr(66, "img", 53), Gr(67, "div", 54), Gr(68, "h6", 55), xo(69, "Test Spring Boot"), Kr(70, "i", 56), Zr(), Zr(), Zr(), Gr(71, "ul", 57), Gr(72, "li", 58), si(), Gr(73, "svg", 59), Kr(74, "path", 60), Zr(), ri(), Gr(75, "a", 61), xo(76, "My Profile"), Zr(), Zr(), Gr(77, "li", 58), si(), Gr(78, "svg", 62), Kr(79, "path", 63), Zr(), ri(), Gr(80, "a", 64), xo(81, "Edit Profile"), Zr(), Zr(), Gr(82, "li", 58), si(), Gr(83, "svg", 65), Kr(84, "path", 66), Kr(85, "path", 67), Zr(), ri(), Gr(86, "a", 68), xo(87, "Account Settings"), Zr(), Zr(), Gr(88, "li", 58), si(), Gr(89, "svg", 69), Kr(90, "path", 70), Zr(), ri(), Gr(91, "a", 71), xo(92, "Privacy Settings"), Zr(), Zr(), Gr(93, "li", 72), si(), Gr(94, "svg", 73), Kr(95, "path", 74), Zr(), ri(), Gr(96, "a", 75), Jr("click", function () { return e.logOut() }), xo(97, "Logout"), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Gr(98, "div", 76), Gr(99, "div", 77), Gr(100, "div", 78), Gr(101, "div", 79), Gr(102, "div", 80), Gr(103, "div", 81), Gr(104, "div", 82), Kr(105, "div", 83), Zr(), Zr(), Gr(106, "div", 84), Kr(107, "router-outlet"), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Gr(108, "footer", 85), Gr(109, "div", 77), Gr(110, "div", 78), Gr(111, "div", 86), Gr(112, "span", 87), xo(113, "\xa9"), Zr(), Gr(114, "a", 88), xo(115, "Dridi Farah"), Zr(), xo(116, " & "), Gr(117, "a", 89), xo(118, "Dridi Farah"), Zr(), Zr(), Zr(), Zr(), Zr()) }, directives: [Jp, Ig, ig, Ag, ef], styles: [""] }), t })(), Mv = (() => { class t { constructor(t) { this.router = t, this.listProjet = [] } ngOnInit() { } seeTaskProjet() { this.router.navigate(["homeUser/listTasksParProject/1"]) } } return t.\u0275fac = function (e) { return new (e || t)(Ur(Xp)) }, t.\u0275cmp = $t({ type: t, selectors: [["app-list-projet-user"]], decls: 57, vars: 0, consts: [[1, "container-fluid"], [1, "row"], [1, "col-lg-12"], [1, "card"], [1, "card-body"], [1, "d-flex", "flex-wrap", "align-items-center", "justify-content-between", "breadcrumb-content"], [1, "d-flex", "flex-wrap", "align-items-center", "justify-content-between"], [1, "dropdown", "status-dropdown", "mr-3"], ["id", "dropdownMenuButton03", "data-toggle", "dropdown", 1, "dropdown-toggle"], [1, "btn", "bg-body"], [1, "h6"], [1, "ri-arrow-down-s-line", "ml-2", "mr-0"], ["aria-labelledby", "dropdownMenuButton03", 1, "dropdown-menu", "dropdown-menu-right"], ["href", "#", 1, "dropdown-item"], [1, "ri-mic-line", "mr-2"], [1, "ri-attachment-line", "mr-2"], [1, "ri-file-copy-line", "mr-2"], [1, "list-grid-toggle", "d-flex", "align-items-center", "mr-3"], ["data-toggle-extra", "tab", "data-target-extra", "#grid", 1, "active"], [1, "grid-icon", "mr-3"], ["width", "20", "height", "20", "xmlns", "http://www.w3.org/2000/svg", "viewBox", "0 0 24 24", "fill", "none", "stroke", "currentColor", "stroke-width", "2", "stroke-linecap", "round", "stroke-linejoin", "round"], ["x", "3", "y", "3", "width", "7", "height", "7"], ["x", "14", "y", "3", "width", "7", "height", "7"], ["x", "14", "y", "14", "width", "7", "height", "7"], ["x", "3", "y", "14", "width", "7", "height", "7"], ["data-toggle-extra", "tab", "data-target-extra", "#list"], [1, "grid-icon"], ["x1", "21", "y1", "10", "x2", "3", "y2", "10"], ["x1", "21", "y1", "6", "x2", "3", "y2", "6"], ["x1", "21", "y1", "14", "x2", "3", "y2", "14"], ["x1", "21", "y1", "18", "x2", "3", "y2", "18"], [1, "pl-3", "border-left", "btn-new"], ["href", "#", "data-target", "#new-project-modal", "data-toggle", "modal", 1, "btn", "btn-primary"], ["id", "grid", "data-toggle-extra", "tab-content", 1, "item-content", "animate__animated", "animate__fadeIn", "active"], [1, "col-lg-4", "col-md-6"], [1, "card", "card-block", "card-stretch", "card-height"], [1, "mb-1"], [1, "mb-3"], [1, "d-flex", "justify-content-end", "pt-3", "border-top"], [1, "iq-media-group"], [1, "btn", "btn-white", "text-primary", "link-shadow", 3, "click"]], template: function (t, e) { 1 & t && (Gr(0, "div", 0), Gr(1, "div", 1), Gr(2, "div", 2), Gr(3, "div", 3), Gr(4, "div", 4), Gr(5, "div", 5), Gr(6, "h5"), xo(7, "Your Projects"), Zr(), Gr(8, "div", 6), Gr(9, "div", 7), Gr(10, "div", 8), Gr(11, "div", 9), Gr(12, "span", 10), xo(13, "Status :"), Zr(), xo(14, " In Progress"), Kr(15, "i", 11), Zr(), Zr(), Gr(16, "div", 12), Gr(17, "a", 13), Kr(18, "i", 14), xo(19, "In Progress"), Zr(), Gr(20, "a", 13), Kr(21, "i", 15), xo(22, "Priority"), Zr(), Gr(23, "a", 13), Kr(24, "i", 16), xo(25, "Category"), Zr(), Zr(), Zr(), Gr(26, "div", 17), Gr(27, "div", 18), Gr(28, "div", 19), si(), Gr(29, "svg", 20), Kr(30, "rect", 21), Kr(31, "rect", 22), Kr(32, "rect", 23), Kr(33, "rect", 24), Zr(), Zr(), Zr(), ri(), Gr(34, "div", 25), Gr(35, "div", 26), si(), Gr(36, "svg", 20), Kr(37, "line", 27), Kr(38, "line", 28), Kr(39, "line", 29), Kr(40, "line", 30), Zr(), Zr(), Zr(), Zr(), ri(), Gr(41, "div", 31), Gr(42, "a", 32), xo(43, "New Project"), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Gr(44, "div", 33), Gr(45, "div", 1), Gr(46, "div", 34), Gr(47, "div", 35), Gr(48, "div", 4), Gr(49, "h5", 36), xo(50, "Titre du projet "), Zr(), Gr(51, "p", 37), xo(52, "Description:Preparing framework of block-based WordPress Theme."), Zr(), Gr(53, "div", 38), Gr(54, "div", 39), Gr(55, "a", 40), Jr("click", function () { return e.seeTaskProjet() }), xo(56, "SEE"), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr()) }, styles: [""] }), t })(); function Iv(t) { return null != t && "false" != `${t}` } function Lv(t, e = 0) { return function (t) { return !isNaN(parseFloat(t)) && !isNaN(Number(t)) }(t) ? Number(t) : e } function Fv(t) { return Array.isArray(t) ? t : [t] } function Nv(t) { return null == t ? "" : "string" == typeof t ? t : `${t}px` } function jv(t) { return t instanceof Ko ? t.nativeElement : t } class Vv { constructor(t, e) { this.compare = t, this.keySelector = e } call(t, e) { return e.subscribe(new Bv(t, this.compare, this.keySelector)) } } class Bv extends f { constructor(t, e, i) { super(t), this.keySelector = i, this.hasKey = !1, "function" == typeof e && (this.compare = e) } compare(t, e) { return t === e } _next(t) { let e; try { const { keySelector: i } = this; e = i ? i(t) : t } catch (n) { return this.destination.error(n) } let i = !1; if (this.hasKey) try { const { compare: t } = this; i = t(this.key, e) } catch (n) { return this.destination.error(n) } else this.hasKey = !0; i || (this.key = e, this.destination.next(t)) } } const Hv = new h_(a_); class zv { constructor(t) { this.durationSelector = t } call(t, e) { return e.subscribe(new $v(t, this.durationSelector)) } } class $v extends j { constructor(t, e) { super(t), this.durationSelector = e, this.hasValue = !1 } _next(t) { if (this.value = t, this.hasValue = !0, !this.throttled) { let i; try { const { durationSelector: e } = this; i = e(t) } catch (e) { return this.destination.error(e) } const n = V(i, new N(this)); !n || n.closed ? this.clearThrottle() : this.add(this.throttled = n) } } clearThrottle() { const { value: t, hasValue: e, throttled: i } = this; i && (this.remove(i), this.throttled = void 0, i.unsubscribe()), e && (this.value = void 0, this.hasValue = !1, this.destination.next(t)) } notifyNext() { this.clearThrottle() } notifyComplete() { this.clearThrottle() } } function Uv(t) { return !l(t) && t - parseFloat(t) + 1 >= 0 } function Wv(t) { const { index: e, period: i, subscriber: n } = t; if (n.next(e), !n.closed) { if (-1 === i) return n.complete(); t.index = e + 1, this.schedule(t, i) } } function qv(t, e = Hv) { return i = () => function (t = 0, e, i) { let n = -1; return Uv(e) ? n = Number(e) < 1 ? 1 : Number(e) : C(e) && (i = e), C(i) || (i = Hv), new v(e => { const s = Uv(t) ? t : +t - i.now(); return i.schedule(Wv, s, { index: 0, period: n, subscriber: e }) }) }(t, e), function (t) { return t.lift(new zv(i)) }; var i } function Gv(t) { return e => e.lift(new Zv(t)) } class Zv { constructor(t) { this.notifier = t } call(t, e) { const i = new Kv(t), n = V(this.notifier, new N(i)); return n && !i.seenValue ? (i.add(n), e.subscribe(i)) : i } } class Kv extends j { constructor(t) { super(t), this.seenValue = !1 } notifyNext() { this.seenValue = !0, this.complete() } notifyComplete() { } } let Yv; try { Yv = "undefined" != typeof Intl && Intl.v8BreakIterator } catch (SM) { Yv = !1 } let Qv, Xv, Jv, ty = (() => { class t { constructor(t) { this._platformId = t, this.isBrowser = this._platformId ? Zc(this._platformId) : "object" == typeof document && !!document, this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent), this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent), this.BLINK = this.isBrowser && !(!window.chrome && !Yv) && "undefined" != typeof CSS && !this.EDGE && !this.TRIDENT, this.WEBKIT = this.isBrowser && /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT, this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !("MSStream" in window), this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent), this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT, this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT } } return t.\u0275fac = function (e) { return new (e || t)(hn(kl)) }, t.\u0275prov = dt({ factory: function () { return new t(hn(kl)) }, token: t, providedIn: "root" }), t })(), ey = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Gt({ type: t }), t.\u0275inj = pt({}), t })(); function iy(t) { return function () { if (null == Qv && "undefined" != typeof window) try { window.addEventListener("test", null, Object.defineProperty({}, "passive", { get: () => Qv = !0 })) } finally { Qv = Qv || !1 } return Qv }() ? t : !!t.capture } function ny() { if (null == Xv) { if ("object" != typeof document || !document || "function" != typeof Element || !Element) return Xv = !1, Xv; if ("scrollBehavior" in document.documentElement.style) Xv = !0; else { const t = Element.prototype.scrollTo; Xv = !!t && !/\{\s*\[native code\]\s*\}/.test(t.toString()) } } return Xv } function sy(t) { if (function () { if (null == Jv) { const t = "undefined" != typeof document ? document.head : null; Jv = !(!t || !t.createShadowRoot && !t.attachShadow) } return Jv }()) { const e = t.getRootNode ? t.getRootNode() : null; if ("undefined" != typeof ShadowRoot && ShadowRoot && e instanceof ShadowRoot) return e } return null } function ry() { let t = "undefined" != typeof document && document ? document.activeElement : null; for (; t && t.shadowRoot;) { const e = t.shadowRoot.activeElement; if (e === t) break; t = e } return t } function oy(t) { return t.composedPath ? t.composedPath()[0] : t.target } function ay() { return "undefined" != typeof __karma__ && !!__karma__ || "undefined" != typeof jasmine && !!jasmine || "undefined" != typeof jest && !!jest || "undefined" != typeof Mocha && !!Mocha } const ly = new Wi("cdk-dir-doc", { providedIn: "root", factory: function () { return un(vc) } }); let cy = (() => { class t { constructor(t) { if (this.value = "ltr", this.change = new Ja, t) { const e = t.documentElement ? t.documentElement.dir : null, i = (t.body ? t.body.dir : null) || e; this.value = "ltr" === i || "rtl" === i ? i : "ltr" } } ngOnDestroy() { this.change.complete() } } return t.\u0275fac = function (e) { return new (e || t)(hn(ly, 8)) }, t.\u0275prov = dt({ factory: function () { return new t(hn(ly, 8)) }, token: t, providedIn: "root" }), t })(), hy = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Gt({ type: t }), t.\u0275inj = pt({}), t })(), uy = (() => { class t { constructor(t, e, i) { this._ngZone = t, this._platform = e, this._scrolled = new S, this._globalSubscription = null, this._scrolledCount = 0, this.scrollContainers = new Map, this._document = i } register(t) { this.scrollContainers.has(t) || this.scrollContainers.set(t, t.elementScrolled().subscribe(() => this._scrolled.next(t))) } deregister(t) { const e = this.scrollContainers.get(t); e && (e.unsubscribe(), this.scrollContainers.delete(t)) } scrolled(t = 20) { return this._platform.isBrowser ? new v(e => { this._globalSubscription || this._addGlobalListener(); const i = t > 0 ? this._scrolled.pipe(qv(t)).subscribe(e) : this._scrolled.subscribe(e); return this._scrolledCount++, () => { i.unsubscribe(), this._scrolledCount--, this._scrolledCount || this._removeGlobalListener() } }) : Dh() } ngOnDestroy() { this._removeGlobalListener(), this.scrollContainers.forEach((t, e) => this.deregister(e)), this._scrolled.complete() } ancestorScrolled(t, e) { const i = this.getAncestorScrollContainers(t); return this.scrolled(e).pipe(Jh(t => !t || i.indexOf(t) > -1)) } getAncestorScrollContainers(t) { const e = []; return this.scrollContainers.forEach((i, n) => { this._scrollableContainsElement(n, t) && e.push(n) }), e } _getWindow() { return this._document.defaultView || window } _scrollableContainsElement(t, e) { let i = jv(e), n = t.getElementRef().nativeElement; do { if (i == n) return !0 } while (i = i.parentElement); return !1 } _addGlobalListener() { this._globalSubscription = this._ngZone.runOutsideAngular(() => s_(this._getWindow().document, "scroll").subscribe(() => this._scrolled.next())) } _removeGlobalListener() { this._globalSubscription && (this._globalSubscription.unsubscribe(), this._globalSubscription = null) } } return t.\u0275fac = function (e) { return new (e || t)(hn(Vl), hn(ty), hn(vc, 8)) }, t.\u0275prov = dt({ factory: function () { return new t(hn(Vl), hn(ty), hn(vc, 8)) }, token: t, providedIn: "root" }), t })(), dy = (() => { class t { constructor(t, e, i) { this._platform = t, this._change = new S, this._changeListener = t => { this._change.next(t) }, this._document = i, e.runOutsideAngular(() => { if (t.isBrowser) { const t = this._getWindow(); t.addEventListener("resize", this._changeListener), t.addEventListener("orientationchange", this._changeListener) } this.change().subscribe(() => this._viewportSize = null) }) } ngOnDestroy() { if (this._platform.isBrowser) { const t = this._getWindow(); t.removeEventListener("resize", this._changeListener), t.removeEventListener("orientationchange", this._changeListener) } this._change.complete() } getViewportSize() { this._viewportSize || this._updateViewportSize(); const t = { width: this._viewportSize.width, height: this._viewportSize.height }; return this._platform.isBrowser || (this._viewportSize = null), t } getViewportRect() { const t = this.getViewportScrollPosition(), { width: e, height: i } = this.getViewportSize(); return { top: t.top, left: t.left, bottom: t.top + i, right: t.left + e, height: i, width: e } } getViewportScrollPosition() { if (!this._platform.isBrowser) return { top: 0, left: 0 }; const t = this._document, e = this._getWindow(), i = t.documentElement, n = i.getBoundingClientRect(); return { top: -n.top || t.body.scrollTop || e.scrollY || i.scrollTop || 0, left: -n.left || t.body.scrollLeft || e.scrollX || i.scrollLeft || 0 } } change(t = 20) { return t > 0 ? this._change.pipe(qv(t)) : this._change } _getWindow() { return this._document.defaultView || window } _updateViewportSize() { const t = this._getWindow(); this._viewportSize = this._platform.isBrowser ? { width: t.innerWidth, height: t.innerHeight } : { width: 0, height: 0 } } } return t.\u0275fac = function (e) { return new (e || t)(hn(ty), hn(Vl), hn(vc, 8)) }, t.\u0275prov = dt({ factory: function () { return new t(hn(ty), hn(Vl), hn(vc, 8)) }, token: t, providedIn: "root" }), t })(), py = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Gt({ type: t }), t.\u0275inj = pt({}), t })(), fy = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Gt({ type: t }), t.\u0275inj = pt({ imports: [[hy, ey, py], hy, py] }), t })(); class gy { constructor(t) { this.total = t } call(t, e) { return e.subscribe(new my(t, this.total)) } } class my extends f { constructor(t, e) { super(t), this.total = e, this.count = 0 } _next(t) { ++this.count > this.total && this.destination.next(t) } } let _y = (() => { class t { constructor(t) { this._platform = t } isDisabled(t) { return t.hasAttribute("disabled") } isVisible(t) { return function (t) { return !!(t.offsetWidth || t.offsetHeight || "function" == typeof t.getClientRects && t.getClientRects().length) }(t) && "visible" === getComputedStyle(t).visibility } isTabbable(t) { if (!this._platform.isBrowser) return !1; const e = function (t) { try { return t.frameElement } catch (SM) { return null } }((i = t).ownerDocument && i.ownerDocument.defaultView || window); var i; if (e) { if (-1 === yy(e)) return !1; if (!this.isVisible(e)) return !1 } let n = t.nodeName.toLowerCase(), s = yy(t); return t.hasAttribute("contenteditable") ? -1 !== s : "iframe" !== n && "object" !== n && !(this._platform.WEBKIT && this._platform.IOS && !function (t) { let e = t.nodeName.toLowerCase(), i = "input" === e && t.type; return "text" === i || "password" === i || "select" === e || "textarea" === e }(t)) && ("audio" === n ? !!t.hasAttribute("controls") && -1 !== s : "video" === n ? -1 !== s && (null !== s || this._platform.FIREFOX || t.hasAttribute("controls")) : t.tabIndex >= 0) } isFocusable(t, e) { return function (t) { return !function (t) { return function (t) { return "input" == t.nodeName.toLowerCase() }(t) && "hidden" == t.type }(t) && (function (t) { let e = t.nodeName.toLowerCase(); return "input" === e || "select" === e || "button" === e || "textarea" === e }(t) || function (t) { return function (t) { return "a" == t.nodeName.toLowerCase() }(t) && t.hasAttribute("href") }(t) || t.hasAttribute("contenteditable") || vy(t)) }(t) && !this.isDisabled(t) && ((null == e ? void 0 : e.ignoreVisibility) || this.isVisible(t)) } } return t.\u0275fac = function (e) { return new (e || t)(hn(ty)) }, t.\u0275prov = dt({ factory: function () { return new t(hn(ty)) }, token: t, providedIn: "root" }), t })(); function vy(t) { if (!t.hasAttribute("tabindex") || void 0 === t.tabIndex) return !1; let e = t.getAttribute("tabindex"); return "-32768" != e && !(!e || isNaN(parseInt(e, 10))) } function yy(t) { if (!vy(t)) return null; const e = parseInt(t.getAttribute("tabindex") || "", 10); return isNaN(e) ? -1 : e } class by { constructor(t, e, i, n, s = !1) { this._element = t, this._checker = e, this._ngZone = i, this._document = n, this._hasAttached = !1, this.startAnchorListener = () => this.focusLastTabbableElement(), this.endAnchorListener = () => this.focusFirstTabbableElement(), this._enabled = !0, s || this.attachAnchors() } get enabled() { return this._enabled } set enabled(t) { this._enabled = t, this._startAnchor && this._endAnchor && (this._toggleAnchorTabIndex(t, this._startAnchor), this._toggleAnchorTabIndex(t, this._endAnchor)) } destroy() { const t = this._startAnchor, e = this._endAnchor; t && (t.removeEventListener("focus", this.startAnchorListener), t.parentNode && t.parentNode.removeChild(t)), e && (e.removeEventListener("focus", this.endAnchorListener), e.parentNode && e.parentNode.removeChild(e)), this._startAnchor = this._endAnchor = null, this._hasAttached = !1 } attachAnchors() { return !!this._hasAttached || (this._ngZone.runOutsideAngular(() => { this._startAnchor || (this._startAnchor = this._createAnchor(), this._startAnchor.addEventListener("focus", this.startAnchorListener)), this._endAnchor || (this._endAnchor = this._createAnchor(), this._endAnchor.addEventListener("focus", this.endAnchorListener)) }), this._element.parentNode && (this._element.parentNode.insertBefore(this._startAnchor, this._element), this._element.parentNode.insertBefore(this._endAnchor, this._element.nextSibling), this._hasAttached = !0), this._hasAttached) } focusInitialElementWhenReady(t) { return new Promise(e => { this._executeOnStable(() => e(this.focusInitialElement(t))) }) } focusFirstTabbableElementWhenReady(t) { return new Promise(e => { this._executeOnStable(() => e(this.focusFirstTabbableElement(t))) }) } focusLastTabbableElementWhenReady(t) { return new Promise(e => { this._executeOnStable(() => e(this.focusLastTabbableElement(t))) }) } _getRegionBoundary(t) { let e = this._element.querySelectorAll(`[cdk-focus-region-${t}], [cdkFocusRegion${t}], [cdk-focus-${t}]`); for (let i = 0; i < e.length; i++)e[i].hasAttribute(`cdk-focus-${t}`) ? console.warn(`Found use of deprecated attribute 'cdk-focus-${t}', use 'cdkFocusRegion${t}' instead. The deprecated attribute will be removed in 8.0.0.`, e[i]) : e[i].hasAttribute(`cdk-focus-region-${t}`) && console.warn(`Found use of deprecated attribute 'cdk-focus-region-${t}', use 'cdkFocusRegion${t}' instead. The deprecated attribute will be removed in 8.0.0.`, e[i]); return "start" == t ? e.length ? e[0] : this._getFirstTabbableElement(this._element) : e.length ? e[e.length - 1] : this._getLastTabbableElement(this._element) } focusInitialElement(t) { const e = this._element.querySelector("[cdk-focus-initial], [cdkFocusInitial]"); if (e) { if (e.hasAttribute("cdk-focus-initial") && console.warn("Found use of deprecated attribute 'cdk-focus-initial', use 'cdkFocusInitial' instead. The deprecated attribute will be removed in 8.0.0", e), !this._checker.isFocusable(e)) { const i = this._getFirstTabbableElement(e); return null == i || i.focus(t), !!i } return e.focus(t), !0 } return this.focusFirstTabbableElement(t) } focusFirstTabbableElement(t) { const e = this._getRegionBoundary("start"); return e && e.focus(t), !!e } focusLastTabbableElement(t) { const e = this._getRegionBoundary("end"); return e && e.focus(t), !!e } hasAttached() { return this._hasAttached } _getFirstTabbableElement(t) { if (this._checker.isFocusable(t) && this._checker.isTabbable(t)) return t; let e = t.children || t.childNodes; for (let i = 0; i < e.length; i++) { let t = e[i].nodeType === this._document.ELEMENT_NODE ? this._getFirstTabbableElement(e[i]) : null; if (t) return t } return null } _getLastTabbableElement(t) { if (this._checker.isFocusable(t) && this._checker.isTabbable(t)) return t; let e = t.children || t.childNodes; for (let i = e.length - 1; i >= 0; i--) { let t = e[i].nodeType === this._document.ELEMENT_NODE ? this._getLastTabbableElement(e[i]) : null; if (t) return t } return null } _createAnchor() { const t = this._document.createElement("div"); return this._toggleAnchorTabIndex(this._enabled, t), t.classList.add("cdk-visually-hidden"), t.classList.add("cdk-focus-trap-anchor"), t.setAttribute("aria-hidden", "true"), t } _toggleAnchorTabIndex(t, e) { t ? e.setAttribute("tabindex", "0") : e.removeAttribute("tabindex") } toggleAnchors(t) { this._startAnchor && this._endAnchor && (this._toggleAnchorTabIndex(t, this._startAnchor), this._toggleAnchorTabIndex(t, this._endAnchor)) } _executeOnStable(t) { this._ngZone.isStable ? t() : this._ngZone.onStable.pipe(qh(1)).subscribe(t) } } let wy = (() => { class t { constructor(t, e, i) { this._checker = t, this._ngZone = e, this._document = i } create(t, e = !1) { return new by(t, this._checker, this._ngZone, this._document, e) } } return t.\u0275fac = function (e) { return new (e || t)(hn(_y), hn(Vl), hn(vc)) }, t.\u0275prov = dt({ factory: function () { return new t(hn(_y), hn(Vl), hn(vc)) }, token: t, providedIn: "root" }), t })(); function xy(t) { return 0 === t.offsetX && 0 === t.offsetY } function Sy(t) { const e = t.touches && t.touches[0] || t.changedTouches && t.changedTouches[0]; return !(!e || -1 !== e.identifier || null != e.radiusX && 1 !== e.radiusX || null != e.radiusY && 1 !== e.radiusY) } "undefined" != typeof Element && Element; const ky = new Wi("cdk-input-modality-detector-options"), Cy = { ignoreKeys: [18, 17, 224, 91, 16] }, Ey = iy({ passive: !0, capture: !0 }); let Ty = (() => { class t { constructor(t, e, i, n) { this._platform = t, this._mostRecentTarget = null, this._modality = new Ah(null), this._lastTouchMs = 0, this._onKeydown = t => { var e, i; (null === (i = null === (e = this._options) || void 0 === e ? void 0 : e.ignoreKeys) || void 0 === i ? void 0 : i.some(e => e === t.keyCode)) || (this._modality.next("keyboard"), this._mostRecentTarget = oy(t)) }, this._onMousedown = t => { Date.now() - this._lastTouchMs < 650 || (this._modality.next(xy(t) ? "keyboard" : "mouse"), this._mostRecentTarget = oy(t)) }, this._onTouchstart = t => { Sy(t) ? this._modality.next("keyboard") : (this._lastTouchMs = Date.now(), this._modality.next("touch"), this._mostRecentTarget = oy(t)) }, this._options = Object.assign(Object.assign({}, Cy), n), this.modalityDetected = this._modality.pipe(t => t.lift(new gy(1))), this.modalityChanged = this.modalityDetected.pipe(t => t.lift(new Vv(void 0, void 0))), t.isBrowser && e.runOutsideAngular(() => { i.addEventListener("keydown", this._onKeydown, Ey), i.addEventListener("mousedown", this._onMousedown, Ey), i.addEventListener("touchstart", this._onTouchstart, Ey) }) } get mostRecentModality() { return this._modality.value } ngOnDestroy() { this._modality.complete(), this._platform.isBrowser && (document.removeEventListener("keydown", this._onKeydown, Ey), document.removeEventListener("mousedown", this._onMousedown, Ey), document.removeEventListener("touchstart", this._onTouchstart, Ey)) } } return t.\u0275fac = function (e) { return new (e || t)(hn(ty), hn(Vl), hn(vc), hn(ky, 8)) }, t.\u0275prov = dt({ factory: function () { return new t(hn(ty), hn(Vl), hn(vc), hn(ky, 8)) }, token: t, providedIn: "root" }), t })(); const Py = new Wi("cdk-focus-monitor-default-options"), Dy = iy({ passive: !0, capture: !0 }); let Ay = (() => { class t { constructor(t, e, i, n, s) { this._ngZone = t, this._platform = e, this._inputModalityDetector = i, this._origin = null, this._windowFocused = !1, this._originFromTouchInteraction = !1, this._elementInfo = new Map, this._monitoredElementCount = 0, this._rootNodeFocusListenerCount = new Map, this._windowFocusListener = () => { this._windowFocused = !0, this._windowFocusTimeoutId = setTimeout(() => this._windowFocused = !1) }, this._stopInputModalityDetector = new S, this._rootNodeFocusAndBlurListener = t => { const e = oy(t), i = "focus" === t.type ? this._onFocus : this._onBlur; for (let n = e; n; n = n.parentElement)i.call(this, t, n) }, this._document = n, this._detectionMode = (null == s ? void 0 : s.detectionMode) || 0 } monitor(t, e = !1) { const i = jv(t); if (!this._platform.isBrowser || 1 !== i.nodeType) return Dh(null); const n = sy(i) || this._getDocument(), s = this._elementInfo.get(i); if (s) return e && (s.checkChildren = !0), s.subject; const r = { checkChildren: e, subject: new S, rootNode: n }; return this._elementInfo.set(i, r), this._registerGlobalListeners(r), r.subject } stopMonitoring(t) { const e = jv(t), i = this._elementInfo.get(e); i && (i.subject.complete(), this._setClasses(e), this._elementInfo.delete(e), this._removeGlobalListeners(i)) } focusVia(t, e, i) { const n = jv(t); n === this._getDocument().activeElement ? this._getClosestElementsInfo(n).forEach(([t, i]) => this._originChanged(t, e, i)) : (this._setOrigin(e), "function" == typeof n.focus && n.focus(i)) } ngOnDestroy() { this._elementInfo.forEach((t, e) => this.stopMonitoring(e)) } _getDocument() { return this._document || document } _getWindow() { return this._getDocument().defaultView || window } _toggleClass(t, e, i) { i ? t.classList.add(e) : t.classList.remove(e) } _getFocusOrigin(t) { return this._origin ? this._originFromTouchInteraction ? this._shouldBeAttributedToTouch(t) ? "touch" : "program" : this._origin : this._windowFocused && this._lastFocusOrigin ? this._lastFocusOrigin : "program" } _shouldBeAttributedToTouch(t) { return 1 === this._detectionMode || !!(null == t ? void 0 : t.contains(this._inputModalityDetector._mostRecentTarget)) } _setClasses(t, e) { this._toggleClass(t, "cdk-focused", !!e), this._toggleClass(t, "cdk-touch-focused", "touch" === e), this._toggleClass(t, "cdk-keyboard-focused", "keyboard" === e), this._toggleClass(t, "cdk-mouse-focused", "mouse" === e), this._toggleClass(t, "cdk-program-focused", "program" === e) } _setOrigin(t, e = !1) { this._ngZone.runOutsideAngular(() => { this._origin = t, this._originFromTouchInteraction = "touch" === t && e, 0 === this._detectionMode && (clearTimeout(this._originTimeoutId), this._originTimeoutId = setTimeout(() => this._origin = null, this._originFromTouchInteraction ? 650 : 1)) }) } _onFocus(t, e) { const i = this._elementInfo.get(e), n = oy(t); i && (i.checkChildren || e === n) && this._originChanged(e, this._getFocusOrigin(n), i) } _onBlur(t, e) { const i = this._elementInfo.get(e); !i || i.checkChildren && t.relatedTarget instanceof Node && e.contains(t.relatedTarget) || (this._setClasses(e), this._emitOrigin(i.subject, null)) } _emitOrigin(t, e) { this._ngZone.run(() => t.next(e)) } _registerGlobalListeners(t) { if (!this._platform.isBrowser) return; const e = t.rootNode, i = this._rootNodeFocusListenerCount.get(e) || 0; i || this._ngZone.runOutsideAngular(() => { e.addEventListener("focus", this._rootNodeFocusAndBlurListener, Dy), e.addEventListener("blur", this._rootNodeFocusAndBlurListener, Dy) }), this._rootNodeFocusListenerCount.set(e, i + 1), 1 == ++this._monitoredElementCount && (this._ngZone.runOutsideAngular(() => { this._getWindow().addEventListener("focus", this._windowFocusListener) }), this._inputModalityDetector.modalityDetected.pipe(Gv(this._stopInputModalityDetector)).subscribe(t => { this._setOrigin(t, !0) })) } _removeGlobalListeners(t) { const e = t.rootNode; if (this._rootNodeFocusListenerCount.has(e)) { const t = this._rootNodeFocusListenerCount.get(e); t > 1 ? this._rootNodeFocusListenerCount.set(e, t - 1) : (e.removeEventListener("focus", this._rootNodeFocusAndBlurListener, Dy), e.removeEventListener("blur", this._rootNodeFocusAndBlurListener, Dy), this._rootNodeFocusListenerCount.delete(e)) } --this._monitoredElementCount || (this._getWindow().removeEventListener("focus", this._windowFocusListener), this._stopInputModalityDetector.next(), clearTimeout(this._windowFocusTimeoutId), clearTimeout(this._originTimeoutId)) } _originChanged(t, e, i) { this._setClasses(t, e), this._emitOrigin(i.subject, e), this._lastFocusOrigin = e } _getClosestElementsInfo(t) { const e = []; return this._elementInfo.forEach((i, n) => { (n === t || i.checkChildren && n.contains(t)) && e.push([n, i]) }), e } } return t.\u0275fac = function (e) { return new (e || t)(hn(Vl), hn(ty), hn(Ty), hn(vc, 8), hn(Py, 8)) }, t.\u0275prov = dt({ factory: function () { return new t(hn(Vl), hn(ty), hn(Ty), hn(vc, 8), hn(Py, 8)) }, token: t, providedIn: "root" }), t })(); const Oy = "cdk-high-contrast-black-on-white", Ry = "cdk-high-contrast-white-on-black", My = "cdk-high-contrast-active"; let Iy = (() => { class t { constructor(t, e) { this._platform = t, this._document = e } getHighContrastMode() { if (!this._platform.isBrowser) return 0; const t = this._document.createElement("div"); t.style.backgroundColor = "rgb(1,2,3)", t.style.position = "absolute", this._document.body.appendChild(t); const e = this._document.defaultView || window, i = e && e.getComputedStyle ? e.getComputedStyle(t) : null, n = (i && i.backgroundColor || "").replace(/ /g, ""); switch (this._document.body.removeChild(t), n) { case "rgb(0,0,0)": return 2; case "rgb(255,255,255)": return 1 }return 0 } _applyBodyHighContrastModeCssClasses() { if (!this._hasCheckedHighContrastMode && this._platform.isBrowser && this._document.body) { const t = this._document.body.classList; t.remove(My), t.remove(Oy), t.remove(Ry), this._hasCheckedHighContrastMode = !0; const e = this.getHighContrastMode(); 1 === e ? (t.add(My), t.add(Oy)) : 2 === e && (t.add(My), t.add(Ry)) } } } return t.\u0275fac = function (e) { return new (e || t)(hn(ty), hn(vc)) }, t.\u0275prov = dt({ factory: function () { return new t(hn(ty), hn(vc)) }, token: t, providedIn: "root" }), t })(); function Ly(t) { const { subscriber: e, counter: i, period: n } = t; e.next(i), this.schedule({ subscriber: e, counter: i + 1, period: n }, n) } function Fy(t, e, i) { for (let n in e) if (e.hasOwnProperty(n)) { const s = e[n]; s ? t.setProperty(n, s, (null == i ? void 0 : i.has(n)) ? "important" : "") : t.removeProperty(n) } return t } function Ny(t, e) { const i = e ? "" : "none"; Fy(t.style, { "touch-action": e ? "" : "none", "-webkit-user-drag": e ? "" : "none", "-webkit-tap-highlight-color": e ? "" : "transparent", "user-select": i, "-ms-user-select": i, "-webkit-user-select": i, "-moz-user-select": i }) } function jy(t, e, i) { Fy(t.style, { position: e ? "" : "fixed", top: e ? "" : "0", opacity: e ? "" : "0", left: e ? "" : "-999em" }, i) } function Vy(t, e) { return e && "none" != e ? t + " " + e : t } function By(t) { const e = t.toLowerCase().indexOf("ms") > -1 ? 1 : 1e3; return parseFloat(t) * e } function Hy(t, e) { return t.getPropertyValue(e).split(",").map(t => t.trim()) } function zy(t) { const e = t.getBoundingClientRect(); return { top: e.top, right: e.right, bottom: e.bottom, left: e.left, width: e.width, height: e.height } } function $y(t, e, i) { const { top: n, bottom: s, left: r, right: o } = t; return i >= n && i <= s && e >= r && e <= o } function Uy(t, e, i) { t.top += e, t.bottom = t.top + t.height, t.left += i, t.right = t.left + t.width } function Wy(t, e, i, n) { const { top: s, right: r, bottom: o, left: a, width: l, height: c } = t, h = l * e, u = c * e; return n > s - u && n < o + u && i > a - h && i < r + h } class qy { constructor(t, e) { this._document = t, this._viewportRuler = e, this.positions = new Map } clear() { this.positions.clear() } cache(t) { this.clear(), this.positions.set(this._document, { scrollPosition: this._viewportRuler.getViewportScrollPosition() }), t.forEach(t => { this.positions.set(t, { scrollPosition: { top: t.scrollTop, left: t.scrollLeft }, clientRect: zy(t) }) }) } handleScroll(t) { const e = oy(t), i = this.positions.get(e); if (!i) return null; const n = e === this._document ? e.documentElement : e, s = i.scrollPosition; let r, o; if (e === this._document) { const t = this._viewportRuler.getViewportScrollPosition(); r = t.top, o = t.left } else r = e.scrollTop, o = e.scrollLeft; const a = s.top - r, l = s.left - o; return this.positions.forEach((t, i) => { t.clientRect && e !== i && n.contains(i) && Uy(t.clientRect, a, l) }), s.top = r, s.left = o, { top: a, left: l } } } function Gy(t) { const e = t.cloneNode(!0), i = e.querySelectorAll("[id]"), n = t.nodeName.toLowerCase(); e.removeAttribute("id"); for (let s = 0; s < i.length; s++)i[s].removeAttribute("id"); return "canvas" === n ? Qy(t, e) : "input" !== n && "select" !== n && "textarea" !== n || Yy(t, e), Zy("canvas", t, e, Qy), Zy("input, textarea, select", t, e, Yy), e } function Zy(t, e, i, n) { const s = e.querySelectorAll(t); if (s.length) { const e = i.querySelectorAll(t); for (let t = 0; t < s.length; t++)n(s[t], e[t]) } } let Ky = 0; function Yy(t, e) { "file" !== e.type && (e.value = t.value), "radio" === e.type && e.name && (e.name = `mat-clone-${e.name}-${Ky++}`) } function Qy(t, e) { const i = e.getContext("2d"); if (i) try { i.drawImage(t, 0, 0) } catch (SM) { } } const Xy = iy({ passive: !0 }), Jy = iy({ passive: !1 }), tb = new Set(["position"]); class eb { constructor(t, e, i, n, s, r) { this._config = e, this._document = i, this._ngZone = n, this._viewportRuler = s, this._dragDropRegistry = r, this._passiveTransform = { x: 0, y: 0 }, this._activeTransform = { x: 0, y: 0 }, this._hasStartedDragging = !1, this._moveEvents = new S, this._pointerMoveSubscription = u.EMPTY, this._pointerUpSubscription = u.EMPTY, this._scrollSubscription = u.EMPTY, this._resizeSubscription = u.EMPTY, this._boundaryElement = null, this._nativeInteractionsEnabled = !0, this._handles = [], this._disabledHandles = new Set, this._direction = "ltr", this.dragStartDelay = 0, this._disabled = !1, this.beforeStarted = new S, this.started = new S, this.released = new S, this.ended = new S, this.entered = new S, this.exited = new S, this.dropped = new S, this.moved = this._moveEvents, this._pointerDown = t => { if (this.beforeStarted.next(), this._handles.length) { const e = this._handles.find(e => { const i = oy(t); return !!i && (i === e || e.contains(i)) }); !e || this._disabledHandles.has(e) || this.disabled || this._initializeDragSequence(e, t) } else this.disabled || this._initializeDragSequence(this._rootElement, t) }, this._pointerMove = t => { const e = this._getPointerPositionOnPage(t); if (!this._hasStartedDragging) { if (Math.abs(e.x - this._pickupPositionOnPage.x) + Math.abs(e.y - this._pickupPositionOnPage.y) >= this._config.dragStartThreshold) { const e = Date.now() >= this._dragStartTime + this._getDragStartDelay(t), i = this._dropContainer; if (!e) return void this._endDragSequence(t); i && (i.isDragging() || i.isReceiving()) || (t.preventDefault(), this._hasStartedDragging = !0, this._ngZone.run(() => this._startDragSequence(t))) } return } this._boundaryElement && (this._previewRect && (this._previewRect.width || this._previewRect.height) || (this._previewRect = (this._preview || this._rootElement).getBoundingClientRect())), t.preventDefault(); const i = this._getConstrainedPointerPosition(e); if (this._hasMoved = !0, this._lastKnownPointerPosition = e, this._updatePointerDirectionDelta(i), this._dropContainer) this._updateActiveDropContainer(i, e); else { const t = this._activeTransform; t.x = i.x - this._pickupPositionOnPage.x + this._passiveTransform.x, t.y = i.y - this._pickupPositionOnPage.y + this._passiveTransform.y, this._applyRootElementTransform(t.x, t.y), "undefined" != typeof SVGElement && this._rootElement instanceof SVGElement && this._rootElement.setAttribute("transform", `translate(${t.x} ${t.y})`) } this._moveEvents.observers.length && this._ngZone.run(() => { this._moveEvents.next({ source: this, pointerPosition: i, event: t, distance: this._getDragDistance(i), delta: this._pointerDirectionDelta }) }) }, this._pointerUp = t => { this._endDragSequence(t) }, this.withRootElement(t).withParent(e.parentDragRef || null), this._parentPositions = new qy(i, s), r.registerDragItem(this) } get disabled() { return this._disabled || !(!this._dropContainer || !this._dropContainer.disabled) } set disabled(t) { const e = Iv(t); e !== this._disabled && (this._disabled = e, this._toggleNativeDragInteractions(), this._handles.forEach(t => Ny(t, e))) } getPlaceholderElement() { return this._placeholder } getRootElement() { return this._rootElement } getVisibleElement() { return this.isDragging() ? this.getPlaceholderElement() : this.getRootElement() } withHandles(t) { this._handles = t.map(t => jv(t)), this._handles.forEach(t => Ny(t, this.disabled)), this._toggleNativeDragInteractions(); const e = new Set; return this._disabledHandles.forEach(t => { this._handles.indexOf(t) > -1 && e.add(t) }), this._disabledHandles = e, this } withPreviewTemplate(t) { return this._previewTemplate = t, this } withPlaceholderTemplate(t) { return this._placeholderTemplate = t, this } withRootElement(t) { const e = jv(t); return e !== this._rootElement && (this._rootElement && this._removeRootElementListeners(this._rootElement), this._ngZone.runOutsideAngular(() => { e.addEventListener("mousedown", this._pointerDown, Jy), e.addEventListener("touchstart", this._pointerDown, Xy) }), this._initialTransform = void 0, this._rootElement = e), "undefined" != typeof SVGElement && this._rootElement instanceof SVGElement && (this._ownerSVGElement = this._rootElement.ownerSVGElement), this } withBoundaryElement(t) { return this._boundaryElement = t ? jv(t) : null, this._resizeSubscription.unsubscribe(), t && (this._resizeSubscription = this._viewportRuler.change(10).subscribe(() => this._containInsideBoundaryOnResize())), this } withParent(t) { return this._parentDragRef = t, this } dispose() { this._removeRootElementListeners(this._rootElement), this.isDragging() && sb(this._rootElement), sb(this._anchor), this._destroyPreview(), this._destroyPlaceholder(), this._dragDropRegistry.removeDragItem(this), this._removeSubscriptions(), this.beforeStarted.complete(), this.started.complete(), this.released.complete(), this.ended.complete(), this.entered.complete(), this.exited.complete(), this.dropped.complete(), this._moveEvents.complete(), this._handles = [], this._disabledHandles.clear(), this._dropContainer = void 0, this._resizeSubscription.unsubscribe(), this._parentPositions.clear(), this._boundaryElement = this._rootElement = this._ownerSVGElement = this._placeholderTemplate = this._previewTemplate = this._anchor = this._parentDragRef = null } isDragging() { return this._hasStartedDragging && this._dragDropRegistry.isDragging(this) } reset() { this._rootElement.style.transform = this._initialTransform || "", this._activeTransform = { x: 0, y: 0 }, this._passiveTransform = { x: 0, y: 0 } } disableHandle(t) { !this._disabledHandles.has(t) && this._handles.indexOf(t) > -1 && (this._disabledHandles.add(t), Ny(t, !0)) } enableHandle(t) { this._disabledHandles.has(t) && (this._disabledHandles.delete(t), Ny(t, this.disabled)) } withDirection(t) { return this._direction = t, this } _withDropContainer(t) { this._dropContainer = t } getFreeDragPosition() { const t = this.isDragging() ? this._activeTransform : this._passiveTransform; return { x: t.x, y: t.y } } setFreeDragPosition(t) { return this._activeTransform = { x: 0, y: 0 }, this._passiveTransform.x = t.x, this._passiveTransform.y = t.y, this._dropContainer || this._applyRootElementTransform(t.x, t.y), this } withPreviewContainer(t) { return this._previewContainer = t, this } _sortFromLastPointerPosition() { const t = this._lastKnownPointerPosition; t && this._dropContainer && this._updateActiveDropContainer(this._getConstrainedPointerPosition(t), t) } _removeSubscriptions() { this._pointerMoveSubscription.unsubscribe(), this._pointerUpSubscription.unsubscribe(), this._scrollSubscription.unsubscribe() } _destroyPreview() { this._preview && sb(this._preview), this._previewRef && this._previewRef.destroy(), this._preview = this._previewRef = null } _destroyPlaceholder() { this._placeholder && sb(this._placeholder), this._placeholderRef && this._placeholderRef.destroy(), this._placeholder = this._placeholderRef = null } _endDragSequence(t) { if (this._dragDropRegistry.isDragging(this) && (this._removeSubscriptions(), this._dragDropRegistry.stopDragging(this), this._toggleNativeDragInteractions(), this._handles && (this._rootElement.style.webkitTapHighlightColor = this._rootElementTapHighlight), this._hasStartedDragging)) if (this.released.next({ source: this }), this._dropContainer) this._dropContainer._stopScrolling(), this._animatePreviewToPlaceholder().then(() => { this._cleanupDragArtifacts(t), this._cleanupCachedDimensions(), this._dragDropRegistry.stopDragging(this) }); else { this._passiveTransform.x = this._activeTransform.x; const e = this._getPointerPositionOnPage(t); this._passiveTransform.y = this._activeTransform.y, this._ngZone.run(() => { this.ended.next({ source: this, distance: this._getDragDistance(e), dropPoint: e }) }), this._cleanupCachedDimensions(), this._dragDropRegistry.stopDragging(this) } } _startDragSequence(t) { rb(t) && (this._lastTouchEventTime = Date.now()), this._toggleNativeDragInteractions(); const e = this._dropContainer; if (e) { const t = this._rootElement, i = t.parentNode, n = this._placeholder = this._createPlaceholderElement(), s = this._anchor = this._anchor || this._document.createComment(""), r = this._getShadowRoot(); i.insertBefore(s, t), this._initialTransform = t.style.transform || "", this._preview = this._createPreviewElement(), jy(t, !1, tb), this._document.body.appendChild(i.replaceChild(n, t)), this._getPreviewInsertionPoint(i, r).appendChild(this._preview), this.started.next({ source: this }), e.start(), this._initialContainer = e, this._initialIndex = e.getItemIndex(this) } else this.started.next({ source: this }), this._initialContainer = this._initialIndex = void 0; this._parentPositions.cache(e ? e.getScrollableParents() : []) } _initializeDragSequence(t, e) { this._parentDragRef && e.stopPropagation(); const i = this.isDragging(), n = rb(e), s = !n && 0 !== e.button, r = this._rootElement, o = oy(e), a = !n && this._lastTouchEventTime && this._lastTouchEventTime + 800 > Date.now(), l = n ? Sy(e) : xy(e); if (o && o.draggable && "mousedown" === e.type && e.preventDefault(), i || s || a || l) return; this._handles.length && (this._rootElementTapHighlight = r.style.webkitTapHighlightColor || "", r.style.webkitTapHighlightColor = "transparent"), this._hasStartedDragging = this._hasMoved = !1, this._removeSubscriptions(), this._pointerMoveSubscription = this._dragDropRegistry.pointerMove.subscribe(this._pointerMove), this._pointerUpSubscription = this._dragDropRegistry.pointerUp.subscribe(this._pointerUp), this._scrollSubscription = this._dragDropRegistry.scrolled(this._getShadowRoot()).subscribe(t => this._updateOnScroll(t)), this._boundaryElement && (this._boundaryRect = zy(this._boundaryElement)); const c = this._previewTemplate; this._pickupPositionInElement = c && c.template && !c.matchSize ? { x: 0, y: 0 } : this._getPointerPositionInElement(t, e); const h = this._pickupPositionOnPage = this._lastKnownPointerPosition = this._getPointerPositionOnPage(e); this._pointerDirectionDelta = { x: 0, y: 0 }, this._pointerPositionAtLastDirectionChange = { x: h.x, y: h.y }, this._dragStartTime = Date.now(), this._dragDropRegistry.startDragging(this, e) } _cleanupDragArtifacts(t) { jy(this._rootElement, !0, tb), this._anchor.parentNode.replaceChild(this._rootElement, this._anchor), this._destroyPreview(), this._destroyPlaceholder(), this._boundaryRect = this._previewRect = this._initialTransform = void 0, this._ngZone.run(() => { const e = this._dropContainer, i = e.getItemIndex(this), n = this._getPointerPositionOnPage(t), s = this._getDragDistance(n), r = e._isOverContainer(n.x, n.y); this.ended.next({ source: this, distance: s, dropPoint: n }), this.dropped.next({ item: this, currentIndex: i, previousIndex: this._initialIndex, container: e, previousContainer: this._initialContainer, isPointerOverContainer: r, distance: s, dropPoint: n }), e.drop(this, i, this._initialIndex, this._initialContainer, r, s, n), this._dropContainer = this._initialContainer }) } _updateActiveDropContainer({ x: t, y: e }, { x: i, y: n }) { let s = this._initialContainer._getSiblingContainerFromPosition(this, t, e); !s && this._dropContainer !== this._initialContainer && this._initialContainer._isOverContainer(t, e) && (s = this._initialContainer), s && s !== this._dropContainer && this._ngZone.run(() => { this.exited.next({ item: this, container: this._dropContainer }), this._dropContainer.exit(this), this._dropContainer = s, this._dropContainer.enter(this, t, e, s === this._initialContainer && s.sortingDisabled ? this._initialIndex : void 0), this.entered.next({ item: this, container: s, currentIndex: s.getItemIndex(this) }) }), this.isDragging() && (this._dropContainer._startScrollingIfNecessary(i, n), this._dropContainer._sortItem(this, t, e, this._pointerDirectionDelta), this._applyPreviewTransform(t - this._pickupPositionInElement.x, e - this._pickupPositionInElement.y)) } _createPreviewElement() { const t = this._previewTemplate, e = this.previewClass, i = t ? t.template : null; let n; if (i && t) { const e = t.matchSize ? this._rootElement.getBoundingClientRect() : null, s = t.viewContainer.createEmbeddedView(i, t.context); s.detectChanges(), n = ob(s, this._document), this._previewRef = s, t.matchSize ? ab(n, e) : n.style.transform = ib(this._pickupPositionOnPage.x, this._pickupPositionOnPage.y) } else { const t = this._rootElement; n = Gy(t), ab(n, t.getBoundingClientRect()), this._initialTransform && (n.style.transform = this._initialTransform) } return Fy(n.style, { "pointer-events": "none", margin: "0", position: "fixed", top: "0", left: "0", "z-index": `${this._config.zIndex || 1e3}` }, tb), Ny(n, !1), n.classList.add("cdk-drag-preview"), n.setAttribute("dir", this._direction), e && (Array.isArray(e) ? e.forEach(t => n.classList.add(t)) : n.classList.add(e)), n } _animatePreviewToPlaceholder() { if (!this._hasMoved) return Promise.resolve(); const t = this._placeholder.getBoundingClientRect(); this._preview.classList.add("cdk-drag-animating"), this._applyPreviewTransform(t.left, t.top); const e = function (t) { const e = getComputedStyle(t), i = Hy(e, "transition-property"), n = i.find(t => "transform" === t || "all" === t); if (!n) return 0; const s = i.indexOf(n), r = Hy(e, "transition-duration"), o = Hy(e, "transition-delay"); return By(r[s]) + By(o[s]) }(this._preview); return 0 === e ? Promise.resolve() : this._ngZone.runOutsideAngular(() => new Promise(t => { const i = e => { var s; (!e || oy(e) === this._preview && "transform" === e.propertyName) && (null === (s = this._preview) || void 0 === s || s.removeEventListener("transitionend", i), t(), clearTimeout(n)) }, n = setTimeout(i, 1.5 * e); this._preview.addEventListener("transitionend", i) })) } _createPlaceholderElement() { const t = this._placeholderTemplate, e = t ? t.template : null; let i; return e ? (this._placeholderRef = t.viewContainer.createEmbeddedView(e, t.context), this._placeholderRef.detectChanges(), i = ob(this._placeholderRef, this._document)) : i = Gy(this._rootElement), i.classList.add("cdk-drag-placeholder"), i } _getPointerPositionInElement(t, e) { const i = this._rootElement.getBoundingClientRect(), n = t === this._rootElement ? null : t, s = n ? n.getBoundingClientRect() : i, r = rb(e) ? e.targetTouches[0] : e, o = this._getViewportScrollPosition(); return { x: s.left - i.left + (r.pageX - s.left - o.left), y: s.top - i.top + (r.pageY - s.top - o.top) } } _getPointerPositionOnPage(t) { const e = this._getViewportScrollPosition(), i = rb(t) ? t.touches[0] || t.changedTouches[0] || { pageX: 0, pageY: 0 } : t, n = i.pageX - e.left, s = i.pageY - e.top; if (this._ownerSVGElement) { const t = this._ownerSVGElement.getScreenCTM(); if (t) { const e = this._ownerSVGElement.createSVGPoint(); return e.x = n, e.y = s, e.matrixTransform(t.inverse()) } } return { x: n, y: s } } _getConstrainedPointerPosition(t) { const e = this._dropContainer ? this._dropContainer.lockAxis : null; let { x: i, y: n } = this.constrainPosition ? this.constrainPosition(t, this) : t; if ("x" === this.lockAxis || "x" === e ? n = this._pickupPositionOnPage.y : "y" !== this.lockAxis && "y" !== e || (i = this._pickupPositionOnPage.x), this._boundaryRect) { const { x: t, y: e } = this._pickupPositionInElement, s = this._boundaryRect, r = this._previewRect, o = s.top + e, a = s.bottom - (r.height - e); i = nb(i, s.left + t, s.right - (r.width - t)), n = nb(n, o, a) } return { x: i, y: n } } _updatePointerDirectionDelta(t) { const { x: e, y: i } = t, n = this._pointerDirectionDelta, s = this._pointerPositionAtLastDirectionChange, r = Math.abs(e - s.x), o = Math.abs(i - s.y); return r > this._config.pointerDirectionChangeThreshold && (n.x = e > s.x ? 1 : -1, s.x = e), o > this._config.pointerDirectionChangeThreshold && (n.y = i > s.y ? 1 : -1, s.y = i), n } _toggleNativeDragInteractions() { if (!this._rootElement || !this._handles) return; const t = this._handles.length > 0 || !this.isDragging(); t !== this._nativeInteractionsEnabled && (this._nativeInteractionsEnabled = t, Ny(this._rootElement, t)) } _removeRootElementListeners(t) { t.removeEventListener("mousedown", this._pointerDown, Jy), t.removeEventListener("touchstart", this._pointerDown, Xy) } _applyRootElementTransform(t, e) { const i = ib(t, e); null == this._initialTransform && (this._initialTransform = this._rootElement.style.transform && "none" != this._rootElement.style.transform ? this._rootElement.style.transform : ""), this._rootElement.style.transform = Vy(i, this._initialTransform) } _applyPreviewTransform(t, e) { var i; const n = (null === (i = this._previewTemplate) || void 0 === i ? void 0 : i.template) ? void 0 : this._initialTransform, s = ib(t, e); this._preview.style.transform = Vy(s, n) } _getDragDistance(t) { const e = this._pickupPositionOnPage; return e ? { x: t.x - e.x, y: t.y - e.y } : { x: 0, y: 0 } } _cleanupCachedDimensions() { this._boundaryRect = this._previewRect = void 0, this._parentPositions.clear() } _containInsideBoundaryOnResize() { let { x: t, y: e } = this._passiveTransform; if (0 === t && 0 === e || this.isDragging() || !this._boundaryElement) return; const i = this._boundaryElement.getBoundingClientRect(), n = this._rootElement.getBoundingClientRect(); if (0 === i.width && 0 === i.height || 0 === n.width && 0 === n.height) return; const s = i.left - n.left, r = n.right - i.right, o = i.top - n.top, a = n.bottom - i.bottom; i.width > n.width ? (s > 0 && (t += s), r > 0 && (t -= r)) : t = 0, i.height > n.height ? (o > 0 && (e += o), a > 0 && (e -= a)) : e = 0, t === this._passiveTransform.x && e === this._passiveTransform.y || this.setFreeDragPosition({ y: e, x: t }) } _getDragStartDelay(t) { const e = this.dragStartDelay; return "number" == typeof e ? e : rb(t) ? e.touch : e ? e.mouse : 0 } _updateOnScroll(t) { const e = this._parentPositions.handleScroll(t); if (e) { const i = oy(t); this._boundaryRect && (i === this._document || i !== this._boundaryElement && i.contains(this._boundaryElement)) && Uy(this._boundaryRect, e.top, e.left), this._pickupPositionOnPage.x += e.left, this._pickupPositionOnPage.y += e.top, this._dropContainer || (this._activeTransform.x -= e.left, this._activeTransform.y -= e.top, this._applyRootElementTransform(this._activeTransform.x, this._activeTransform.y)) } } _getViewportScrollPosition() { const t = this._parentPositions.positions.get(this._document); return t ? t.scrollPosition : this._viewportRuler.getViewportScrollPosition() } _getShadowRoot() { return void 0 === this._cachedShadowRoot && (this._cachedShadowRoot = sy(this._rootElement)), this._cachedShadowRoot } _getPreviewInsertionPoint(t, e) { const i = this._previewContainer || "global"; if ("parent" === i) return t; if ("global" === i) { const t = this._document; return e || t.fullscreenElement || t.webkitFullscreenElement || t.mozFullScreenElement || t.msFullscreenElement || t.body } return jv(i) } } function ib(t, e) { return `translate3d(${Math.round(t)}px, ${Math.round(e)}px, 0)` } function nb(t, e, i) { return Math.max(e, Math.min(i, t)) } function sb(t) { t && t.parentNode && t.parentNode.removeChild(t) } function rb(t) { return "t" === t.type[0] } function ob(t, e) { const i = t.rootNodes; if (1 === i.length && i[0].nodeType === e.ELEMENT_NODE) return i[0]; const n = e.createElement("div"); return i.forEach(t => n.appendChild(t)), n } function ab(t, e) { t.style.width = `${e.width}px`, t.style.height = `${e.height}px`, t.style.transform = ib(e.left, e.top) } function lb(t, e, i) { const n = cb(e, t.length - 1), s = cb(i, t.length - 1); if (n === s) return; const r = t[n], o = s < n ? -1 : 1; for (let a = n; a !== s; a += o)t[a] = t[a + o]; t[s] = r } function cb(t, e) { return Math.max(0, Math.min(e, t)) } class hb { constructor(t, e, i, n, s) { this._dragDropRegistry = e, this._ngZone = n, this._viewportRuler = s, this.disabled = !1, this.sortingDisabled = !1, this.autoScrollDisabled = !1, this.autoScrollStep = 2, this.enterPredicate = () => !0, this.sortPredicate = () => !0, this.beforeStarted = new S, this.entered = new S, this.exited = new S, this.dropped = new S, this.sorted = new S, this._isDragging = !1, this._itemPositions = [], this._previousSwap = { drag: null, delta: 0, overlaps: !1 }, this._draggables = [], this._siblings = [], this._orientation = "vertical", this._activeSiblings = new Set, this._direction = "ltr", this._viewportScrollSubscription = u.EMPTY, this._verticalScrollDirection = 0, this._horizontalScrollDirection = 0, this._stopScrollTimers = new S, this._cachedShadowRoot = null, this._startScrollInterval = () => { this._stopScrolling(), function (t = 0, e = Hv) { return (!Uv(t) || t < 0) && (t = 0), e && "function" == typeof e.schedule || (e = Hv), new v(i => (i.add(e.schedule(Ly, t, { subscriber: i, counter: 0, period: t })), i)) }(0, d_).pipe(Gv(this._stopScrollTimers)).subscribe(() => { const t = this._scrollNode, e = this.autoScrollStep; 1 === this._verticalScrollDirection ? db(t, -e) : 2 === this._verticalScrollDirection && db(t, e), 1 === this._horizontalScrollDirection ? pb(t, -e) : 2 === this._horizontalScrollDirection && pb(t, e) }) }, this.element = jv(t), this._document = i, this.withScrollableParents([this.element]), e.registerDropContainer(this), this._parentPositions = new qy(i, s) } dispose() { this._stopScrolling(), this._stopScrollTimers.complete(), this._viewportScrollSubscription.unsubscribe(), this.beforeStarted.complete(), this.entered.complete(), this.exited.complete(), this.dropped.complete(), this.sorted.complete(), this._activeSiblings.clear(), this._scrollNode = null, this._parentPositions.clear(), this._dragDropRegistry.removeDropContainer(this) } isDragging() { return this._isDragging } start() { this._draggingStarted(), this._notifyReceivingSiblings() } enter(t, e, i, n) { let s; this._draggingStarted(), null == n ? (s = this.sortingDisabled ? this._draggables.indexOf(t) : -1, -1 === s && (s = this._getItemIndexFromPointerPosition(t, e, i))) : s = n; const r = this._activeDraggables, o = r.indexOf(t), a = t.getPlaceholderElement(); let l = r[s]; if (l === t && (l = r[s + 1]), o > -1 && r.splice(o, 1), l && !this._dragDropRegistry.isDragging(l)) { const e = l.getRootElement(); e.parentElement.insertBefore(a, e), r.splice(s, 0, t) } else if (this._shouldEnterAsFirstChild(e, i)) { const e = r[0].getRootElement(); e.parentNode.insertBefore(a, e), r.unshift(t) } else jv(this.element).appendChild(a), r.push(t); a.style.transform = "", this._cacheItemPositions(), this._cacheParentPositions(), this._notifyReceivingSiblings(), this.entered.next({ item: t, container: this, currentIndex: this.getItemIndex(t) }) } exit(t) { this._reset(), this.exited.next({ item: t, container: this }) } drop(t, e, i, n, s, r, o) { this._reset(), this.dropped.next({ item: t, currentIndex: e, previousIndex: i, container: this, previousContainer: n, isPointerOverContainer: s, distance: r, dropPoint: o }) } withItems(t) { const e = this._draggables; return this._draggables = t, t.forEach(t => t._withDropContainer(this)), this.isDragging() && (e.filter(t => t.isDragging()).every(e => -1 === t.indexOf(e)) ? this._reset() : this._cacheItems()), this } withDirection(t) { return this._direction = t, this } connectedTo(t) { return this._siblings = t.slice(), this } withOrientation(t) { return this._orientation = t, this } withScrollableParents(t) { const e = jv(this.element); return this._scrollableElements = -1 === t.indexOf(e) ? [e, ...t] : t.slice(), this } getScrollableParents() { return this._scrollableElements } getItemIndex(t) { return this._isDragging ? ub("horizontal" === this._orientation && "rtl" === this._direction ? this._itemPositions.slice().reverse() : this._itemPositions, e => e.drag === t) : this._draggables.indexOf(t) } isReceiving() { return this._activeSiblings.size > 0 } _sortItem(t, e, i, n) { if (this.sortingDisabled || !this._clientRect || !Wy(this._clientRect, .05, e, i)) return; const s = this._itemPositions, r = this._getItemIndexFromPointerPosition(t, e, i, n); if (-1 === r && s.length > 0) return; const o = "horizontal" === this._orientation, a = ub(s, e => e.drag === t), l = s[r], c = l.clientRect, h = a > r ? 1 : -1, u = this._getItemOffsetPx(s[a].clientRect, c, h), d = this._getSiblingOffsetPx(a, s, h), p = s.slice(); lb(s, a, r), this.sorted.next({ previousIndex: a, currentIndex: r, container: this, item: t }), s.forEach((e, i) => { if (p[i] === e) return; const n = e.drag === t, s = n ? u : d, r = n ? t.getPlaceholderElement() : e.drag.getRootElement(); e.offset += s, o ? (r.style.transform = Vy(`translate3d(${Math.round(e.offset)}px, 0, 0)`, e.initialTransform), Uy(e.clientRect, 0, s)) : (r.style.transform = Vy(`translate3d(0, ${Math.round(e.offset)}px, 0)`, e.initialTransform), Uy(e.clientRect, s, 0)) }), this._previousSwap.overlaps = $y(c, e, i), this._previousSwap.drag = l.drag, this._previousSwap.delta = o ? n.x : n.y } _startScrollingIfNecessary(t, e) { if (this.autoScrollDisabled) return; let i, n = 0, s = 0; if (this._parentPositions.positions.forEach((r, o) => { o !== this._document && r.clientRect && !i && Wy(r.clientRect, .05, t, e) && ([n, s] = function (t, e, i, n) { const s = fb(e, n), r = gb(e, i); let o = 0, a = 0; if (s) { const e = t.scrollTop; 1 === s ? e > 0 && (o = 1) : t.scrollHeight - e > t.clientHeight && (o = 2) } if (r) { const e = t.scrollLeft; 1 === r ? e > 0 && (a = 1) : t.scrollWidth - e > t.clientWidth && (a = 2) } return [o, a] }(o, r.clientRect, t, e), (n || s) && (i = o)) }), !n && !s) { const { width: r, height: o } = this._viewportRuler.getViewportSize(), a = { width: r, height: o, top: 0, right: r, bottom: o, left: 0 }; n = fb(a, e), s = gb(a, t), i = window } !i || n === this._verticalScrollDirection && s === this._horizontalScrollDirection && i === this._scrollNode || (this._verticalScrollDirection = n, this._horizontalScrollDirection = s, this._scrollNode = i, (n || s) && i ? this._ngZone.runOutsideAngular(this._startScrollInterval) : this._stopScrolling()) } _stopScrolling() { this._stopScrollTimers.next() } _draggingStarted() { const t = jv(this.element).style; this.beforeStarted.next(), this._isDragging = !0, this._initialScrollSnap = t.msScrollSnapType || t.scrollSnapType || "", t.scrollSnapType = t.msScrollSnapType = "none", this._cacheItems(), this._viewportScrollSubscription.unsubscribe(), this._listenToScrollEvents() } _cacheParentPositions() { const t = jv(this.element); this._parentPositions.cache(this._scrollableElements), this._clientRect = this._parentPositions.positions.get(t).clientRect } _cacheItemPositions() { const t = "horizontal" === this._orientation; this._itemPositions = this._activeDraggables.map(t => { const e = t.getVisibleElement(); return { drag: t, offset: 0, initialTransform: e.style.transform || "", clientRect: zy(e) } }).sort((e, i) => t ? e.clientRect.left - i.clientRect.left : e.clientRect.top - i.clientRect.top) } _reset() { this._isDragging = !1; const t = jv(this.element).style; t.scrollSnapType = t.msScrollSnapType = this._initialScrollSnap, this._activeDraggables.forEach(t => { var e; const i = t.getRootElement(); if (i) { const n = null === (e = this._itemPositions.find(e => e.drag === t)) || void 0 === e ? void 0 : e.initialTransform; i.style.transform = n || "" } }), this._siblings.forEach(t => t._stopReceiving(this)), this._activeDraggables = [], this._itemPositions = [], this._previousSwap.drag = null, this._previousSwap.delta = 0, this._previousSwap.overlaps = !1, this._stopScrolling(), this._viewportScrollSubscription.unsubscribe(), this._parentPositions.clear() } _getSiblingOffsetPx(t, e, i) { const n = "horizontal" === this._orientation, s = e[t].clientRect, r = e[t + -1 * i]; let o = s[n ? "width" : "height"] * i; if (r) { const t = n ? "left" : "top", e = n ? "right" : "bottom"; -1 === i ? o -= r.clientRect[t] - s[e] : o += s[t] - r.clientRect[e] } return o } _getItemOffsetPx(t, e, i) { const n = "horizontal" === this._orientation; let s = n ? e.left - t.left : e.top - t.top; return -1 === i && (s += n ? e.width - t.width : e.height - t.height), s } _shouldEnterAsFirstChild(t, e) { if (!this._activeDraggables.length) return !1; const i = this._itemPositions, n = "horizontal" === this._orientation; if (i[0].drag !== this._activeDraggables[0]) { const s = i[i.length - 1].clientRect; return n ? t >= s.right : e >= s.bottom } { const s = i[0].clientRect; return n ? t <= s.left : e <= s.top } } _getItemIndexFromPointerPosition(t, e, i, n) { const s = "horizontal" === this._orientation, r = ub(this._itemPositions, ({ drag: r, clientRect: o }, a, l) => { if (r === t) return l.length < 2; if (n) { const t = s ? n.x : n.y; if (r === this._previousSwap.drag && this._previousSwap.overlaps && t === this._previousSwap.delta) return !1 } return s ? e >= Math.floor(o.left) && e < Math.floor(o.right) : i >= Math.floor(o.top) && i < Math.floor(o.bottom) }); return -1 !== r && this.sortPredicate(r, t, this) ? r : -1 } _cacheItems() { this._activeDraggables = this._draggables.slice(), this._cacheItemPositions(), this._cacheParentPositions() } _isOverContainer(t, e) { return null != this._clientRect && $y(this._clientRect, t, e) } _getSiblingContainerFromPosition(t, e, i) { return this._siblings.find(n => n._canReceive(t, e, i)) } _canReceive(t, e, i) { if (!this._clientRect || !$y(this._clientRect, e, i) || !this.enterPredicate(t, this)) return !1; const n = this._getShadowRoot().elementFromPoint(e, i); if (!n) return !1; const s = jv(this.element); return n === s || s.contains(n) } _startReceiving(t, e) { const i = this._activeSiblings; !i.has(t) && e.every(t => this.enterPredicate(t, this) || this._draggables.indexOf(t) > -1) && (i.add(t), this._cacheParentPositions(), this._listenToScrollEvents()) } _stopReceiving(t) { this._activeSiblings.delete(t), this._viewportScrollSubscription.unsubscribe() } _listenToScrollEvents() { this._viewportScrollSubscription = this._dragDropRegistry.scrolled(this._getShadowRoot()).subscribe(t => { if (this.isDragging()) { const e = this._parentPositions.handleScroll(t); e && (this._itemPositions.forEach(({ clientRect: t }) => { Uy(t, e.top, e.left) }), this._itemPositions.forEach(({ drag: t }) => { this._dragDropRegistry.isDragging(t) && t._sortFromLastPointerPosition() })) } else this.isReceiving() && this._cacheParentPositions() }) } _getShadowRoot() { if (!this._cachedShadowRoot) { const t = sy(jv(this.element)); this._cachedShadowRoot = t || this._document } return this._cachedShadowRoot } _notifyReceivingSiblings() { const t = this._activeDraggables.filter(t => t.isDragging()); this._siblings.forEach(e => e._startReceiving(this, t)) } } function ub(t, e) { for (let i = 0; i < t.length; i++)if (e(t[i], i, t)) return i; return -1 } function db(t, e) { t === window ? t.scrollBy(0, e) : t.scrollTop += e } function pb(t, e) { t === window ? t.scrollBy(e, 0) : t.scrollLeft += e } function fb(t, e) { const { top: i, bottom: n, height: s } = t, r = .05 * s; return e >= i - r && e <= i + r ? 1 : e >= n - r && e <= n + r ? 2 : 0 } function gb(t, e) { const { left: i, right: n, width: s } = t, r = .05 * s; return e >= i - r && e <= i + r ? 1 : e >= n - r && e <= n + r ? 2 : 0 } const mb = iy({ passive: !1, capture: !0 }); let _b = (() => { class t { constructor(t, e) { this._ngZone = t, this._dropInstances = new Set, this._dragInstances = new Set, this._activeDragInstances = [], this._globalListeners = new Map, this._draggingPredicate = t => t.isDragging(), this.pointerMove = new S, this.pointerUp = new S, this.scroll = new S, this._preventDefaultWhileDragging = t => { this._activeDragInstances.length > 0 && t.preventDefault() }, this._persistentTouchmoveListener = t => { this._activeDragInstances.length > 0 && (this._activeDragInstances.some(this._draggingPredicate) && t.preventDefault(), this.pointerMove.next(t)) }, this._document = e } registerDropContainer(t) { this._dropInstances.has(t) || this._dropInstances.add(t) } registerDragItem(t) { this._dragInstances.add(t), 1 === this._dragInstances.size && this._ngZone.runOutsideAngular(() => { this._document.addEventListener("touchmove", this._persistentTouchmoveListener, mb) }) } removeDropContainer(t) { this._dropInstances.delete(t) } removeDragItem(t) { this._dragInstances.delete(t), this.stopDragging(t), 0 === this._dragInstances.size && this._document.removeEventListener("touchmove", this._persistentTouchmoveListener, mb) } startDragging(t, e) { if (!(this._activeDragInstances.indexOf(t) > -1) && (this._activeDragInstances.push(t), 1 === this._activeDragInstances.length)) { const t = e.type.startsWith("touch"); this._globalListeners.set(t ? "touchend" : "mouseup", { handler: t => this.pointerUp.next(t), options: !0 }).set("scroll", { handler: t => this.scroll.next(t), options: !0 }).set("selectstart", { handler: this._preventDefaultWhileDragging, options: mb }), t || this._globalListeners.set("mousemove", { handler: t => this.pointerMove.next(t), options: mb }), this._ngZone.runOutsideAngular(() => { this._globalListeners.forEach((t, e) => { this._document.addEventListener(e, t.handler, t.options) }) }) } } stopDragging(t) { const e = this._activeDragInstances.indexOf(t); e > -1 && (this._activeDragInstances.splice(e, 1), 0 === this._activeDragInstances.length && this._clearGlobalListeners()) } isDragging(t) { return this._activeDragInstances.indexOf(t) > -1 } scrolled(t) { const e = [this.scroll]; return t && t !== this._document && e.push(new v(e => this._ngZone.runOutsideAngular(() => { const i = t => { this._activeDragInstances.length && e.next(t) }; return t.addEventListener("scroll", i, !0), () => { t.removeEventListener("scroll", i, !0) } }))), q(...e) } ngOnDestroy() { this._dragInstances.forEach(t => this.removeDragItem(t)), this._dropInstances.forEach(t => this.removeDropContainer(t)), this._clearGlobalListeners(), this.pointerMove.complete(), this.pointerUp.complete() } _clearGlobalListeners() { this._globalListeners.forEach((t, e) => { this._document.removeEventListener(e, t.handler, t.options) }), this._globalListeners.clear() } } return t.\u0275fac = function (e) { return new (e || t)(hn(Vl), hn(vc)) }, t.\u0275prov = dt({ factory: function () { return new t(hn(Vl), hn(vc)) }, token: t, providedIn: "root" }), t })(); const vb = { dragStartThreshold: 5, pointerDirectionChangeThreshold: 5 }; let yb = (() => { class t { constructor(t, e, i, n) { this._document = t, this._ngZone = e, this._viewportRuler = i, this._dragDropRegistry = n } createDrag(t, e = vb) { return new eb(t, e, this._document, this._ngZone, this._viewportRuler, this._dragDropRegistry) } createDropList(t) { return new hb(t, this._dragDropRegistry, this._document, this._ngZone, this._viewportRuler) } } return t.\u0275fac = function (e) { return new (e || t)(hn(vc), hn(Vl), hn(dy), hn(_b)) }, t.\u0275prov = dt({ factory: function () { return new t(hn(vc), hn(Vl), hn(dy), hn(_b)) }, token: t, providedIn: "root" }), t })(); const bb = new Wi("CDK_DRAG_PARENT"), wb = new Wi("CdkDropListGroup"), xb = new Wi("CDK_DRAG_CONFIG"); let Sb = 0; const kb = new Wi("CdkDropList"); let Cb = (() => { class t { constructor(e, i, n, s, r, o, a) { this.element = e, this._changeDetectorRef = n, this._scrollDispatcher = s, this._dir = r, this._group = o, this._destroyed = new S, this.connectedTo = [], this.id = "cdk-drop-list-" + Sb++, this.enterPredicate = () => !0, this.sortPredicate = () => !0, this.dropped = new Ja, this.entered = new Ja, this.exited = new Ja, this.sorted = new Ja, this._unsortedItems = new Set, this._dropListRef = i.createDropList(e), this._dropListRef.data = this, a && this._assignDefaults(a), this._dropListRef.enterPredicate = (t, e) => this.enterPredicate(t.data, e.data), this._dropListRef.sortPredicate = (t, e, i) => this.sortPredicate(t, e.data, i.data), this._setupInputSyncSubscription(this._dropListRef), this._handleEvents(this._dropListRef), t._dropLists.push(this), o && o._items.add(this) } get disabled() { return this._disabled || !!this._group && this._group.disabled } set disabled(t) { this._dropListRef.disabled = this._disabled = Iv(t) } addItem(t) { this._unsortedItems.add(t), this._dropListRef.isDragging() && this._syncItemsWithRef() } removeItem(t) { this._unsortedItems.delete(t), this._dropListRef.isDragging() && this._syncItemsWithRef() } getSortedItems() { return Array.from(this._unsortedItems).sort((t, e) => t._dragRef.getVisibleElement().compareDocumentPosition(e._dragRef.getVisibleElement()) & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : 1) } ngOnDestroy() { const e = t._dropLists.indexOf(this); e > -1 && t._dropLists.splice(e, 1), this._group && this._group._items.delete(this), this._unsortedItems.clear(), this._dropListRef.dispose(), this._destroyed.next(), this._destroyed.complete() } _setupInputSyncSubscription(e) { this._dir && this._dir.change.pipe(Kh(this._dir.value), Gv(this._destroyed)).subscribe(t => e.withDirection(t)), e.beforeStarted.subscribe(() => { const i = Fv(this.connectedTo).map(e => "string" == typeof e ? t._dropLists.find(t => t.id === e) : e); if (this._group && this._group._items.forEach(t => { -1 === i.indexOf(t) && i.push(t) }), !this._scrollableParentsResolved) { const t = this._scrollDispatcher.getAncestorScrollContainers(this.element).map(t => t.getElementRef().nativeElement); this._dropListRef.withScrollableParents(t), this._scrollableParentsResolved = !0 } e.disabled = this.disabled, e.lockAxis = this.lockAxis, e.sortingDisabled = Iv(this.sortingDisabled), e.autoScrollDisabled = Iv(this.autoScrollDisabled), e.autoScrollStep = Lv(this.autoScrollStep, 2), e.connectedTo(i.filter(t => t && t !== this).map(t => t._dropListRef)).withOrientation(this.orientation) }) } _handleEvents(t) { t.beforeStarted.subscribe(() => { this._syncItemsWithRef(), this._changeDetectorRef.markForCheck() }), t.entered.subscribe(t => { this.entered.emit({ container: this, item: t.item.data, currentIndex: t.currentIndex }) }), t.exited.subscribe(t => { this.exited.emit({ container: this, item: t.item.data }), this._changeDetectorRef.markForCheck() }), t.sorted.subscribe(t => { this.sorted.emit({ previousIndex: t.previousIndex, currentIndex: t.currentIndex, container: this, item: t.item.data }) }), t.dropped.subscribe(t => { this.dropped.emit({ previousIndex: t.previousIndex, currentIndex: t.currentIndex, previousContainer: t.previousContainer.data, container: t.container.data, item: t.item.data, isPointerOverContainer: t.isPointerOverContainer, distance: t.distance, dropPoint: t.dropPoint }), this._changeDetectorRef.markForCheck() }) } _assignDefaults(t) { const { lockAxis: e, draggingDisabled: i, sortingDisabled: n, listAutoScrollDisabled: s, listOrientation: r } = t; this.disabled = null != i && i, this.sortingDisabled = null != n && n, this.autoScrollDisabled = null != s && s, this.orientation = r || "vertical", e && (this.lockAxis = e) } _syncItemsWithRef() { this._dropListRef.withItems(this.getSortedItems().map(t => t._dragRef)) } } return t.\u0275fac = function (e) { return new (e || t)(Ur(Ko), Ur(yb), Ur(wa), Ur(uy), Ur(cy, 8), Ur(wb, 12), Ur(xb, 8)) }, t.\u0275dir = Kt({ type: t, selectors: [["", "cdkDropList", ""], ["cdk-drop-list"]], hostAttrs: [1, "cdk-drop-list"], hostVars: 7, hostBindings: function (t, e) { 2 & t && (Hr("id", e.id), uo("cdk-drop-list-disabled", e.disabled)("cdk-drop-list-dragging", e._dropListRef.isDragging())("cdk-drop-list-receiving", e._dropListRef.isReceiving())) }, inputs: { connectedTo: ["cdkDropListConnectedTo", "connectedTo"], id: "id", enterPredicate: ["cdkDropListEnterPredicate", "enterPredicate"], sortPredicate: ["cdkDropListSortPredicate", "sortPredicate"], disabled: ["cdkDropListDisabled", "disabled"], sortingDisabled: ["cdkDropListSortingDisabled", "sortingDisabled"], autoScrollDisabled: ["cdkDropListAutoScrollDisabled", "autoScrollDisabled"], orientation: ["cdkDropListOrientation", "orientation"], lockAxis: ["cdkDropListLockAxis", "lockAxis"], data: ["cdkDropListData", "data"], autoScrollStep: ["cdkDropListAutoScrollStep", "autoScrollStep"] }, outputs: { dropped: "cdkDropListDropped", entered: "cdkDropListEntered", exited: "cdkDropListExited", sorted: "cdkDropListSorted" }, exportAs: ["cdkDropList"], features: [zo([{ provide: wb, useValue: void 0 }, { provide: kb, useExisting: t }])] }), t._dropLists = [], t })(); const Eb = new Wi("CdkDragHandle"), Tb = new Wi("CdkDragPlaceholder"), Pb = new Wi("CdkDragPreview"); let Db = (() => { class t { constructor(e, i, n, s, r, o, a, l, c, h, u) { this.element = e, this.dropContainer = i, this._ngZone = s, this._viewContainerRef = r, this._dir = a, this._changeDetectorRef = c, this._selfHandle = h, this._parentDrag = u, this._destroyed = new S, this.started = new Ja, this.released = new Ja, this.ended = new Ja, this.entered = new Ja, this.exited = new Ja, this.dropped = new Ja, this.moved = new v(t => { const e = this._dragRef.moved.pipe(E(t => ({ source: this, pointerPosition: t.pointerPosition, event: t.event, delta: t.delta, distance: t.distance }))).subscribe(t); return () => { e.unsubscribe() } }), this._dragRef = l.createDrag(e, { dragStartThreshold: o && null != o.dragStartThreshold ? o.dragStartThreshold : 5, pointerDirectionChangeThreshold: o && null != o.pointerDirectionChangeThreshold ? o.pointerDirectionChangeThreshold : 5, zIndex: null == o ? void 0 : o.zIndex }), this._dragRef.data = this, t._dragInstances.push(this), o && this._assignDefaults(o), i && (this._dragRef._withDropContainer(i._dropListRef), i.addItem(this)), this._syncInputs(this._dragRef), this._handleEvents(this._dragRef) } get disabled() { return this._disabled || this.dropContainer && this.dropContainer.disabled } set disabled(t) { this._disabled = Iv(t), this._dragRef.disabled = this._disabled } getPlaceholderElement() { return this._dragRef.getPlaceholderElement() } getRootElement() { return this._dragRef.getRootElement() } reset() { this._dragRef.reset() } getFreeDragPosition() { return this._dragRef.getFreeDragPosition() } ngAfterViewInit() { this._ngZone.runOutsideAngular(() => { this._ngZone.onStable.pipe(qh(1), Gv(this._destroyed)).subscribe(() => { this._updateRootElement(), this._setupHandlesListener(), this.freeDragPosition && this._dragRef.setFreeDragPosition(this.freeDragPosition) }) }) } ngOnChanges(t) { const e = t.rootElementSelector, i = t.freeDragPosition; e && !e.firstChange && this._updateRootElement(), i && !i.firstChange && this.freeDragPosition && this._dragRef.setFreeDragPosition(this.freeDragPosition) } ngOnDestroy() { this.dropContainer && this.dropContainer.removeItem(this); const e = t._dragInstances.indexOf(this); e > -1 && t._dragInstances.splice(e, 1), this._ngZone.runOutsideAngular(() => { this._destroyed.next(), this._destroyed.complete(), this._dragRef.dispose() }) } _updateRootElement() { const t = this.element.nativeElement, e = this.rootElementSelector ? Ab(t, this.rootElementSelector) : t; this._dragRef.withRootElement(e || t) } _getBoundaryElement() { const t = this.boundaryElement; return t ? "string" == typeof t ? Ab(this.element.nativeElement, t) : jv(t) : null } _syncInputs(e) { e.beforeStarted.subscribe(() => { if (!e.isDragging()) { const t = this._dir, i = this.dragStartDelay, n = this._placeholderTemplate ? { template: this._placeholderTemplate.templateRef, context: this._placeholderTemplate.data, viewContainer: this._viewContainerRef } : null, s = this._previewTemplate ? { template: this._previewTemplate.templateRef, context: this._previewTemplate.data, matchSize: this._previewTemplate.matchSize, viewContainer: this._viewContainerRef } : null; e.disabled = this.disabled, e.lockAxis = this.lockAxis, e.dragStartDelay = "object" == typeof i && i ? i : Lv(i), e.constrainPosition = this.constrainPosition, e.previewClass = this.previewClass, e.withBoundaryElement(this._getBoundaryElement()).withPlaceholderTemplate(n).withPreviewTemplate(s).withPreviewContainer(this.previewContainer || "global"), t && e.withDirection(t.value) } }), e.beforeStarted.pipe(qh(1)).subscribe(() => { var i, n; if (this._parentDrag) return void e.withParent(this._parentDrag._dragRef); let s = this.element.nativeElement.parentElement; for (; s;) { if (null === (i = s.classList) || void 0 === i ? void 0 : i.contains("cdk-drag")) { e.withParent((null === (n = t._dragInstances.find(t => t.element.nativeElement === s)) || void 0 === n ? void 0 : n._dragRef) || null); break } s = s.parentElement } }) } _handleEvents(t) { t.started.subscribe(() => { this.started.emit({ source: this }), this._changeDetectorRef.markForCheck() }), t.released.subscribe(() => { this.released.emit({ source: this }) }), t.ended.subscribe(t => { this.ended.emit({ source: this, distance: t.distance, dropPoint: t.dropPoint }), this._changeDetectorRef.markForCheck() }), t.entered.subscribe(t => { this.entered.emit({ container: t.container.data, item: this, currentIndex: t.currentIndex }) }), t.exited.subscribe(t => { this.exited.emit({ container: t.container.data, item: this }) }), t.dropped.subscribe(t => { this.dropped.emit({ previousIndex: t.previousIndex, currentIndex: t.currentIndex, previousContainer: t.previousContainer.data, container: t.container.data, isPointerOverContainer: t.isPointerOverContainer, item: this, distance: t.distance, dropPoint: t.dropPoint }) }) } _assignDefaults(t) { const { lockAxis: e, dragStartDelay: i, constrainPosition: n, previewClass: s, boundaryElement: r, draggingDisabled: o, rootElementSelector: a, previewContainer: l } = t; this.disabled = null != o && o, this.dragStartDelay = i || 0, e && (this.lockAxis = e), n && (this.constrainPosition = n), s && (this.previewClass = s), r && (this.boundaryElement = r), a && (this.rootElementSelector = a), l && (this.previewContainer = l) } _setupHandlesListener() { this._handles.changes.pipe(Kh(this._handles), vu(t => { const e = t.filter(t => t._parentDrag === this).map(t => t.element); this._selfHandle && this.rootElementSelector && e.push(this.element), this._dragRef.withHandles(e) }), zh(t => q(...t.map(t => t._stateChanges.pipe(Kh(t))))), Gv(this._destroyed)).subscribe(t => { const e = this._dragRef, i = t.element.nativeElement; t.disabled ? e.disableHandle(i) : e.enableHandle(i) }) } } return t.\u0275fac = function (e) { return new (e || t)(Ur(Ko), Ur(kb, 12), Ur(vc), Ur(Vl), Ur(Ma), Ur(xb, 8), Ur(cy, 8), Ur(yb), Ur(wa), Ur(Eb, 10), Ur(bb, 12)) }, t.\u0275dir = Kt({ type: t, selectors: [["", "cdkDrag", ""]], contentQueries: function (t, e, i) { if (1 & t && (dl(i, Pb, 5), dl(i, Tb, 5), dl(i, Eb, 5)), 2 & t) { let t; ul(t = pl()) && (e._previewTemplate = t.first), ul(t = pl()) && (e._placeholderTemplate = t.first), ul(t = pl()) && (e._handles = t) } }, hostAttrs: [1, "cdk-drag"], hostVars: 4, hostBindings: function (t, e) { 2 & t && uo("cdk-drag-disabled", e.disabled)("cdk-drag-dragging", e._dragRef.isDragging()) }, inputs: { disabled: ["cdkDragDisabled", "disabled"], dragStartDelay: ["cdkDragStartDelay", "dragStartDelay"], lockAxis: ["cdkDragLockAxis", "lockAxis"], constrainPosition: ["cdkDragConstrainPosition", "constrainPosition"], previewClass: ["cdkDragPreviewClass", "previewClass"], boundaryElement: ["cdkDragBoundary", "boundaryElement"], rootElementSelector: ["cdkDragRootElement", "rootElementSelector"], previewContainer: ["cdkDragPreviewContainer", "previewContainer"], data: ["cdkDragData", "data"], freeDragPosition: ["cdkDragFreeDragPosition", "freeDragPosition"] }, outputs: { started: "cdkDragStarted", released: "cdkDragReleased", ended: "cdkDragEnded", entered: "cdkDragEntered", exited: "cdkDragExited", dropped: "cdkDragDropped", moved: "cdkDragMoved" }, exportAs: ["cdkDrag"], features: [zo([{ provide: bb, useExisting: t }]), le] }), t._dragInstances = [], t })(); function Ab(t, e) { let i = t.parentElement; for (; i;) { if (i.matches ? i.matches(e) : i.msMatchesSelector(e)) return i; i = i.parentElement } return null } let Ob = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Gt({ type: t }), t.\u0275inj = pt({ providers: [yb], imports: [py] }), t })(); class Rb { } function Mb(t, e) { if (1 & t) { const t = Yr(); Gr(0, "div", 28), Jr("click", function () { const e = Oe(t).$implicit; return so().getDetailsTask(e.id) }), xo(1), Zr() } if (2 & t) { const t = e.$implicit; vs(1), ko("", t.title, " ") } } function Ib(t, e) { if (1 & t) { const t = Yr(); Gr(0, "div", 28), Jr("click", function () { const e = Oe(t).$implicit; return so().getDetailsTask(e.id) }), xo(1), Zr() } if (2 & t) { const t = e.$implicit; vs(1), ko("", t.title, " ") } } function Lb(t, e) { if (1 & t) { const t = Yr(); Gr(0, "div", 28), Jr("click", function () { const e = Oe(t).$implicit; return so().getDetailsTask(e.id) }), xo(1), Zr() } if (2 & t) { const t = e.$implicit; vs(1), ko(" ", t.title, " ") } } const Fb = function (t, e) { return [t, e] }; let Nb = (() => { class t { constructor(t) { this.taskService = t, this.listTaskToDO = [], this.listTaskDone = [], this.listTaskInProgress = [], this.selectedTask = new Rb, this.todo = ["T\xe2che 1", "T\xe2che 2", "T\xe2che 3"], this.inProgress = ["T\xe2che 4", "T\xe2che 5"], this.done = ["T\xe2che 6", "T\xe2che 7"] } ngOnInit() { this.taskService.getTaskByStatusAndMemberId("Done", 1).subscribe(t => { this.listTaskDone = t, console.log(this.listTaskDone) }, t => { console.log(t) }), this.taskService.getTaskByStatusAndMemberId("ToDo", 1).subscribe(t => { this.listTaskToDO = t, console.log(this.listTaskToDO) }, t => { console.log(t) }), this.taskService.getTaskByStatusAndMemberId("InProgress", 1).subscribe(t => { this.listTaskInProgress = t, console.log(this.listTaskInProgress) }, t => { console.log(t) }) } drop(t, e) { console.log("D\xe9but de la fonction drop"), e.previousContainer === e.container ? (console.log("Condition 1"), lb(e.container.data, e.previousIndex, e.currentIndex)) : (console.log("Condition 2"), this.selectedTask = t[e.previousIndex], this.selectedTask && void 0 !== this.selectedTask.id ? console.log("T\xe2che", this.selectedTask.id, "d\xe9plac\xe9e vers la liste appropri\xe9e !") : console.error('La t\xe2che d\xe9plac\xe9e ne contient pas une propri\xe9t\xe9 "id" d\xe9finie correctement.'), function (t, e, i, n) { const s = cb(i, t.length - 1), r = cb(n, e.length); t.length && e.splice(r, 0, t.splice(s, 1)[0]) }(e.previousContainer.data, e.container.data, e.previousIndex, e.currentIndex)), console.log("Fin de la fonction drop"), this.sortLists() } sortLists() { this.listTaskInProgress.sort(), this.listTaskToDO.sort(), this.listTaskDone.sort() } onClear() { this.selectedTask = new Rb } getDetailsTask(t) { this.taskService.taskById(t).subscribe(t => { this.selectedTask = t, console.log("selected task :", this.selectedTask) }, t => { console.log(t) }) } } return t.\u0275fac = function (e) { return new (e || t)(Ur(Xm)) }, t.\u0275cmp = $t({ type: t, selectors: [["app-list-task-par-projet"]], decls: 60, vars: 23, consts: [[1, "header-title"], [1, "lists-container"], [1, "example-container"], [1, "toDO"], ["cdkDropList", "", 1, "example-list", 3, "cdkDropListData", "cdkDropListConnectedTo", "cdkDropListDropped"], ["todoList", "cdkDropList"], ["class", "example-box", "cdkDrag", "", "data-toggle", "modal", "href", "#show-task-modal", 3, "click", 4, "ngFor", "ngForOf"], [1, "inProgress"], ["inProgressList", "cdkDropList"], [1, "done"], ["doneList", "cdkDropList"], ["role", "dialog", "aria-modal", "true", "id", "show-task-modal", 1, "modal", "fade", "bd-example-modal-lg"], ["role", "document", 1, "modal-dialog", "modal-dialog-centered", "modal-lg"], [1, "modal-content"], [1, "modal-header", "d-block", "text-center", "pb-3", "border-bttom"], ["id", "exampleModalCenterTitle", 1, "modal-title"], [1, "modal-body"], [1, "row"], [1, "col-lg-12"], [1, "form-group", "mb-3"], [1, "h5"], ["type", "text", "readonly", "", 1, "form-control", 3, "value"], ["readonly", "", "rows", "3", 1, "form-control", 3, "value"], [1, "col-lg-6"], ["type", "date", "readonly", "", 1, "form-control", 3, "value"], ["readonly", "", 1, "form-control", 3, "value"], [1, "d-flex", "flex-wrap", "align-items-ceter", "justify-content-center", "mt-4"], ["type", "reset", "data-dismiss", "modal", 1, "btn", "btn-danger", 3, "click"], ["cdkDrag", "", "data-toggle", "modal", "href", "#show-task-modal", 1, "example-box", 3, "click"]], template: function (t, e) { if (1 & t && (Gr(0, "div", 0), Gr(1, "h4"), xo(2, "Liste des t\xe2ches du Projet : Titre du projet "), Zr(), Zr(), Kr(3, "br"), Gr(4, "div", 1), Gr(5, "div", 2), Gr(6, "h5", 3), xo(7, "To Do"), Zr(), Gr(8, "div", 4, 5), Jr("cdkDropListDropped", function (t) { return e.drop(e.listTaskToDO, t) }), zr(10, Mb, 2, 1, "div", 6), Zr(), Zr(), Gr(11, "div", 2), Gr(12, "h5", 7), xo(13, "In Progress"), Zr(), Gr(14, "div", 4, 8), Jr("cdkDropListDropped", function (t) { return e.drop(e.listTaskInProgress, t) }), zr(16, Ib, 2, 1, "div", 6), Zr(), Zr(), Gr(17, "div", 2), Gr(18, "h5", 9), xo(19, "Done"), Zr(), Gr(20, "div", 4, 10), Jr("cdkDropListDropped", function (t) { return e.drop(e.listTaskDone, t) }), zr(22, Lb, 2, 1, "div", 6), Zr(), Zr(), Zr(), Gr(23, "div", 11), Gr(24, "div", 12), Gr(25, "div", 13), Gr(26, "div", 14), Gr(27, "h3", 15), xo(28, "Details Task"), Zr(), Zr(), Gr(29, "div", 16), Gr(30, "div", 17), Gr(31, "div", 18), Gr(32, "div", 19), Gr(33, "label", 20), xo(34, "Task Name"), Zr(), Kr(35, "input", 21), Zr(), Zr(), Gr(36, "div", 18), Gr(37, "div", 19), Gr(38, "label", 20), xo(39, "Description"), Zr(), Kr(40, "textarea", 22), Zr(), Zr(), Gr(41, "div", 23), Gr(42, "div", 19), Gr(43, "label", 20), xo(44, "Start Dates"), Zr(), Kr(45, "input", 24), Zr(), Zr(), Gr(46, "div", 23), Gr(47, "div", 19), Gr(48, "label", 20), xo(49, "Start Dates"), Zr(), Kr(50, "input", 24), Zr(), Zr(), Gr(51, "div", 23), Gr(52, "div", 19), Gr(53, "label", 20), xo(54, "Periorty"), Zr(), Kr(55, "input", 25), Zr(), Zr(), Gr(56, "div", 18), Gr(57, "div", 26), Gr(58, "button", 27), Jr("click", function () { return e.onClear() }), xo(59, "Cancel"), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr()), 2 & t) { const t = $r(9), i = $r(15), n = $r(21); vs(8), Wr("cdkDropListData", e.listTaskToDO)("cdkDropListConnectedTo", Ya(14, Fb, i, n)), vs(2), Wr("ngForOf", e.listTaskToDO), vs(4), Wr("cdkDropListData", e.listTaskInProgress)("cdkDropListConnectedTo", Ya(17, Fb, t, n)), vs(2), Wr("ngForOf", e.listTaskInProgress), vs(4), Wr("cdkDropListData", e.listTaskDone)("cdkDropListConnectedTo", Ya(20, Fb, t, i)), vs(2), Wr("ngForOf", e.listTaskDone), vs(13), Wr("value", e.selectedTask.title), vs(5), Wr("value", e.selectedTask.description), vs(5), Wr("value", e.selectedTask.startDate), vs(5), Wr("value", e.selectedTask.dueDate), vs(5), Wr("value", e.selectedTask.priority) } }, directives: [Cb, zc, Db], styles: [".lists-container[_ngcontent-%COMP%]{display:flex;justify-content:space-between;padding:20px}.example-container[_ngcontent-%COMP%]{width:30%;max-width:100%;margin:0;display:inline-block;vertical-align:top;box-shadow:0 0 10px #0000001a;border-radius:10px;overflow:hidden;height:auto}.example-container[_ngcontent-%COMP%]   h5[_ngcontent-%COMP%]{color:#fff;padding:5px;margin:0;text-align:center}.example-list[_ngcontent-%COMP%]{border:1px solid #ccc;min-height:60px;background:#ecf0f1;overflow:hidden;display:block}.example-box[_ngcontent-%COMP%], .example-list[_ngcontent-%COMP%]{border-radius:4px;padding:10px}.example-box[_ngcontent-%COMP%]{color:#000000de;display:flex;flex-direction:row;align-items:center;justify-content:space-between;box-sizing:border-box;cursor:move;background:#fff;font-size:14px;margin-bottom:8px;border:1px solid #bdc3c7}.cdk-drag-preview[_ngcontent-%COMP%]{box-sizing:border-box;border-radius:4px;box-shadow:0 5px 5px -3px #0000004d}.cdk-drag-placeholder[_ngcontent-%COMP%]{opacity:.5;border:2px dashed #3498db;border-radius:4px}.cdk-drag-animating[_ngcontent-%COMP%]{transition:transform .25s cubic-bezier(0,0,.2,1)}.example-box[_ngcontent-%COMP%]:last-child{border:none;margin-bottom:0}.example-list.cdk-drop-list-dragging[_ngcontent-%COMP%]   .example-box[_ngcontent-%COMP%]:not(.cdk-drag-placeholder){transition:transform .25s cubic-bezier(0,0,.2,1)}.toDO[_ngcontent-%COMP%]{background-color:#bf3131}.done[_ngcontent-%COMP%]{background-color:#bed754}.inProgress[_ngcontent-%COMP%]{background-color:#52d3d8}.icons-container[_ngcontent-%COMP%]{display:flex;align-items:center}.icons-container[_ngcontent-%COMP%]   i[_ngcontent-%COMP%]{cursor:pointer;margin-left:10px;font-size:18px;color:#3498db}"] }), t })(); function jb(t, e) { 1 & t && (Gr(0, "tbody"), Gr(1, "tr"), Gr(2, "td", 20), xo(3, "Loading data..."), Zr(), Zr(), Zr()) } function Vb(t, e) { if (1 & t) { const t = Yr(); Gr(0, "tr"), Gr(1, "td"), xo(2), Zr(), Gr(3, "td"), xo(4), Zr(), Gr(5, "td"), xo(6), Zr(), Gr(7, "td"), xo(8), Zr(), Gr(9, "td"), xo(10), Zr(), Gr(11, "td"), xo(12), Zr(), Gr(13, "td"), Gr(14, "a", 21), Jr("click", function () { const e = Oe(t).$implicit; return so(2).openSeeTaskModal(e) }), Kr(15, "i", 22), Zr(), Gr(16, "a", 23), Jr("click", function () { const e = Oe(t).$implicit, i = so(2), n = $r(55); return i.openEditTaskModal(n, e) }), Kr(17, "i", 24), Zr(), Zr(), Zr() } if (2 & t) { const t = e.$implicit; vs(2), So(t.id), vs(2), So(t.title), vs(2), So(t.description), vs(2), So(t.startDate), vs(2), So(t.dueDate), vs(2), So(t.status) } } function Bb(t, e) { if (1 & t && (Gr(0, "tbody"), zr(1, Vb, 18, 6, "tr", 18), Zr()), 2 & t) { const t = so(); vs(1), Wr("ngForOf", t.tasks) } } function Hb(t, e) { if (1 & t && (Gr(0, "li"), xo(1), Zr()), 2 & t) { const t = e.$implicit; vs(1), So(t.fullname) } } function zb(t, e) { if (1 & t && (Gr(0, "option", 39), xo(1), Zr()), 2 & t) { const t = e.$implicit; Wr("ngValue", t.id), vs(1), So(t.name) } } function $b(t, e) { if (1 & t) { const t = Yr(); Gr(0, "div"), Gr(1, "div", 40), Gr(2, "input", 41), Jr("change", function () { const e = Oe(t).$implicit; return so(2).toggleMemberSelection(e) }), Zr(), Gr(3, "label", 42), xo(4), Zr(), Zr(), Zr() } if (2 & t) { const t = e.$implicit, i = so(2); vs(2), Wr("id", "member-" + t.id)("value", t)("checked", i.isMemberSelected(t)), vs(1), Wr("for", "member-" + t.id), vs(1), ko(" ", t.fullname, " ") } } const Ub = function () { return { standalone: !0 } }; function Wb(t, e) { if (1 & t) { const t = Yr(); Gr(0, "div"), Gr(1, "div", 12), Gr(2, "div", 13), Gr(3, "h5", 25), xo(4, "Edit Task"), Zr(), Gr(5, "button", 15), Gr(6, "span", 16), xo(7, "\xd7"), Zr(), Zr(), Zr(), Gr(8, "div", 17), Gr(9, "form"), Gr(10, "div", 26), Gr(11, "label", 27), xo(12, "Title"), Zr(), Gr(13, "input", 28), Jr("ngModelChange", function (e) { return Oe(t), so().selectedTask.title = e }), Zr(), Zr(), Gr(14, "div", 26), Gr(15, "label", 29), xo(16, "Description"), Zr(), Gr(17, "textarea", 30), Jr("ngModelChange", function (e) { return Oe(t), so().selectedTask.description = e }), Zr(), Zr(), Gr(18, "div", 26), Gr(19, "label", 31), xo(20, "Start Date"), Zr(), Gr(21, "input", 32), Jr("ngModelChange", function (e) { return Oe(t), so().selectedTask.startDate = e }), Zr(), Zr(), Gr(22, "div", 26), Gr(23, "label", 33), xo(24, "Due Date"), Zr(), Gr(25, "input", 34), Jr("ngModelChange", function (e) { return Oe(t), so().selectedTask.dueDate = e }), Zr(), Zr(), Gr(26, "div", 26), Gr(27, "label", 35), xo(28, "Status"), Zr(), Gr(29, "select", 36), Jr("ngModelChange", function (e) { return Oe(t), so().selectedTask.status = e }), zr(30, zb, 2, 2, "option", 37), Zr(), Zr(), Gr(31, "div", 26), Gr(32, "label"), xo(33, "Assigned Members"), Zr(), zr(34, $b, 5, 5, "div", 18), Zr(), Gr(35, "button", 38), Jr("click", function () { return Oe(t), so().saveEditedTask() }), xo(36, "Save Changes"), Zr(), Zr(), Zr(), Zr(), Zr() } if (2 & t) { const t = so(); vs(13), Wr("ngModel", t.selectedTask.title)("ngModelOptions", Za(12, Ub)), vs(4), Wr("ngModel", t.selectedTask.description)("ngModelOptions", Za(13, Ub)), vs(4), Wr("ngModel", t.selectedTask.startDate)("ngModelOptions", Za(14, Ub)), vs(4), Wr("ngModel", t.selectedTask.dueDate)("ngModelOptions", Za(15, Ub)), vs(4), Wr("ngModel", t.selectedTask.status)("ngModelOptions", Za(16, Ub)), vs(1), Wr("ngForOf", t.listStatus), vs(4), Wr("ngForOf", t.listMembers) } } let qb = (() => { class t { constructor(t, e, i, n) { this.http = t, this.taskservice = e, this.modalService = i, this.memberservice = n, this.dtOptions = {}, this.dtTrigger = new S, this.loadingData = !1, this.selectedTask = {}, this.listMembers = [], this.listStatus = [{ id: "TODO", name: "Todo" }, { id: "DOING", name: "Doing" }, { id: "DONE", name: "Done" }, { id: "ARCHIVED", name: "Archived" }, { id: "PENDING", name: "Pending" }, { id: "IN_PROGRESS", name: "In Progress" }] } ngOnInit() { let t = 0, e = ""; this.dtOptions = { pagingType: "full_numbers", pageLength: 3, displayStart: t, search: { search: e }, serverSide: !0, processing: !0, lengthMenu: [5, 10, 25], ajax: (i, n) => { t = i.start, e = i.search.value, this.loadingData = !0, this.request = this.http.post("http://devazure.eastus.cloudapp.azure.com:8085/api/tasks/search", i, {}).subscribe(t => { this.loadingData = !1, this.tasks = t.data, n({ recordsTotal: t.recordsTotal, recordsFiltered: t.recordsFiltered, data: [] }) }) }, columns: [{ data: "id" }, { data: "title" }, { data: "description" }, { data: "startDate" }, { data: "dueDate" }, { data: "status" }] } } loadAll() { this.taskservice.getAllTasks().subscribe(t => { this.tasks = t, this.dtTrigger.next() }, t => { console.log(t) }) } openSeeTaskModal(t) { this.selectedTask = t } openEditTaskModal(t, e) { this.selectedTask = e, console.log(this.selectedTask), this.modalRef = this.modalService.show(t) } saveEditedTask() { this.taskservice.updateTask(this.selectedTask).subscribe(t => { var e; console.log("Task updated successfully"), this.loadAll(), null === (e = this.modalRef) || void 0 === e || e.hide() }, t => { console.log("Error updating task: ", t) }) } isMemberSelected(t) { return this.selectedTask.members.some(e => e.id === t.id) } toggleMemberSelection(t) { const e = this.selectedTask.members.findIndex(e => e.id === t.id); e > -1 ? this.selectedTask.members.splice(e, 1) : this.selectedTask.members.push(t) } } return t.\u0275fac = function (e) { return new (e || t)(Ur(bm), Ur(Xm), Ur(vv), Ur(bv)) }, t.\u0275cmp = $t({ type: t, selectors: [["app-list-all-tasks-user"]], decls: 56, vars: 9, consts: [[1, "header-title"], [1, "container-fluid"], [1, "row"], [1, "col-sm-12"], [1, "card"], [1, "card-header", "d-flex", "justify-content-between"], [1, "card-body"], [1, "table-responsive"], ["id", "table", "datatable", "", 1, "display", 2, "width", "100%", 3, "dtOptions"], [4, "ngIf"], ["id", "seeTaskModal", "tabindex", "-1", "role", "dialog", "aria-labelledby", "seeTaskModalLabel", "aria-hidden", "true", 1, "modal", "fade"], ["role", "document", 1, "modal-dialog"], [1, "modal-content"], [1, "modal-header"], ["id", "seeTaskModalLabel", 1, "modal-title"], ["type", "button", "data-dismiss", "modal", "aria-label", "Close", 1, "close"], ["aria-hidden", "true"], [1, "modal-body"], [4, "ngFor", "ngForOf"], ["editTaskModal", ""], ["colspan", "8", 1, "loading-indicator-cell", 2, "text-align", "center"], ["data-toggle", "modal", "data-target", "#seeTaskModal", 1, "btn", "bg-primary-light", "m-1", 3, "click"], [1, "ri-eye-2-line", "m-1"], [1, "btn", "bg-warning-light", "m-1", 3, "click"], [1, "ri-edit-box-line", "m-1"], ["id", "editTaskModalLabel", 1, "modal-title"], [1, "form-group"], ["for", "editTitle"], ["type", "text", "id", "editTitle", 1, "form-control", 3, "ngModel", "ngModelOptions", "ngModelChange"], ["for", "editDescription"], ["id", "editDescription", 1, "form-control", 3, "ngModel", "ngModelOptions", "ngModelChange"], ["for", "editStartDate"], ["type", "date", "id", "editStartDate", 1, "form-control", 3, "ngModel", "ngModelOptions", "ngModelChange"], ["for", "editDueDate"], ["type", "date", "id", "editDueDate", 1, "form-control", 3, "ngModel", "ngModelOptions", "ngModelChange"], ["for", "editStatus"], ["id", "editStatus", 1, "form-control", 3, "ngModel", "ngModelOptions", "ngModelChange"], [3, "ngValue", 4, "ngFor", "ngForOf"], ["type", "button", 1, "btn", "btn-primary", 3, "click"], [3, "ngValue"], [1, "form-check"], ["type", "checkbox", 1, "form-check-input", 3, "id", "value", "checked", "change"], [1, "form-check-label", 3, "for"]], template: function (t, e) { 1 & t && (Gr(0, "div", 0), Gr(1, "h4"), xo(2, "All tasks"), Zr(), Zr(), Kr(3, "br"), Gr(4, "div", 1), Gr(5, "div", 2), Gr(6, "div", 3), Gr(7, "div", 4), Kr(8, "div", 5), Gr(9, "div", 6), Gr(10, "div", 7), Gr(11, "table", 8), Gr(12, "thead"), Gr(13, "tr"), Gr(14, "th"), xo(15, "ID"), Zr(), Gr(16, "th"), xo(17, "Title"), Zr(), Gr(18, "th"), xo(19, "Description"), Zr(), Gr(20, "th"), xo(21, "Start Date"), Zr(), Gr(22, "th"), xo(23, "Due Date"), Zr(), Gr(24, "th"), xo(25, "Status"), Zr(), Gr(26, "th"), xo(27, "Actions"), Zr(), Zr(), Zr(), zr(28, jb, 4, 0, "tbody", 9), zr(29, Bb, 2, 1, "tbody", 9), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Gr(30, "div", 10), Gr(31, "div", 11), Gr(32, "div", 12), Gr(33, "div", 13), Gr(34, "h5", 14), xo(35, "See Task"), Zr(), Gr(36, "button", 15), Gr(37, "span", 16), xo(38, "\xd7"), Zr(), Zr(), Zr(), Gr(39, "div", 17), Gr(40, "p"), xo(41), Zr(), Gr(42, "p"), xo(43), Zr(), Gr(44, "p"), xo(45), Zr(), Gr(46, "p"), xo(47), Zr(), Gr(48, "p"), xo(49), Zr(), Gr(50, "p"), xo(51, "Members:"), Zr(), Gr(52, "ul"), zr(53, Hb, 2, 1, "li", 18), Zr(), Zr(), Zr(), Zr(), Zr(), zr(54, Wb, 37, 17, "ng-template", null, 19, _l)), 2 & t && (vs(11), Wr("dtOptions", e.dtOptions), vs(17), Wr("ngIf", e.loadingData), vs(1), Wr("ngIf", !e.loadingData), vs(12), ko("Title: ", e.selectedTask.title, ""), vs(2), ko("Description: ", e.selectedTask.description, ""), vs(2), ko("Start Date: ", e.selectedTask.startDate, ""), vs(2), ko("Due Date: ", e.selectedTask.dueDate, ""), vs(2), ko("Status: ", e.selectedTask.status, ""), vs(4), Wr("ngForOf", e.selectedTask.members)) }, directives: [wv, Uc, zc, Ig, ig, Ag, Of, eg, Mg, $g, Ug, Zg], styles: [""] }), t })(), Gb = (() => { class t { constructor() { } ngOnInit() { } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = $t({ type: t, selectors: [["app-dashboard-user"]], decls: 82, vars: 0, consts: [[1, "header-title"], [1, "container-fluid"], [1, "row"], [1, "col-md-6", "col-lg-3"], [1, "card", "card-block", "card-stretch", "card-height"], [1, "card-body"], [1, "top-block", "d-flex", "align-items-center", "justify-content-between"], [1, "badge", "badge-primary"], [1, "counter", 2, "visibility", "visible"], [1, "d-flex", "align-items-center", "justify-content-between", "mt-1"], [1, "mb-0"], [1, "text-primary"], [1, "iq-progress-bar", "bg-primary-light", "mt-2"], ["data-percent", "65", 1, "bg-primary", "iq-progress", "progress-1", 2, "transition", "width 2s ease 0s", "width", "65%"], [1, "badge", "badge-warning"], [1, "text-warning"], [1, "iq-progress-bar", "bg-warning-light", "mt-2"], ["data-percent", "35", 1, "bg-warning", "iq-progress", "progress-1", 2, "transition", "width 2s ease 0s", "width", "35%"], [1, "badge", "badge-success"], [1, "text-success"], [1, "iq-progress-bar", "bg-success-light", "mt-2"], ["data-percent", "85", 1, "bg-success", "iq-progress", "progress-1", 2, "transition", "width 2s ease 0s", "width", "85%"], [1, "badge", "badge-info"], [1, "text-info"], [1, "iq-progress-bar", "bg-info-light", "mt-2"], ["data-percent", "55", 1, "bg-info", "iq-progress", "progress-1", 2, "transition", "width 2s ease 0s", "width", "55%"]], template: function (t, e) { 1 & t && (Gr(0, "div", 0), Gr(1, "h4"), xo(2, "Statistiques "), Zr(), Zr(), Kr(3, "br"), Gr(4, "div", 1), Gr(5, "div", 2), Gr(6, "div", 3), Gr(7, "div", 4), Gr(8, "div", 5), Gr(9, "div", 6), Gr(10, "h5"), xo(11, "Investment"), Zr(), Gr(12, "span", 7), xo(13, "Monthly"), Zr(), Zr(), Gr(14, "h3"), xo(15, "$"), Gr(16, "span", 8), xo(17, "35000"), Zr(), Zr(), Gr(18, "div", 9), Gr(19, "p", 10), xo(20, "Total Revenue"), Zr(), Gr(21, "span", 11), xo(22, "65%"), Zr(), Zr(), Gr(23, "div", 12), Kr(24, "span", 13), Zr(), Zr(), Zr(), Zr(), Gr(25, "div", 3), Gr(26, "div", 4), Gr(27, "div", 5), Gr(28, "div", 6), Gr(29, "h5"), xo(30, "Sales"), Zr(), Gr(31, "span", 14), xo(32, "Anual"), Zr(), Zr(), Gr(33, "h3"), xo(34, "$"), Gr(35, "span", 8), xo(36, "25100"), Zr(), Zr(), Gr(37, "div", 9), Gr(38, "p", 10), xo(39, "Total Revenue"), Zr(), Gr(40, "span", 15), xo(41, "35%"), Zr(), Zr(), Gr(42, "div", 16), Kr(43, "span", 17), Zr(), Zr(), Zr(), Zr(), Gr(44, "div", 3), Gr(45, "div", 4), Gr(46, "div", 5), Gr(47, "div", 6), Gr(48, "h5"), xo(49, "Cost"), Zr(), Gr(50, "span", 18), xo(51, "Today"), Zr(), Zr(), Gr(52, "h3"), xo(53, "$"), Gr(54, "span", 8), xo(55, "33000"), Zr(), Zr(), Gr(56, "div", 9), Gr(57, "p", 10), xo(58, "Total Revenue"), Zr(), Gr(59, "span", 19), xo(60, "85%"), Zr(), Zr(), Gr(61, "div", 20), Kr(62, "span", 21), Zr(), Zr(), Zr(), Zr(), Gr(63, "div", 3), Gr(64, "div", 4), Gr(65, "div", 5), Gr(66, "div", 6), Gr(67, "h5"), xo(68, "Profit"), Zr(), Gr(69, "span", 22), xo(70, "Weekly"), Zr(), Zr(), Gr(71, "h3"), xo(72, "$"), Gr(73, "span", 8), xo(74, "2500"), Zr(), Zr(), Gr(75, "div", 9), Gr(76, "p", 10), xo(77, "Total Revenue"), Zr(), Gr(78, "span", 23), xo(79, "55%"), Zr(), Zr(), Gr(80, "div", 24), Kr(81, "span", 25), Zr(), Zr(), Zr(), Zr(), Zr(), Zr()) }, styles: [""] }), t })(); function Zb(t) { return t + .5 | 0 } const Kb = (t, e, i) => Math.max(Math.min(t, i), e); function Yb(t) { return Kb(Zb(2.55 * t), 0, 255) } function Qb(t) { return Kb(Zb(255 * t), 0, 255) } function Xb(t) { return Kb(Zb(t / 2.55) / 100, 0, 1) } function Jb(t) { return Kb(Zb(100 * t), 0, 100) } const tw = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 }, ew = [..."0123456789ABCDEF"], iw = t => ew[15 & t], nw = t => ew[(240 & t) >> 4] + ew[15 & t], sw = t => (240 & t) >> 4 == (15 & t), rw = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/; function ow(t, e, i) { const n = e * Math.min(i, 1 - i), s = (e, s = (e + t / 30) % 12) => i - n * Math.max(Math.min(s - 3, 9 - s, 1), -1); return [s(0), s(8), s(4)] } function aw(t, e, i) { const n = (n, s = (n + t / 60) % 6) => i - i * e * Math.max(Math.min(s, 4 - s, 1), 0); return [n(5), n(3), n(1)] } function lw(t, e, i) { const n = ow(t, 1, .5); let s; for (e + i > 1 && (s = 1 / (e + i), e *= s, i *= s), s = 0; s < 3; s++)n[s] *= 1 - e - i, n[s] += e; return n } function cw(t) { const e = t.r / 255, i = t.g / 255, n = t.b / 255, s = Math.max(e, i, n), r = Math.min(e, i, n), o = (s + r) / 2; let a, l, c; return s !== r && (c = s - r, l = o > .5 ? c / (2 - s - r) : c / (s + r), a = function (t, e, i, n, s) { return t === s ? (e - i) / n + (e < i ? 6 : 0) : e === s ? (i - t) / n + 2 : (t - e) / n + 4 }(e, i, n, c, s), a = 60 * a + .5), [0 | a, l || 0, o] } function hw(t, e, i, n) { return (Array.isArray(e) ? t(e[0], e[1], e[2]) : t(e, i, n)).map(Qb) } function uw(t, e, i) { return hw(ow, t, e, i) } function dw(t) { return (t % 360 + 360) % 360 } const pw = { x: "dark", Z: "light", Y: "re", X: "blu", W: "gr", V: "medium", U: "slate", A: "ee", T: "ol", S: "or", B: "ra", C: "lateg", D: "ights", R: "in", Q: "turquois", E: "hi", P: "ro", O: "al", N: "le", M: "de", L: "yello", F: "en", K: "ch", G: "arks", H: "ea", I: "ightg", J: "wh" }, fw = { OiceXe: "f0f8ff", antiquewEte: "faebd7", aqua: "ffff", aquamarRe: "7fffd4", azuY: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "0", blanKedOmond: "ffebcd", Xe: "ff", XeviTet: "8a2be2", bPwn: "a52a2a", burlywood: "deb887", caMtXe: "5f9ea0", KartYuse: "7fff00", KocTate: "d2691e", cSO: "ff7f50", cSnflowerXe: "6495ed", cSnsilk: "fff8dc", crimson: "dc143c", cyan: "ffff", xXe: "8b", xcyan: "8b8b", xgTMnPd: "b8860b", xWay: "a9a9a9", xgYF: "6400", xgYy: "a9a9a9", xkhaki: "bdb76b", xmagFta: "8b008b", xTivegYF: "556b2f", xSange: "ff8c00", xScEd: "9932cc", xYd: "8b0000", xsOmon: "e9967a", xsHgYF: "8fbc8f", xUXe: "483d8b", xUWay: "2f4f4f", xUgYy: "2f4f4f", xQe: "ced1", xviTet: "9400d3", dAppRk: "ff1493", dApskyXe: "bfff", dimWay: "696969", dimgYy: "696969", dodgerXe: "1e90ff", fiYbrick: "b22222", flSOwEte: "fffaf0", foYstWAn: "228b22", fuKsia: "ff00ff", gaRsbSo: "dcdcdc", ghostwEte: "f8f8ff", gTd: "ffd700", gTMnPd: "daa520", Way: "808080", gYF: "8000", gYFLw: "adff2f", gYy: "808080", honeyMw: "f0fff0", hotpRk: "ff69b4", RdianYd: "cd5c5c", Rdigo: "4b0082", ivSy: "fffff0", khaki: "f0e68c", lavFMr: "e6e6fa", lavFMrXsh: "fff0f5", lawngYF: "7cfc00", NmoncEffon: "fffacd", ZXe: "add8e6", ZcSO: "f08080", Zcyan: "e0ffff", ZgTMnPdLw: "fafad2", ZWay: "d3d3d3", ZgYF: "90ee90", ZgYy: "d3d3d3", ZpRk: "ffb6c1", ZsOmon: "ffa07a", ZsHgYF: "20b2aa", ZskyXe: "87cefa", ZUWay: "778899", ZUgYy: "778899", ZstAlXe: "b0c4de", ZLw: "ffffe0", lime: "ff00", limegYF: "32cd32", lRF: "faf0e6", magFta: "ff00ff", maPon: "800000", VaquamarRe: "66cdaa", VXe: "cd", VScEd: "ba55d3", VpurpN: "9370db", VsHgYF: "3cb371", VUXe: "7b68ee", VsprRggYF: "fa9a", VQe: "48d1cc", VviTetYd: "c71585", midnightXe: "191970", mRtcYam: "f5fffa", mistyPse: "ffe4e1", moccasR: "ffe4b5", navajowEte: "ffdead", navy: "80", Tdlace: "fdf5e6", Tive: "808000", TivedBb: "6b8e23", Sange: "ffa500", SangeYd: "ff4500", ScEd: "da70d6", pOegTMnPd: "eee8aa", pOegYF: "98fb98", pOeQe: "afeeee", pOeviTetYd: "db7093", papayawEp: "ffefd5", pHKpuff: "ffdab9", peru: "cd853f", pRk: "ffc0cb", plum: "dda0dd", powMrXe: "b0e0e6", purpN: "800080", YbeccapurpN: "663399", Yd: "ff0000", Psybrown: "bc8f8f", PyOXe: "4169e1", saddNbPwn: "8b4513", sOmon: "fa8072", sandybPwn: "f4a460", sHgYF: "2e8b57", sHshell: "fff5ee", siFna: "a0522d", silver: "c0c0c0", skyXe: "87ceeb", UXe: "6a5acd", UWay: "708090", UgYy: "708090", snow: "fffafa", sprRggYF: "ff7f", stAlXe: "4682b4", tan: "d2b48c", teO: "8080", tEstN: "d8bfd8", tomato: "ff6347", Qe: "40e0d0", viTet: "ee82ee", JHt: "f5deb3", wEte: "ffffff", wEtesmoke: "f5f5f5", Lw: "ffff00", LwgYF: "9acd32" }; let gw; const mw = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/, _w = t => t <= .0031308 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - .055, vw = t => t <= .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4); function yw(t, e, i) { if (t) { let n = cw(t); n[e] = Math.max(0, Math.min(n[e] + n[e] * i, 0 === e ? 360 : 1)), n = uw(n), t.r = n[0], t.g = n[1], t.b = n[2] } } function bw(t, e) { return t ? Object.assign(e || {}, t) : t } function ww(t) { var e = { r: 0, g: 0, b: 0, a: 255 }; return Array.isArray(t) ? t.length >= 3 && (e = { r: t[0], g: t[1], b: t[2], a: 255 }, t.length > 3 && (e.a = Qb(t[3]))) : (e = bw(t, { r: 0, g: 0, b: 0, a: 1 })).a = Qb(e.a), e } class xw { constructor(t) { if (t instanceof xw) return t; const e = typeof t; let i; var n, s, r; "object" === e ? i = ww(t) : "string" === e && (r = (n = t).length, "#" === n[0] && (4 === r || 5 === r ? s = { r: 255 & 17 * tw[n[1]], g: 255 & 17 * tw[n[2]], b: 255 & 17 * tw[n[3]], a: 5 === r ? 17 * tw[n[4]] : 255 } : 7 !== r && 9 !== r || (s = { r: tw[n[1]] << 4 | tw[n[2]], g: tw[n[3]] << 4 | tw[n[4]], b: tw[n[5]] << 4 | tw[n[6]], a: 9 === r ? tw[n[7]] << 4 | tw[n[8]] : 255 })), i = s || function (t) { gw || (gw = function () { const t = {}, e = Object.keys(fw), i = Object.keys(pw); let n, s, r, o, a; for (n = 0; n < e.length; n++) { for (o = a = e[n], s = 0; s < i.length; s++)r = i[s], a = a.replace(r, pw[r]); r = parseInt(fw[o], 16), t[a] = [r >> 16 & 255, r >> 8 & 255, 255 & r] } return t }(), gw.transparent = [0, 0, 0, 0]); const e = gw[t.toLowerCase()]; return e && { r: e[0], g: e[1], b: e[2], a: 4 === e.length ? e[3] : 255 } }(t) || function (t) { return "r" === t.charAt(0) ? function (t) { const e = mw.exec(t); let i, n, s, r = 255; if (e) { if (e[7] !== i) { const t = +e[7]; r = e[8] ? Yb(t) : Kb(255 * t, 0, 255) } return i = +e[1], n = +e[3], s = +e[5], i = 255 & (e[2] ? Yb(i) : Kb(i, 0, 255)), n = 255 & (e[4] ? Yb(n) : Kb(n, 0, 255)), s = 255 & (e[6] ? Yb(s) : Kb(s, 0, 255)), { r: i, g: n, b: s, a: r } } }(t) : function (t) { const e = rw.exec(t); let i, n = 255; if (!e) return; e[5] !== i && (n = e[6] ? Yb(+e[5]) : Qb(+e[5])); const s = dw(+e[2]), r = +e[3] / 100, o = +e[4] / 100; return i = "hwb" === e[1] ? function (t, e, i) { return hw(lw, t, e, i) }(s, r, o) : "hsv" === e[1] ? function (t, e, i) { return hw(aw, t, e, i) }(s, r, o) : uw(s, r, o), { r: i[0], g: i[1], b: i[2], a: n } }(t) }(t)), this._rgb = i, this._valid = !!i } get valid() { return this._valid } get rgb() { var t = bw(this._rgb); return t && (t.a = Xb(t.a)), t } set rgb(t) { this._rgb = ww(t) } rgbString() { return this._valid ? (t = this._rgb) && (t.a < 255 ? `rgba(${t.r}, ${t.g}, ${t.b}, ${Xb(t.a)})` : `rgb(${t.r}, ${t.g}, ${t.b})`) : void 0; var t } hexString() { return this._valid ? (e = (t => sw(t.r) && sw(t.g) && sw(t.b) && sw(t.a))(t = this._rgb) ? iw : nw, t ? "#" + e(t.r) + e(t.g) + e(t.b) + ((t, e) => t < 255 ? e(t) : "")(t.a, e) : void 0) : void 0; var t, e } hslString() { return this._valid ? function (t) { if (!t) return; const e = cw(t), i = e[0], n = Jb(e[1]), s = Jb(e[2]); return t.a < 255 ? `hsla(${i}, ${n}%, ${s}%, ${Xb(t.a)})` : `hsl(${i}, ${n}%, ${s}%)` }(this._rgb) : void 0 } mix(t, e) { if (t) { const i = this.rgb, n = t.rgb; let s; const r = e === s ? .5 : e, o = 2 * r - 1, a = i.a - n.a, l = ((o * a == -1 ? o : (o + a) / (1 + o * a)) + 1) / 2; s = 1 - l, i.r = 255 & l * i.r + s * n.r + .5, i.g = 255 & l * i.g + s * n.g + .5, i.b = 255 & l * i.b + s * n.b + .5, i.a = r * i.a + (1 - r) * n.a, this.rgb = i } return this } interpolate(t, e) { return t && (this._rgb = function (t, e, i) { const n = vw(Xb(t.r)), s = vw(Xb(t.g)), r = vw(Xb(t.b)); return { r: Qb(_w(n + i * (vw(Xb(e.r)) - n))), g: Qb(_w(s + i * (vw(Xb(e.g)) - s))), b: Qb(_w(r + i * (vw(Xb(e.b)) - r))), a: t.a + i * (e.a - t.a) } }(this._rgb, t._rgb, e)), this } clone() { return new xw(this.rgb) } alpha(t) { return this._rgb.a = Qb(t), this } clearer(t) { return this._rgb.a *= 1 - t, this } greyscale() { const t = this._rgb, e = Zb(.3 * t.r + .59 * t.g + .11 * t.b); return t.r = t.g = t.b = e, this } opaquer(t) { return this._rgb.a *= 1 + t, this } negate() { const t = this._rgb; return t.r = 255 - t.r, t.g = 255 - t.g, t.b = 255 - t.b, this } lighten(t) { return yw(this._rgb, 2, t), this } darken(t) { return yw(this._rgb, 2, -t), this } saturate(t) { return yw(this._rgb, 1, t), this } desaturate(t) { return yw(this._rgb, 1, -t), this } rotate(t) { return function (t, e) { var i = cw(t); i[0] = dw(i[0] + e), i = uw(i), t.r = i[0], t.g = i[1], t.b = i[2] }(this._rgb, t), this } } function Sw() { } const kw = (() => { let t = 0; return () => t++ })(); function Cw(t) { return null == t } function Ew(t) { if (Array.isArray && Array.isArray(t)) return !0; const e = Object.prototype.toString.call(t); return "[object" === e.slice(0, 7) && "Array]" === e.slice(-6) } function Tw(t) { return null !== t && "[object Object]" === Object.prototype.toString.call(t) } function Pw(t) { return ("number" == typeof t || t instanceof Number) && isFinite(+t) } function Dw(t, e) { return Pw(t) ? t : e } function Aw(t, e) { return void 0 === t ? e : t } const Ow = (t, e) => "string" == typeof t && t.endsWith("%") ? parseFloat(t) / 100 * e : +t; function Rw(t, e, i) { if (t && "function" == typeof t.call) return t.apply(i, e) } function Mw(t, e, i, n) { let s, r, o; if (Ew(t)) if (r = t.length, n) for (s = r - 1; s >= 0; s--)e.call(i, t[s], s); else for (s = 0; s < r; s++)e.call(i, t[s], s); else if (Tw(t)) for (o = Object.keys(t), r = o.length, s = 0; s < r; s++)e.call(i, t[o[s]], o[s]) } function Iw(t, e) { let i, n, s, r; if (!t || !e || t.length !== e.length) return !1; for (i = 0, n = t.length; i < n; ++i)if (s = t[i], r = e[i], s.datasetIndex !== r.datasetIndex || s.index !== r.index) return !1; return !0 } function Lw(t) { if (Ew(t)) return t.map(Lw); if (Tw(t)) { const e = Object.create(null), i = Object.keys(t), n = i.length; let s = 0; for (; s < n; ++s)e[i[s]] = Lw(t[i[s]]); return e } return t } function Fw(t) { return -1 === ["__proto__", "prototype", "constructor"].indexOf(t) } function Nw(t, e, i, n) { if (!Fw(t)) return; const s = e[t], r = i[t]; Tw(s) && Tw(r) ? jw(s, r, n) : e[t] = Lw(r) } function jw(t, e, i) { const n = Ew(e) ? e : [e], s = n.length; if (!Tw(t)) return t; const r = (i = i || {}).merger || Nw; let o; for (let a = 0; a < s; ++a) { if (o = n[a], !Tw(o)) continue; const e = Object.keys(o); for (let n = 0, s = e.length; n < s; ++n)r(e[n], t, o, i) } return t } function Vw(t, e) { return jw(t, e, { merger: Bw }) } function Bw(t, e, i) { if (!Fw(t)) return; const n = e[t], s = i[t]; Tw(n) && Tw(s) ? Vw(n, s) : Object.prototype.hasOwnProperty.call(e, t) || (e[t] = Lw(s)) } const Hw = { "": t => t, x: t => t.x, y: t => t.y }; function zw(t, e) { return (Hw[e] || (Hw[e] = function (t) { const e = function (t) { const e = t.split("."), i = []; let n = ""; for (const s of e) n += s, n.endsWith("\\") ? n = n.slice(0, -1) + "." : (i.push(n), n = ""); return i }(t); return t => { for (const i of e) { if ("" === i) break; t = t && t[i] } return t } }(e)))(t) } function $w(t) { return t.charAt(0).toUpperCase() + t.slice(1) } const Uw = t => void 0 !== t, Ww = t => "function" == typeof t, qw = (t, e) => { if (t.size !== e.size) return !1; for (const i of t) if (!e.has(i)) return !1; return !0 }, Gw = Math.PI, Zw = 2 * Gw, Kw = Zw + Gw, Yw = Number.POSITIVE_INFINITY, Qw = Gw / 180, Xw = Gw / 2, Jw = Gw / 4, tx = 2 * Gw / 3, ex = Math.log10, ix = Math.sign; function nx(t, e, i) { return Math.abs(t - e) < i } function sx(t) { const e = Math.round(t); t = nx(t, e, t / 1e3) ? e : t; const i = Math.pow(10, Math.floor(ex(t))), n = t / i; return (n <= 1 ? 1 : n <= 2 ? 2 : n <= 5 ? 5 : 10) * i } function rx(t) { return !isNaN(parseFloat(t)) && isFinite(t) } function ox(t, e, i) { let n, s, r; for (n = 0, s = t.length; n < s; n++)r = t[n][i], isNaN(r) || (e.min = Math.min(e.min, r), e.max = Math.max(e.max, r)) } function ax(t) { return t * (Gw / 180) } function lx(t) { return t * (180 / Gw) } function cx(t) { if (!Pw(t)) return; let e = 1, i = 0; for (; Math.round(t * e) / e !== t;)e *= 10, i++; return i } function hx(t, e) { const i = e.x - t.x, n = e.y - t.y, s = Math.sqrt(i * i + n * n); let r = Math.atan2(n, i); return r < -.5 * Gw && (r += Zw), { angle: r, distance: s } } function ux(t, e) { return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2)) } function dx(t, e) { return (t - e + Kw) % Zw - Gw } function px(t) { return (t % Zw + Zw) % Zw } function fx(t, e, i, n) { const s = px(t), r = px(e), o = px(i), a = px(r - s), l = px(o - s), c = px(s - r), h = px(s - o); return s === r || s === o || n && r === o || a > l && c < h } function gx(t, e, i) { return Math.max(e, Math.min(i, t)) } function mx(t, e, i, n = 1e-6) { return t >= Math.min(e, i) - n && t <= Math.max(e, i) + n } function _x(t, e, i) { i = i || (i => t[i] < e); let n, s = t.length - 1, r = 0; for (; s - r > 1;)n = r + s >> 1, i(n) ? r = n : s = n; return { lo: r, hi: s } } const vx = (t, e, i, n) => _x(t, i, n ? n => { const s = t[n][e]; return s < i || s === i && t[n + 1][e] === i } : n => t[n][e] < i), yx = (t, e, i) => _x(t, i, n => t[n][e] >= i), bx = ["push", "pop", "shift", "splice", "unshift"]; function wx(t, e) { const i = t._chartjs; if (!i) return; const n = i.listeners, s = n.indexOf(e); -1 !== s && n.splice(s, 1), n.length > 0 || (bx.forEach(e => { delete t[e] }), delete t._chartjs) } function xx(t) { const e = new Set(t); return e.size === t.length ? t : Array.from(e) } const Sx = "undefined" == typeof window ? function (t) { return t() } : window.requestAnimationFrame; function kx(t, e) { let i = [], n = !1; return function (...s) { i = s, n || (n = !0, Sx.call(window, () => { n = !1, t.apply(e, i) })) } } const Cx = t => "start" === t ? "left" : "end" === t ? "right" : "center", Ex = (t, e, i) => "start" === t ? e : "end" === t ? i : (e + i) / 2; function Tx(t, e, i) { const n = e.length; let s = 0, r = n; if (t._sorted) { const { iScale: o, _parsed: a } = t, l = o.axis, { min: c, max: h, minDefined: u, maxDefined: d } = o.getUserBounds(); u && (s = gx(Math.min(vx(a, l, c).lo, i ? n : vx(e, l, o.getPixelForValue(c)).lo), 0, n - 1)), r = d ? gx(Math.max(vx(a, o.axis, h, !0).hi + 1, i ? 0 : vx(e, l, o.getPixelForValue(h), !0).hi + 1), s, n) - s : n - s } return { start: s, count: r } } function Px(t) { const { xScale: e, yScale: i, _scaleRanges: n } = t, s = { xmin: e.min, xmax: e.max, ymin: i.min, ymax: i.max }; if (!n) return t._scaleRanges = s, !0; const r = n.xmin !== e.min || n.xmax !== e.max || n.ymin !== i.min || n.ymax !== i.max; return Object.assign(n, s), r } const Dx = t => 0 === t || 1 === t, Ax = (t, e, i) => -Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * Zw / i), Ox = (t, e, i) => Math.pow(2, -10 * t) * Math.sin((t - e) * Zw / i) + 1, Rx = { linear: t => t, easeInQuad: t => t * t, easeOutQuad: t => -t * (t - 2), easeInOutQuad: t => (t /= .5) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1), easeInCubic: t => t * t * t, easeOutCubic: t => (t -= 1) * t * t + 1, easeInOutCubic: t => (t /= .5) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2), easeInQuart: t => t * t * t * t, easeOutQuart: t => -((t -= 1) * t * t * t - 1), easeInOutQuart: t => (t /= .5) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2), easeInQuint: t => t * t * t * t * t, easeOutQuint: t => (t -= 1) * t * t * t * t + 1, easeInOutQuint: t => (t /= .5) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2), easeInSine: t => 1 - Math.cos(t * Xw), easeOutSine: t => Math.sin(t * Xw), easeInOutSine: t => -.5 * (Math.cos(Gw * t) - 1), easeInExpo: t => 0 === t ? 0 : Math.pow(2, 10 * (t - 1)), easeOutExpo: t => 1 === t ? 1 : 1 - Math.pow(2, -10 * t), easeInOutExpo: t => Dx(t) ? t : t < .5 ? .5 * Math.pow(2, 10 * (2 * t - 1)) : .5 * (2 - Math.pow(2, -10 * (2 * t - 1))), easeInCirc: t => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1), easeOutCirc: t => Math.sqrt(1 - (t -= 1) * t), easeInOutCirc: t => (t /= .5) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1), easeInElastic: t => Dx(t) ? t : Ax(t, .075, .3), easeOutElastic: t => Dx(t) ? t : Ox(t, .075, .3), easeInOutElastic(t) { const e = .1125; return Dx(t) ? t : t < .5 ? .5 * Ax(2 * t, e, .45) : .5 + .5 * Ox(2 * t - 1, e, .45) }, easeInBack(t) { const e = 1.70158; return t * t * ((e + 1) * t - e) }, easeOutBack(t) { const e = 1.70158; return (t -= 1) * t * ((e + 1) * t + e) + 1 }, easeInOutBack(t) { let e = 1.70158; return (t /= .5) < 1 ? t * t * ((1 + (e *= 1.525)) * t - e) * .5 : .5 * ((t -= 2) * t * ((1 + (e *= 1.525)) * t + e) + 2) }, easeInBounce: t => 1 - Rx.easeOutBounce(1 - t), easeOutBounce(t) { const e = 7.5625, i = 2.75; return t < 1 / i ? e * t * t : t < 2 / i ? e * (t -= 1.5 / i) * t + .75 : t < 2.5 / i ? e * (t -= 2.25 / i) * t + .9375 : e * (t -= 2.625 / i) * t + .984375 }, easeInOutBounce: t => t < .5 ? .5 * Rx.easeInBounce(2 * t) : .5 * Rx.easeOutBounce(2 * t - 1) + .5 }; function Mx(t) { if (t && "object" == typeof t) { const e = t.toString(); return "[object CanvasPattern]" === e || "[object CanvasGradient]" === e } return !1 } function Ix(t) { return Mx(t) ? t : new xw(t) } function Lx(t) { return Mx(t) ? t : new xw(t).saturate(.5).darken(.1).hexString() } const Fx = ["x", "y", "borderWidth", "radius", "tension"], Nx = ["color", "borderColor", "backgroundColor"], jx = new Map; function Vx(t, e, i) { return function (t, e) { e = e || {}; const i = t + JSON.stringify(e); let n = jx.get(i); return n || (n = new Intl.NumberFormat(t, e), jx.set(i, n)), n }(e, i).format(t) } const Bx = { values: t => Ew(t) ? t : "" + t, numeric(t, e, i) { if (0 === t) return "0"; const n = this.chart.options.locale; let s, r = t; if (i.length > 1) { const e = Math.max(Math.abs(i[0].value), Math.abs(i[i.length - 1].value)); (e < 1e-4 || e > 1e15) && (s = "scientific"), r = function (t, e) { let i = e.length > 3 ? e[2].value - e[1].value : e[1].value - e[0].value; return Math.abs(i) >= 1 && t !== Math.floor(t) && (i = t - Math.floor(t)), i }(t, i) } const o = ex(Math.abs(r)), a = isNaN(o) ? 1 : Math.max(Math.min(-1 * Math.floor(o), 20), 0), l = { notation: s, minimumFractionDigits: a, maximumFractionDigits: a }; return Object.assign(l, this.options.ticks.format), Vx(t, n, l) }, logarithmic(t, e, i) { if (0 === t) return "0"; const n = i[e].significand || t / Math.pow(10, Math.floor(ex(t))); return [1, 2, 3, 5, 10, 15].includes(n) || e > .8 * i.length ? Bx.numeric.call(this, t, e, i) : "" } }; var Hx = { formatters: Bx }; const zx = Object.create(null), $x = Object.create(null); function Ux(t, e) { if (!e) return t; const i = e.split("."); for (let n = 0, s = i.length; n < s; ++n) { const e = i[n]; t = t[e] || (t[e] = Object.create(null)) } return t } function Wx(t, e, i) { return "string" == typeof e ? jw(Ux(t, e), i) : jw(Ux(t, ""), e) } class qx { constructor(t, e) { this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = t => t.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = ["mousemove", "mouseout", "click", "touchstart", "touchmove"], this.font = { family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif", size: 12, style: "normal", lineHeight: 1.2, weight: null }, this.hover = {}, this.hoverBackgroundColor = (t, e) => Lx(e.backgroundColor), this.hoverBorderColor = (t, e) => Lx(e.borderColor), this.hoverColor = (t, e) => Lx(e.color), this.indexAxis = "x", this.interaction = { mode: "nearest", intersect: !0, includeInvisible: !1 }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(t), this.apply(e) } set(t, e) { return Wx(this, t, e) } get(t) { return Ux(this, t) } describe(t, e) { return Wx($x, t, e) } override(t, e) { return Wx(zx, t, e) } route(t, e, i, n) { const s = Ux(this, t), r = Ux(this, i), o = "_" + e; Object.defineProperties(s, { [o]: { value: s[e], writable: !0 }, [e]: { enumerable: !0, get() { const t = this[o], e = r[n]; return Tw(t) ? Object.assign({}, e, t) : Aw(t, e) }, set(t) { this[o] = t } } }) } apply(t) { t.forEach(t => t(this)) } } var Gx = new qx({ _scriptable: t => !t.startsWith("on"), _indexable: t => "events" !== t, hover: { _fallback: "interaction" }, interaction: { _scriptable: !1, _indexable: !1 } }, [function (t) { t.set("animation", { delay: void 0, duration: 1e3, easing: "easeOutQuart", fn: void 0, from: void 0, loop: void 0, to: void 0, type: void 0 }), t.describe("animation", { _fallback: !1, _indexable: !1, _scriptable: t => "onProgress" !== t && "onComplete" !== t && "fn" !== t }), t.set("animations", { colors: { type: "color", properties: Nx }, numbers: { type: "number", properties: Fx } }), t.describe("animations", { _fallback: "animation" }), t.set("transitions", { active: { animation: { duration: 400 } }, resize: { animation: { duration: 0 } }, show: { animations: { colors: { from: "transparent" }, visible: { type: "boolean", duration: 0 } } }, hide: { animations: { colors: { to: "transparent" }, visible: { type: "boolean", easing: "linear", fn: t => 0 | t } } } }) }, function (t) { t.set("layout", { autoPadding: !0, padding: { top: 0, right: 0, bottom: 0, left: 0 } }) }, function (t) { t.set("scale", { display: !0, offset: !1, reverse: !1, beginAtZero: !1, bounds: "ticks", clip: !0, grace: 0, grid: { display: !0, lineWidth: 1, drawOnChartArea: !0, drawTicks: !0, tickLength: 8, tickWidth: (t, e) => e.lineWidth, tickColor: (t, e) => e.color, offset: !1 }, border: { display: !0, dash: [], dashOffset: 0, width: 1 }, title: { display: !1, text: "", padding: { top: 4, bottom: 4 } }, ticks: { minRotation: 0, maxRotation: 50, mirror: !1, textStrokeWidth: 0, textStrokeColor: "", padding: 3, display: !0, autoSkip: !0, autoSkipPadding: 3, labelOffset: 0, callback: Hx.formatters.values, minor: {}, major: {}, align: "center", crossAlign: "near", showLabelBackdrop: !1, backdropColor: "rgba(255, 255, 255, 0.75)", backdropPadding: 2 } }), t.route("scale.ticks", "color", "", "color"), t.route("scale.grid", "color", "", "borderColor"), t.route("scale.border", "color", "", "borderColor"), t.route("scale.title", "color", "", "color"), t.describe("scale", { _fallback: !1, _scriptable: t => !t.startsWith("before") && !t.startsWith("after") && "callback" !== t && "parser" !== t, _indexable: t => "borderDash" !== t && "tickBorderDash" !== t && "dash" !== t }), t.describe("scales", { _fallback: "scale" }), t.describe("scale.ticks", { _scriptable: t => "backdropPadding" !== t && "callback" !== t, _indexable: t => "backdropPadding" !== t }) }]); function Zx(t, e, i, n, s) { let r = e[s]; return r || (r = e[s] = t.measureText(s).width, i.push(s)), r > n && (n = r), n } function Kx(t, e, i, n) { let s = (n = n || {}).data = n.data || {}, r = n.garbageCollect = n.garbageCollect || []; n.font !== e && (s = n.data = {}, r = n.garbageCollect = [], n.font = e), t.save(), t.font = e; let o = 0; const a = i.length; let l, c, h, u, d; for (l = 0; l < a; l++)if (u = i[l], null == u || Ew(u)) { if (Ew(u)) for (c = 0, h = u.length; c < h; c++)d = u[c], null == d || Ew(d) || (o = Zx(t, s, r, o, d)) } else o = Zx(t, s, r, o, u); t.restore(); const p = r.length / 2; if (p > i.length) { for (l = 0; l < p; l++)delete s[r[l]]; r.splice(0, p) } return o } function Yx(t, e, i) { const n = t.currentDevicePixelRatio, s = 0 !== i ? Math.max(i / 2, .5) : 0; return Math.round((e - s) * n) / n + s } function Qx(t, e) { (e = e || t.getContext("2d")).save(), e.resetTransform(), e.clearRect(0, 0, t.width, t.height), e.restore() } function Xx(t, e, i, n) { Jx(t, e, i, n, null) } function Jx(t, e, i, n, s) { let r, o, a, l, c, h, u, d; const p = e.pointStyle, f = e.rotation, g = e.radius; let m = (f || 0) * Qw; if (p && "object" == typeof p && (r = p.toString(), "[object HTMLImageElement]" === r || "[object HTMLCanvasElement]" === r)) return t.save(), t.translate(i, n), t.rotate(m), t.drawImage(p, -p.width / 2, -p.height / 2, p.width, p.height), void t.restore(); if (!(isNaN(g) || g <= 0)) { switch (t.beginPath(), p) { default: s ? t.ellipse(i, n, s / 2, g, 0, 0, Zw) : t.arc(i, n, g, 0, Zw), t.closePath(); break; case "triangle": h = s ? s / 2 : g, t.moveTo(i + Math.sin(m) * h, n - Math.cos(m) * g), m += tx, t.lineTo(i + Math.sin(m) * h, n - Math.cos(m) * g), m += tx, t.lineTo(i + Math.sin(m) * h, n - Math.cos(m) * g), t.closePath(); break; case "rectRounded": c = .516 * g, l = g - c, o = Math.cos(m + Jw) * l, u = Math.cos(m + Jw) * (s ? s / 2 - c : l), a = Math.sin(m + Jw) * l, d = Math.sin(m + Jw) * (s ? s / 2 - c : l), t.arc(i - u, n - a, c, m - Gw, m - Xw), t.arc(i + d, n - o, c, m - Xw, m), t.arc(i + u, n + a, c, m, m + Xw), t.arc(i - d, n + o, c, m + Xw, m + Gw), t.closePath(); break; case "rect": if (!f) { l = Math.SQRT1_2 * g, h = s ? s / 2 : l, t.rect(i - h, n - l, 2 * h, 2 * l); break } m += Jw; case "rectRot": u = Math.cos(m) * (s ? s / 2 : g), o = Math.cos(m) * g, a = Math.sin(m) * g, d = Math.sin(m) * (s ? s / 2 : g), t.moveTo(i - u, n - a), t.lineTo(i + d, n - o), t.lineTo(i + u, n + a), t.lineTo(i - d, n + o), t.closePath(); break; case "crossRot": m += Jw; case "cross": u = Math.cos(m) * (s ? s / 2 : g), o = Math.cos(m) * g, a = Math.sin(m) * g, d = Math.sin(m) * (s ? s / 2 : g), t.moveTo(i - u, n - a), t.lineTo(i + u, n + a), t.moveTo(i + d, n - o), t.lineTo(i - d, n + o); break; case "star": u = Math.cos(m) * (s ? s / 2 : g), o = Math.cos(m) * g, a = Math.sin(m) * g, d = Math.sin(m) * (s ? s / 2 : g), t.moveTo(i - u, n - a), t.lineTo(i + u, n + a), t.moveTo(i + d, n - o), t.lineTo(i - d, n + o), m += Jw, u = Math.cos(m) * (s ? s / 2 : g), o = Math.cos(m) * g, a = Math.sin(m) * g, d = Math.sin(m) * (s ? s / 2 : g), t.moveTo(i - u, n - a), t.lineTo(i + u, n + a), t.moveTo(i + d, n - o), t.lineTo(i - d, n + o); break; case "line": o = s ? s / 2 : Math.cos(m) * g, a = Math.sin(m) * g, t.moveTo(i - o, n - a), t.lineTo(i + o, n + a); break; case "dash": t.moveTo(i, n), t.lineTo(i + Math.cos(m) * (s ? s / 2 : g), n + Math.sin(m) * g); break; case !1: t.closePath() }t.fill(), e.borderWidth > 0 && t.stroke() } } function tS(t, e, i) { return i = i || .5, !e || t && t.x > e.left - i && t.x < e.right + i && t.y > e.top - i && t.y < e.bottom + i } function eS(t, e) { t.save(), t.beginPath(), t.rect(e.left, e.top, e.right - e.left, e.bottom - e.top), t.clip() } function iS(t) { t.restore() } function nS(t, e, i, n, s) { if (!e) return t.lineTo(i.x, i.y); if ("middle" === s) { const n = (e.x + i.x) / 2; t.lineTo(n, e.y), t.lineTo(n, i.y) } else "after" === s != !!n ? t.lineTo(e.x, i.y) : t.lineTo(i.x, e.y); t.lineTo(i.x, i.y) } function sS(t, e, i, n) { if (!e) return t.lineTo(i.x, i.y); t.bezierCurveTo(n ? e.cp1x : e.cp2x, n ? e.cp1y : e.cp2y, n ? i.cp2x : i.cp1x, n ? i.cp2y : i.cp1y, i.x, i.y) } function rS(t, e, i, n, s) { if (s.strikethrough || s.underline) { const r = t.measureText(n), o = e - r.actualBoundingBoxLeft, a = e + r.actualBoundingBoxRight, l = i - r.actualBoundingBoxAscent, c = i + r.actualBoundingBoxDescent, h = s.strikethrough ? (l + c) / 2 : c; t.strokeStyle = t.fillStyle, t.beginPath(), t.lineWidth = s.decorationWidth || 2, t.moveTo(o, h), t.lineTo(a, h), t.stroke() } } function oS(t, e) { const i = t.fillStyle; t.fillStyle = e.color, t.fillRect(e.left, e.top, e.width, e.height), t.fillStyle = i } function aS(t, e, i, n, s, r = {}) { const o = Ew(e) ? e : [e], a = r.strokeWidth > 0 && "" !== r.strokeColor; let l, c; for (t.save(), t.font = s.string, function (t, e) { e.translation && t.translate(e.translation[0], e.translation[1]), Cw(e.rotation) || t.rotate(e.rotation), e.color && (t.fillStyle = e.color), e.textAlign && (t.textAlign = e.textAlign), e.textBaseline && (t.textBaseline = e.textBaseline) }(t, r), l = 0; l < o.length; ++l)c = o[l], r.backdrop && oS(t, r.backdrop), a && (r.strokeColor && (t.strokeStyle = r.strokeColor), Cw(r.strokeWidth) || (t.lineWidth = r.strokeWidth), t.strokeText(c, i, n, r.maxWidth)), t.fillText(c, i, n, r.maxWidth), rS(t, i, n, c, r), n += Number(s.lineHeight); t.restore() } function lS(t, e) { const { x: i, y: n, w: s, h: r, radius: o } = e; t.arc(i + o.topLeft, n + o.topLeft, o.topLeft, 1.5 * Gw, Gw, !0), t.lineTo(i, n + r - o.bottomLeft), t.arc(i + o.bottomLeft, n + r - o.bottomLeft, o.bottomLeft, Gw, Xw, !0), t.lineTo(i + s - o.bottomRight, n + r), t.arc(i + s - o.bottomRight, n + r - o.bottomRight, o.bottomRight, Xw, 0, !0), t.lineTo(i + s, n + o.topRight), t.arc(i + s - o.topRight, n + o.topRight, o.topRight, 0, -Xw, !0), t.lineTo(i + o.topLeft, n) } const cS = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/, hS = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/; function uS(t, e) { const i = ("" + t).match(cS); if (!i || "normal" === i[1]) return 1.2 * e; switch (t = +i[2], i[3]) { case "px": return t; case "%": t /= 100 }return e * t } function dS(t, e) { const i = {}, n = Tw(e), s = n ? Object.keys(e) : e, r = Tw(t) ? n ? i => Aw(t[i], t[e[i]]) : e => t[e] : () => t; for (const o of s) i[o] = +r(o) || 0; return i } function pS(t) { return dS(t, { top: "y", right: "x", bottom: "y", left: "x" }) } function fS(t) { return dS(t, ["topLeft", "topRight", "bottomLeft", "bottomRight"]) } function gS(t) { const e = pS(t); return e.width = e.left + e.right, e.height = e.top + e.bottom, e } function mS(t, e) { let i = Aw((t = t || {}).size, (e = e || Gx.font).size); "string" == typeof i && (i = parseInt(i, 10)); let n = Aw(t.style, e.style); n && !("" + n).match(hS) && (console.warn('Invalid font style specified: "' + n + '"'), n = void 0); const s = { family: Aw(t.family, e.family), lineHeight: uS(Aw(t.lineHeight, e.lineHeight), i), size: i, style: n, weight: Aw(t.weight, e.weight), string: "" }; return s.string = function (t) { return !t || Cw(t.size) || Cw(t.family) ? null : (t.style ? t.style + " " : "") + (t.weight ? t.weight + " " : "") + t.size + "px " + t.family }(s), s } function _S(t, e, i, n) { let s, r, o, a = !0; for (s = 0, r = t.length; s < r; ++s)if (o = t[s], void 0 !== o && (void 0 !== e && "function" == typeof o && (o = o(e), a = !1), void 0 !== i && Ew(o) && (o = o[i % o.length], a = !1), void 0 !== o)) return n && !a && (n.cacheable = !1), o } function vS(t, e) { return Object.assign(Object.create(t), e) } function yS(t, e = [""], i, n, s = (() => t[0])) { const r = i || t; void 0 === n && (n = AS("_fallback", t)); const o = { [Symbol.toStringTag]: "Object", _cacheable: !0, _scopes: t, _rootScopes: r, _fallback: n, _getTarget: s, override: i => yS([i, ...t], e, r, n) }; return new Proxy(o, { deleteProperty: (e, i) => (delete e[i], delete e._keys, delete t[0][i], !0), get: (i, n) => kS(i, n, () => function (t, e, i, n) { let s; for (const r of e) if (s = AS(xS(r, t), i), void 0 !== s) return SS(t, s) ? PS(i, n, t, s) : s }(n, e, t, i)), getOwnPropertyDescriptor: (t, e) => Reflect.getOwnPropertyDescriptor(t._scopes[0], e), getPrototypeOf: () => Reflect.getPrototypeOf(t[0]), has: (t, e) => OS(t).includes(e), ownKeys: t => OS(t), set(t, e, i) { const n = t._storage || (t._storage = s()); return t[e] = n[e] = i, delete t._keys, !0 } }) } function bS(t, e, i, n) { const s = { _cacheable: !1, _proxy: t, _context: e, _subProxy: i, _stack: new Set, _descriptors: wS(t, n), setContext: e => bS(t, e, i, n), override: s => bS(t.override(s), e, i, n) }; return new Proxy(s, { deleteProperty: (e, i) => (delete e[i], delete t[i], !0), get: (t, e, i) => kS(t, e, () => function (t, e, i) { const { _proxy: n, _context: s, _subProxy: r, _descriptors: o } = t; let a = n[e]; return Ww(a) && o.isScriptable(e) && (a = function (t, e, i, n) { const { _proxy: s, _context: r, _subProxy: o, _stack: a } = i; if (a.has(t)) throw new Error("Recursion detected: " + Array.from(a).join("->") + "->" + t); a.add(t); let l = e(r, o || n); return a.delete(t), SS(t, l) && (l = PS(s._scopes, s, t, l)), l }(e, a, t, i)), Ew(a) && a.length && (a = function (t, e, i, n) { const { _proxy: s, _context: r, _subProxy: o, _descriptors: a } = i; if (void 0 !== r.index && n(t)) return e[r.index % e.length]; if (Tw(e[0])) { const i = e, n = s._scopes.filter(t => t !== i); e = []; for (const l of i) { const i = PS(n, s, t, l); e.push(bS(i, r, o && o[t], a)) } } return e }(e, a, t, o.isIndexable)), SS(e, a) && (a = bS(a, s, r && r[e], o)), a }(t, e, i)), getOwnPropertyDescriptor: (e, i) => e._descriptors.allKeys ? Reflect.has(t, i) ? { enumerable: !0, configurable: !0 } : void 0 : Reflect.getOwnPropertyDescriptor(t, i), getPrototypeOf: () => Reflect.getPrototypeOf(t), has: (e, i) => Reflect.has(t, i), ownKeys: () => Reflect.ownKeys(t), set: (e, i, n) => (t[i] = n, delete e[i], !0) }) } function wS(t, e = { scriptable: !0, indexable: !0 }) { const { _scriptable: i = e.scriptable, _indexable: n = e.indexable, _allKeys: s = e.allKeys } = t; return { allKeys: s, scriptable: i, indexable: n, isScriptable: Ww(i) ? i : () => i, isIndexable: Ww(n) ? n : () => n } } const xS = (t, e) => t ? t + $w(e) : e, SS = (t, e) => Tw(e) && "adapters" !== t && (null === Object.getPrototypeOf(e) || e.constructor === Object); function kS(t, e, i) { if (Object.prototype.hasOwnProperty.call(t, e)) return t[e]; const n = i(); return t[e] = n, n } function CS(t, e, i) { return Ww(t) ? t(e, i) : t } const ES = (t, e) => !0 === t ? e : "string" == typeof t ? zw(e, t) : void 0; function TS(t, e, i, n, s) { for (const r of e) { const e = ES(i, r); if (e) { t.add(e); const r = CS(e._fallback, i, s); if (void 0 !== r && r !== i && r !== n) return r } else if (!1 === e && void 0 !== n && i !== n) return null } return !1 } function PS(t, e, i, n) { const s = e._rootScopes, r = CS(e._fallback, i, n), o = [...t, ...s], a = new Set; a.add(n); let l = DS(a, o, i, r || i, n); return null !== l && (void 0 === r || r === i || (l = DS(a, o, r, l, n), null !== l)) && yS(Array.from(a), [""], s, r, () => function (t, e, i) { const n = t._getTarget(); e in n || (n[e] = {}); const s = n[e]; return Ew(s) && Tw(i) ? i : s || {} }(e, i, n)) } function DS(t, e, i, n, s) { for (; i;)i = TS(t, e, i, n, s); return i } function AS(t, e) { for (const i of e) { if (!i) continue; const e = i[t]; if (void 0 !== e) return e } } function OS(t) { let e = t._keys; return e || (e = t._keys = function (t) { const e = new Set; for (const i of t) for (const t of Object.keys(i).filter(t => !t.startsWith("_"))) e.add(t); return Array.from(e) }(t._scopes)), e } function RS(t, e, i, n) { const { iScale: s } = t, { key: r = "r" } = this._parsing, o = new Array(n); let a, l, c, h; for (a = 0, l = n; a < l; ++a)c = a + i, h = e[c], o[a] = { r: s.parse(zw(h, r), c) }; return o } const MS = Number.EPSILON || 1e-14, IS = (t, e) => e < t.length && !t[e].skip && t[e], LS = t => "x" === t ? "y" : "x"; function FS(t, e, i, n) { const s = t.skip ? e : t, r = e, o = i.skip ? e : i, a = ux(r, s), l = ux(o, r); let c = a / (a + l), h = l / (a + l); c = isNaN(c) ? 0 : c, h = isNaN(h) ? 0 : h; const u = n * c, d = n * h; return { previous: { x: r.x - u * (o.x - s.x), y: r.y - u * (o.y - s.y) }, next: { x: r.x + d * (o.x - s.x), y: r.y + d * (o.y - s.y) } } } function NS(t, e, i) { return Math.max(Math.min(t, i), e) } function jS() { return "undefined" != typeof window && "undefined" != typeof document } function VS(t) { let e = t.parentNode; return e && "[object ShadowRoot]" === e.toString() && (e = e.host), e } function BS(t, e, i) { let n; return "string" == typeof t ? (n = parseInt(t, 10), -1 !== t.indexOf("%") && (n = n / 100 * e.parentNode[i])) : n = t, n } const HS = t => t.ownerDocument.defaultView.getComputedStyle(t, null), zS = ["top", "right", "bottom", "left"]; function $S(t, e, i) { const n = {}; i = i ? "-" + i : ""; for (let s = 0; s < 4; s++) { const r = zS[s]; n[r] = parseFloat(t[e + "-" + r + i]) || 0 } return n.width = n.left + n.right, n.height = n.top + n.bottom, n } function US(t, e) { if ("native" in t) return t; const { canvas: i, currentDevicePixelRatio: n } = e, s = HS(i), r = "border-box" === s.boxSizing, o = $S(s, "padding"), a = $S(s, "border", "width"), { x: l, y: c, box: h } = function (t, e) { const i = t.touches, n = i && i.length ? i[0] : t, { offsetX: s, offsetY: r } = n; let o, a, l = !1; if (((t, e, i) => (t > 0 || e > 0) && (!i || !i.shadowRoot))(s, r, t.target)) o = s, a = r; else { const t = e.getBoundingClientRect(); o = n.clientX - t.left, a = n.clientY - t.top, l = !0 } return { x: o, y: a, box: l } }(t, i), u = o.left + (h && a.left), d = o.top + (h && a.top); let { width: p, height: f } = e; return r && (p -= o.width + a.width, f -= o.height + a.height), { x: Math.round((l - u) / p * i.width / n), y: Math.round((c - d) / f * i.height / n) } } const WS = t => Math.round(10 * t) / 10; function qS(t, e, i) { const n = e || 1, s = Math.floor(t.height * n), r = Math.floor(t.width * n); t.height = Math.floor(t.height), t.width = Math.floor(t.width); const o = t.canvas; return o.style && (i || !o.style.height && !o.style.width) && (o.style.height = `${t.height}px`, o.style.width = `${t.width}px`), (t.currentDevicePixelRatio !== n || o.height !== s || o.width !== r) && (t.currentDevicePixelRatio = n, o.height = s, o.width = r, t.ctx.setTransform(n, 0, 0, n, 0, 0), !0) } const GS = function () { let t = !1; try { const e = { get passive() { return t = !0, !1 } }; jS() && (window.addEventListener("test", null, e), window.removeEventListener("test", null, e)) } catch (e) { } return t }(); function ZS(t, e) { const i = function (t, e) { return HS(t).getPropertyValue(e) }(t, e), n = i && i.match(/^(\d+)(\.\d+)?px$/); return n ? +n[1] : void 0 } function KS(t, e, i, n) { return { x: t.x + i * (e.x - t.x), y: t.y + i * (e.y - t.y) } } function YS(t, e, i, n) { return { x: t.x + i * (e.x - t.x), y: "middle" === n ? i < .5 ? t.y : e.y : "after" === n ? i < 1 ? t.y : e.y : i > 0 ? e.y : t.y } } function QS(t, e, i, n) { const s = { x: t.cp2x, y: t.cp2y }, r = { x: e.cp1x, y: e.cp1y }, o = KS(t, s, i), a = KS(s, r, i), l = KS(r, e, i), c = KS(o, a, i), h = KS(a, l, i); return KS(c, h, i) } function XS(t, e, i) { return t ? function (t, e) { return { x: i => t + t + e - i, setWidth(t) { e = t }, textAlign: t => "center" === t ? t : "right" === t ? "left" : "right", xPlus: (t, e) => t - e, leftForLtr: (t, e) => t - e } }(e, i) : { x: t => t, setWidth(t) { }, textAlign: t => t, xPlus: (t, e) => t + e, leftForLtr: (t, e) => t } } function JS(t, e) { let i, n; "ltr" !== e && "rtl" !== e || (i = t.canvas.style, n = [i.getPropertyValue("direction"), i.getPropertyPriority("direction")], i.setProperty("direction", e, "important"), t.prevTextDirection = n) } function tk(t, e) { void 0 !== e && (delete t.prevTextDirection, t.canvas.style.setProperty("direction", e[0], e[1])) } function ek(t) { return "angle" === t ? { between: fx, compare: dx, normalize: px } : { between: mx, compare: (t, e) => t - e, normalize: t => t } } function ik({ start: t, end: e, count: i, loop: n, style: s }) { return { start: t % i, end: e % i, loop: n && (e - t + 1) % i == 0, style: s } } function nk(t, e, i) { if (!i) return [t]; const { property: n, start: s, end: r } = i, o = e.length, { compare: a, between: l, normalize: c } = ek(n), { start: h, end: u, loop: d, style: p } = function (t, e, i) { const { property: n, start: s, end: r } = i, { between: o, normalize: a } = ek(n), l = e.length; let c, h, { start: u, end: d, loop: p } = t; if (p) { for (u += l, d += l, c = 0, h = l; c < h && o(a(e[u % l][n]), s, r); ++c)u--, d--; u %= l, d %= l } return d < u && (d += l), { start: u, end: d, loop: p, style: t.style } }(t, e, i), f = []; let g, m, _, v = !1, y = null; for (let b = h, w = h; b <= u; ++b)m = e[b % o], m.skip || (g = c(m[n]), g !== _ && (v = l(g, s, r), null === y && (v || l(s, _, g) && 0 !== a(s, _)) && (y = 0 === a(g, s) ? b : w), null !== y && (!v || 0 === a(r, g) || l(r, _, g)) && (f.push(ik({ start: y, end: b, loop: d, count: o, style: p })), y = null), w = b, _ = g)); return null !== y && f.push(ik({ start: y, end: u, loop: d, count: o, style: p })), f } function sk(t, e) { const i = [], n = t.segments; for (let s = 0; s < n.length; s++) { const r = nk(n[s], t.points, e); r.length && i.push(...r) } return i } function rk(t) { return { backgroundColor: t.backgroundColor, borderCapStyle: t.borderCapStyle, borderDash: t.borderDash, borderDashOffset: t.borderDashOffset, borderJoinStyle: t.borderJoinStyle, borderWidth: t.borderWidth, borderColor: t.borderColor } } function ok(t, e) { if (!e) return !1; const i = [], n = function (t, e) { return Mx(e) ? (i.includes(e) || i.push(e), i.indexOf(e)) : e }; return JSON.stringify(t, n) !== JSON.stringify(e, n) } class ak { constructor() { this._request = null, this._charts = new Map, this._running = !1, this._lastDate = void 0 } _notify(t, e, i, n) { const s = e.duration; e.listeners[n].forEach(n => n({ chart: t, initial: e.initial, numSteps: s, currentStep: Math.min(i - e.start, s) })) } _refresh() { this._request || (this._running = !0, this._request = Sx.call(window, () => { this._update(), this._request = null, this._running && this._refresh() })) } _update(t = Date.now()) { let e = 0; this._charts.forEach((i, n) => { if (!i.running || !i.items.length) return; const s = i.items; let r, o = s.length - 1, a = !1; for (; o >= 0; --o)r = s[o], r._active ? (r._total > i.duration && (i.duration = r._total), r.tick(t), a = !0) : (s[o] = s[s.length - 1], s.pop()); a && (n.draw(), this._notify(n, i, t, "progress")), s.length || (i.running = !1, this._notify(n, i, t, "complete"), i.initial = !1), e += s.length }), this._lastDate = t, 0 === e && (this._running = !1) } _getAnims(t) { const e = this._charts; let i = e.get(t); return i || (i = { running: !1, initial: !0, items: [], listeners: { complete: [], progress: [] } }, e.set(t, i)), i } listen(t, e, i) { this._getAnims(t).listeners[e].push(i) } add(t, e) { e && e.length && this._getAnims(t).items.push(...e) } has(t) { return this._getAnims(t).items.length > 0 } start(t) { const e = this._charts.get(t); e && (e.running = !0, e.start = Date.now(), e.duration = e.items.reduce((t, e) => Math.max(t, e._duration), 0), this._refresh()) } running(t) { if (!this._running) return !1; const e = this._charts.get(t); return !!(e && e.running && e.items.length) } stop(t) { const e = this._charts.get(t); if (!e || !e.items.length) return; const i = e.items; let n = i.length - 1; for (; n >= 0; --n)i[n].cancel(); e.items = [], this._notify(t, e, Date.now(), "complete") } remove(t) { return this._charts.delete(t) } } var lk = new ak; const ck = "transparent", hk = { boolean: (t, e, i) => i > .5 ? e : t, color(t, e, i) { const n = Ix(t || ck), s = n.valid && Ix(e || ck); return s && s.valid ? s.mix(n, i).hexString() : e }, number: (t, e, i) => t + (e - t) * i }; class uk { constructor(t, e, i, n) { const s = e[i]; n = _S([t.to, n, s, t.from]); const r = _S([t.from, s, n]); this._active = !0, this._fn = t.fn || hk[t.type || typeof r], this._easing = Rx[t.easing] || Rx.linear, this._start = Math.floor(Date.now() + (t.delay || 0)), this._duration = this._total = Math.floor(t.duration), this._loop = !!t.loop, this._target = e, this._prop = i, this._from = r, this._to = n, this._promises = void 0 } active() { return this._active } update(t, e, i) { if (this._active) { this._notify(!1); const n = this._target[this._prop], s = i - this._start, r = this._duration - s; this._start = i, this._duration = Math.floor(Math.max(r, t.duration)), this._total += s, this._loop = !!t.loop, this._to = _S([t.to, e, n, t.from]), this._from = _S([t.from, n, e]) } } cancel() { this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1)) } tick(t) { const e = t - this._start, i = this._duration, n = this._prop, s = this._from, r = this._loop, o = this._to; let a; if (this._active = s !== o && (r || e < i), !this._active) return this._target[n] = o, void this._notify(!0); e < 0 ? this._target[n] = s : (a = e / i % 2, a = r && a > 1 ? 2 - a : a, a = this._easing(Math.min(1, Math.max(0, a))), this._target[n] = this._fn(s, o, a)) } wait() { const t = this._promises || (this._promises = []); return new Promise((e, i) => { t.push({ res: e, rej: i }) }) } _notify(t) { const e = t ? "res" : "rej", i = this._promises || []; for (let n = 0; n < i.length; n++)i[n][e]() } } class dk { constructor(t, e) { this._chart = t, this._properties = new Map, this.configure(e) } configure(t) { if (!Tw(t)) return; const e = Object.keys(Gx.animation), i = this._properties; Object.getOwnPropertyNames(t).forEach(n => { const s = t[n]; if (!Tw(s)) return; const r = {}; for (const t of e) r[t] = s[t]; (Ew(s.properties) && s.properties || [n]).forEach(t => { t !== n && i.has(t) || i.set(t, r) }) }) } _animateOptions(t, e) { const i = e.options, n = function (t, e) { if (!e) return; let i = t.options; if (i) return i.$shared && (t.options = i = Object.assign({}, i, { $shared: !1, $animations: {} })), i; t.options = e }(t, i); if (!n) return []; const s = this._createAnimations(n, i); return i.$shared && function (t, e) { const i = [], n = Object.keys(e); for (let s = 0; s < n.length; s++) { const e = t[n[s]]; e && e.active() && i.push(e.wait()) } return Promise.all(i) }(t.options.$animations, i).then(() => { t.options = i }, () => { }), s } _createAnimations(t, e) { const i = this._properties, n = [], s = t.$animations || (t.$animations = {}), r = Object.keys(e), o = Date.now(); let a; for (a = r.length - 1; a >= 0; --a) { const l = r[a]; if ("$" === l.charAt(0)) continue; if ("options" === l) { n.push(...this._animateOptions(t, e)); continue } const c = e[l]; let h = s[l]; const u = i.get(l); if (h) { if (u && h.active()) { h.update(u, c, o); continue } h.cancel() } u && u.duration ? (s[l] = h = new uk(u, t, l, c), n.push(h)) : t[l] = c } return n } update(t, e) { if (0 === this._properties.size) return void Object.assign(t, e); const i = this._createAnimations(t, e); return i.length ? (lk.add(this._chart, i), !0) : void 0 } } function pk(t, e) { const i = t && t.options || {}, n = i.reverse, s = void 0 === i.min ? e : 0, r = void 0 === i.max ? e : 0; return { start: n ? r : s, end: n ? s : r } } function fk(t, e) { const i = [], n = t._getSortedDatasetMetas(e); let s, r; for (s = 0, r = n.length; s < r; ++s)i.push(n[s].index); return i } function gk(t, e, i, n = {}) { const s = t.keys, r = "single" === n.mode; let o, a, l, c; if (null !== e) { for (o = 0, a = s.length; o < a; ++o) { if (l = +s[o], l === i) { if (n.all) continue; break } c = t.values[l], Pw(c) && (r || 0 === e || ix(e) === ix(c)) && (e += c) } return e } } function mk(t, e) { const i = t && t.options.stacked; return i || void 0 === i && void 0 !== e.stack } function _k(t, e, i) { const n = t[e] || (t[e] = {}); return n[i] || (n[i] = {}) } function vk(t, e, i, n) { for (const s of e.getMatchingVisibleMetas(n).reverse()) { const e = t[s.index]; if (i && e > 0 || !i && e < 0) return s.index } return null } function yk(t, e) { const { chart: i, _cachedMeta: n } = t, s = i._stacks || (i._stacks = {}), { iScale: r, vScale: o, index: a } = n, l = r.axis, c = o.axis, h = function (t, e, i) { return `${t.id}.${e.id}.${i.stack || i.type}` }(r, o, n), u = e.length; let d; for (let p = 0; p < u; ++p) { const t = e[p], { [l]: i, [c]: r } = t; d = (t._stacks || (t._stacks = {}))[c] = _k(s, h, i), d[a] = r, d._top = vk(d, o, !0, n.type), d._bottom = vk(d, o, !1, n.type), (d._visualValues || (d._visualValues = {}))[a] = r } } function bk(t, e) { const i = t.scales; return Object.keys(i).filter(t => i[t].axis === e).shift() } function wk(t, e) { const i = t.controller.index, n = t.vScale && t.vScale.axis; if (n) { e = e || t._parsed; for (const t of e) { const e = t._stacks; if (!e || void 0 === e[n] || void 0 === e[n][i]) return; delete e[n][i], void 0 !== e[n]._visualValues && void 0 !== e[n]._visualValues[i] && delete e[n]._visualValues[i] } } } const xk = t => "reset" === t || "none" === t, Sk = (t, e) => e ? t : Object.assign({}, t); class kk { static defaults = {}; static datasetElementType = null; static dataElementType = null; constructor(t, e) { this.chart = t, this._ctx = t.ctx, this.index = e, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.datasetElementType = new.target.datasetElementType, this.dataElementType = new.target.dataElementType, this.initialize() } initialize() { const t = this._cachedMeta; this.configure(), this.linkScales(), t._stacked = mk(t.vScale, t), this.addElements(), this.options.fill && !this.chart.isPluginEnabled("filler") && console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options") } updateIndex(t) { this.index !== t && wk(this._cachedMeta), this.index = t } linkScales() { const t = this.chart, e = this._cachedMeta, i = this.getDataset(), n = (t, e, i, n) => "x" === t ? e : "r" === t ? n : i, s = e.xAxisID = Aw(i.xAxisID, bk(t, "x")), r = e.yAxisID = Aw(i.yAxisID, bk(t, "y")), o = e.rAxisID = Aw(i.rAxisID, bk(t, "r")), a = e.indexAxis, l = e.iAxisID = n(a, s, r, o), c = e.vAxisID = n(a, r, s, o); e.xScale = this.getScaleForId(s), e.yScale = this.getScaleForId(r), e.rScale = this.getScaleForId(o), e.iScale = this.getScaleForId(l), e.vScale = this.getScaleForId(c) } getDataset() { return this.chart.data.datasets[this.index] } getMeta() { return this.chart.getDatasetMeta(this.index) } getScaleForId(t) { return this.chart.scales[t] } _getOtherScale(t) { const e = this._cachedMeta; return t === e.iScale ? e.vScale : e.iScale } reset() { this._update("reset") } _destroy() { const t = this._cachedMeta; this._data && wx(this._data, this), t._stacked && wk(t) } _dataCheck() { const t = this.getDataset(), e = t.data || (t.data = []), i = this._data; if (Tw(e)) this._data = function (t) { const e = Object.keys(t), i = new Array(e.length); let n, s, r; for (n = 0, s = e.length; n < s; ++n)r = e[n], i[n] = { x: r, y: t[r] }; return i }(e); else if (i !== e) { if (i) { wx(i, this); const t = this._cachedMeta; wk(t), t._parsed = [] } e && Object.isExtensible(e) && ((n = e)._chartjs ? n._chartjs.listeners.push(this) : (Object.defineProperty(n, "_chartjs", { configurable: !0, enumerable: !1, value: { listeners: [this] } }), bx.forEach(t => { const e = "_onData" + $w(t), i = n[t]; Object.defineProperty(n, t, { configurable: !0, enumerable: !1, value(...t) { const s = i.apply(this, t); return n._chartjs.listeners.forEach(i => { "function" == typeof i[e] && i[e](...t) }), s } }) }))), this._syncList = [], this._data = e } var n } addElements() { const t = this._cachedMeta; this._dataCheck(), this.datasetElementType && (t.dataset = new this.datasetElementType) } buildOrUpdateElements(t) { const e = this._cachedMeta, i = this.getDataset(); let n = !1; this._dataCheck(); const s = e._stacked; e._stacked = mk(e.vScale, e), e.stack !== i.stack && (n = !0, wk(e), e.stack = i.stack), this._resyncElements(t), (n || s !== e._stacked) && yk(this, e._parsed) } configure() { const t = this.chart.config, e = t.datasetScopeKeys(this._type), i = t.getOptionScopes(this.getDataset(), e, !0); this.options = t.createResolver(i, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {} } parse(t, e) { const { _cachedMeta: i, _data: n } = this, { iScale: s, _stacked: r } = i, o = s.axis; let a, l, c, h = 0 === t && e === n.length || i._sorted, u = t > 0 && i._parsed[t - 1]; if (!1 === this._parsing) i._parsed = n, i._sorted = !0, c = n; else { c = Ew(n[t]) ? this.parseArrayData(i, n, t, e) : Tw(n[t]) ? this.parseObjectData(i, n, t, e) : this.parsePrimitiveData(i, n, t, e); const s = () => null === l[o] || u && l[o] < u[o]; for (a = 0; a < e; ++a)i._parsed[a + t] = l = c[a], h && (s() && (h = !1), u = l); i._sorted = h } r && yk(this, c) } parsePrimitiveData(t, e, i, n) { const { iScale: s, vScale: r } = t, o = s.axis, a = r.axis, l = s.getLabels(), c = s === r, h = new Array(n); let u, d, p; for (u = 0, d = n; u < d; ++u)p = u + i, h[u] = { [o]: c || s.parse(l[p], p), [a]: r.parse(e[p], p) }; return h } parseArrayData(t, e, i, n) { const { xScale: s, yScale: r } = t, o = new Array(n); let a, l, c, h; for (a = 0, l = n; a < l; ++a)c = a + i, h = e[c], o[a] = { x: s.parse(h[0], c), y: r.parse(h[1], c) }; return o } parseObjectData(t, e, i, n) { const { xScale: s, yScale: r } = t, { xAxisKey: o = "x", yAxisKey: a = "y" } = this._parsing, l = new Array(n); let c, h, u, d; for (c = 0, h = n; c < h; ++c)u = c + i, d = e[u], l[c] = { x: s.parse(zw(d, o), u), y: r.parse(zw(d, a), u) }; return l } getParsed(t) { return this._cachedMeta._parsed[t] } getDataElement(t) { return this._cachedMeta.data[t] } applyStack(t, e, i) { const n = this._cachedMeta, s = e[t.axis]; return gk({ keys: fk(this.chart, !0), values: e._stacks[t.axis]._visualValues }, s, n.index, { mode: i }) } updateRangeFromParsed(t, e, i, n) { const s = i[e.axis]; let r = null === s ? NaN : s; const o = n && i._stacks[e.axis]; n && o && (n.values = o, r = gk(n, s, this._cachedMeta.index)), t.min = Math.min(t.min, r), t.max = Math.max(t.max, r) } getMinMax(t, e) { const i = this._cachedMeta, n = i._parsed, s = i._sorted && t === i.iScale, r = n.length, o = this._getOtherScale(t), a = ((t, e, i) => t && !e.hidden && e._stacked && { keys: fk(this.chart, !0), values: null })(e, i), l = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY }, { min: c, max: h } = function (t) { const { min: e, max: i, minDefined: n, maxDefined: s } = t.getUserBounds(); return { min: n ? e : Number.NEGATIVE_INFINITY, max: s ? i : Number.POSITIVE_INFINITY } }(o); let u, d; function p() { d = n[u]; const e = d[o.axis]; return !Pw(d[t.axis]) || c > e || h < e } for (u = 0; u < r && (p() || (this.updateRangeFromParsed(l, t, d, a), !s)); ++u); if (s) for (u = r - 1; u >= 0; --u)if (!p()) { this.updateRangeFromParsed(l, t, d, a); break } return l } getAllParsedValues(t) { const e = this._cachedMeta._parsed, i = []; let n, s, r; for (n = 0, s = e.length; n < s; ++n)r = e[n][t.axis], Pw(r) && i.push(r); return i } getMaxOverflow() { return !1 } getLabelAndValue(t) { const e = this._cachedMeta, i = e.iScale, n = e.vScale, s = this.getParsed(t); return { label: i ? "" + i.getLabelForValue(s[i.axis]) : "", value: n ? "" + n.getLabelForValue(s[n.axis]) : "" } } _update(t) { const e = this._cachedMeta; this.update(t || "default"), e._clip = function (t) { let e, i, n, s; return Tw(t) ? (e = t.top, i = t.right, n = t.bottom, s = t.left) : e = i = n = s = t, { top: e, right: i, bottom: n, left: s, disabled: !1 === t } }(Aw(this.options.clip, function (t, e, i) { if (!1 === i) return !1; const n = pk(t, i), s = pk(e, i); return { top: s.end, right: n.end, bottom: s.start, left: n.start } }(e.xScale, e.yScale, this.getMaxOverflow()))) } update(t) { } draw() { const t = this._ctx, e = this._cachedMeta, i = e.data || [], n = this.chart.chartArea, s = [], r = this._drawStart || 0, o = this._drawCount || i.length - r, a = this.options.drawActiveElementsOnTop; let l; for (e.dataset && e.dataset.draw(t, n, r, o), l = r; l < r + o; ++l) { const e = i[l]; e.hidden || (e.active && a ? s.push(e) : e.draw(t, n)) } for (l = 0; l < s.length; ++l)s[l].draw(t, n) } getStyle(t, e) { const i = e ? "active" : "default"; return void 0 === t && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(i) : this.resolveDataElementOptions(t || 0, i) } getContext(t, e, i) { const n = this.getDataset(); let s; if (t >= 0 && t < this._cachedMeta.data.length) { const e = this._cachedMeta.data[t]; s = e.$context || (e.$context = function (t, e, i) { return vS(t, { active: !1, dataIndex: e, parsed: void 0, raw: void 0, element: i, index: e, mode: "default", type: "data" }) }(this.getContext(), t, e)), s.parsed = this.getParsed(t), s.raw = n.data[t], s.index = s.dataIndex = t } else s = this.$context || (this.$context = function (t, e) { return vS(t, { active: !1, dataset: void 0, datasetIndex: e, index: e, mode: "default", type: "dataset" }) }(this.chart.getContext(), this.index)), s.dataset = n, s.index = s.datasetIndex = this.index; return s.active = !!e, s.mode = i, s } resolveDatasetElementOptions(t) { return this._resolveElementOptions(this.datasetElementType.id, t) } resolveDataElementOptions(t, e) { return this._resolveElementOptions(this.dataElementType.id, e, t) } _resolveElementOptions(t, e = "default", i) { const n = "active" === e, s = this._cachedDataOpts, r = t + "-" + e, o = s[r], a = this.enableOptionSharing && Uw(i); if (o) return Sk(o, a); const l = this.chart.config, c = l.datasetElementScopeKeys(this._type, t), h = n ? [`${t}Hover`, "hover", t, ""] : [t, ""], u = l.getOptionScopes(this.getDataset(), c), d = Object.keys(Gx.elements[t]), p = l.resolveNamedOptions(u, d, () => this.getContext(i, n, e), h); return p.$shared && (p.$shared = a, s[r] = Object.freeze(Sk(p, a))), p } _resolveAnimations(t, e, i) { const n = this.chart, s = this._cachedDataOpts, r = `animation-${e}`, o = s[r]; if (o) return o; let a; if (!1 !== n.options.animation) { const n = this.chart.config, s = n.datasetAnimationScopeKeys(this._type, e), r = n.getOptionScopes(this.getDataset(), s); a = n.createResolver(r, this.getContext(t, i, e)) } const l = new dk(n, a && a.animations); return a && a._cacheable && (s[r] = Object.freeze(l)), l } getSharedOptions(t) { if (t.$shared) return this._sharedOptions || (this._sharedOptions = Object.assign({}, t)) } includeOptions(t, e) { return !e || xk(t) || this.chart._animationsDisabled } _getSharedOptions(t, e) { const i = this.resolveDataElementOptions(t, e), n = this._sharedOptions, s = this.getSharedOptions(i), r = this.includeOptions(e, s) || s !== n; return this.updateSharedOptions(s, e, i), { sharedOptions: s, includeOptions: r } } updateElement(t, e, i, n) { xk(n) ? Object.assign(t, i) : this._resolveAnimations(e, n).update(t, i) } updateSharedOptions(t, e, i) { t && !xk(e) && this._resolveAnimations(void 0, e).update(t, i) } _setStyle(t, e, i, n) { t.active = n; const s = this.getStyle(e, n); this._resolveAnimations(e, i, n).update(t, { options: !n && this.getSharedOptions(s) || s }) } removeHoverStyle(t, e, i) { this._setStyle(t, i, "active", !1) } setHoverStyle(t, e, i) { this._setStyle(t, i, "active", !0) } _removeDatasetHoverStyle() { const t = this._cachedMeta.dataset; t && this._setStyle(t, void 0, "active", !1) } _setDatasetHoverStyle() { const t = this._cachedMeta.dataset; t && this._setStyle(t, void 0, "active", !0) } _resyncElements(t) { const e = this._data, i = this._cachedMeta.data; for (const [o, a, l] of this._syncList) this[o](a, l); this._syncList = []; const n = i.length, s = e.length, r = Math.min(s, n); r && this.parse(0, r), s > n ? this._insertElements(n, s - n, t) : s < n && this._removeElements(s, n - s) } _insertElements(t, e, i = !0) { const n = this._cachedMeta, s = n.data, r = t + e; let o; const a = t => { for (t.length += e, o = t.length - 1; o >= r; o--)t[o] = t[o - e] }; for (a(s), o = t; o < r; ++o)s[o] = new this.dataElementType; this._parsing && a(n._parsed), this.parse(t, e), i && this.updateElements(s, t, e, "reset") } updateElements(t, e, i, n) { } _removeElements(t, e) { const i = this._cachedMeta; if (this._parsing) { const n = i._parsed.splice(t, e); i._stacked && wk(i, n) } i.data.splice(t, e) } _sync(t) { if (this._parsing) this._syncList.push(t); else { const [e, i, n] = t; this[e](i, n) } this.chart._dataChanges.push([this.index, ...t]) } _onDataPush() { const t = arguments.length; this._sync(["_insertElements", this.getDataset().data.length - t, t]) } _onDataPop() { this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1]) } _onDataShift() { this._sync(["_removeElements", 0, 1]) } _onDataSplice(t, e) { e && this._sync(["_removeElements", t, e]); const i = arguments.length - 2; i && this._sync(["_insertElements", t, i]) } _onDataUnshift() { this._sync(["_insertElements", 0, arguments.length]) } } function Ck(t) { const e = t.iScale, i = function (t, e) { if (!t._cache.$bar) { const i = t.getMatchingVisibleMetas(e); let n = []; for (let e = 0, s = i.length; e < s; e++)n = n.concat(i[e].controller.getAllParsedValues(t)); t._cache.$bar = xx(n.sort((t, e) => t - e)) } return t._cache.$bar }(e, t.type); let n, s, r, o, a = e._length; const l = () => { 32767 !== r && -32768 !== r && (Uw(o) && (a = Math.min(a, Math.abs(r - o) || a)), o = r) }; for (n = 0, s = i.length; n < s; ++n)r = e.getPixelForValue(i[n]), l(); for (o = void 0, n = 0, s = e.ticks.length; n < s; ++n)r = e.getPixelForTick(n), l(); return a } function Ek(t, e, i, n) { return Ew(t) ? function (t, e, i, n) { const s = i.parse(t[0], n), r = i.parse(t[1], n), o = Math.min(s, r), a = Math.max(s, r); let l = o, c = a; Math.abs(o) > Math.abs(a) && (l = a, c = o), e[i.axis] = c, e._custom = { barStart: l, barEnd: c, start: s, end: r, min: o, max: a } }(t, e, i, n) : e[i.axis] = i.parse(t, n), e } function Tk(t, e, i, n) { const s = t.iScale, r = t.vScale, o = s.getLabels(), a = s === r, l = []; let c, h, u, d; for (c = i, h = i + n; c < h; ++c)d = e[c], u = {}, u[s.axis] = a || s.parse(o[c], c), l.push(Ek(d, u, r, c)); return l } function Pk(t) { return t && void 0 !== t.barStart && void 0 !== t.barEnd } function Dk(t, e, i, n) { let s = e.borderSkipped; const r = {}; if (!s) return void (t.borderSkipped = r); if (!0 === s) return void (t.borderSkipped = { top: !0, right: !0, bottom: !0, left: !0 }); const { start: o, end: a, reverse: l, top: c, bottom: h } = function (t) { let e, i, n, s, r; return t.horizontal ? (e = t.base > t.x, i = "left", n = "right") : (e = t.base < t.y, i = "bottom", n = "top"), e ? (s = "end", r = "start") : (s = "start", r = "end"), { start: i, end: n, reverse: e, top: s, bottom: r } }(t); "middle" === s && i && (t.enableBorderRadius = !0, (i._top || 0) === n ? s = c : (i._bottom || 0) === n ? s = h : (r[Ak(h, o, a, l)] = !0, s = c)), r[Ak(s, o, a, l)] = !0, t.borderSkipped = r } function Ak(t, e, i, n) { var s, r, o; return n ? (o = i, t = Ok(t = (s = t) === (r = e) ? o : s === o ? r : s, i, e)) : t = Ok(t, e, i), t } function Ok(t, e, i) { return "start" === t ? e : "end" === t ? i : t } function Rk(t, { inflateAmount: e }, i) { t.inflateAmount = "auto" === e ? 1 === i ? .33 : 0 : e } class Mk extends kk { static id = "doughnut"; static defaults = { datasetElementType: !1, dataElementType: "arc", animation: { animateRotate: !0, animateScale: !1 }, animations: { numbers: { type: "number", properties: ["circumference", "endAngle", "innerRadius", "outerRadius", "startAngle", "x", "y", "offset", "borderWidth", "spacing"] } }, cutout: "50%", rotation: 0, circumference: 360, radius: "100%", spacing: 0, indexAxis: "r" }; static descriptors = { _scriptable: t => "spacing" !== t, _indexable: t => "spacing" !== t && !t.startsWith("borderDash") && !t.startsWith("hoverBorderDash") }; static overrides = { aspectRatio: 1, plugins: { legend: { labels: { generateLabels(t) { const e = t.data; if (e.labels.length && e.datasets.length) { const { labels: { pointStyle: i, color: n } } = t.legend.options; return e.labels.map((e, s) => { const r = t.getDatasetMeta(0).controller.getStyle(s); return { text: e, fillStyle: r.backgroundColor, strokeStyle: r.borderColor, fontColor: n, lineWidth: r.borderWidth, pointStyle: i, hidden: !t.getDataVisibility(s), index: s } }) } return [] } }, onClick(t, e, i) { i.chart.toggleDataVisibility(e.index), i.chart.update() } } } }; constructor(t, e) { super(t, e), this.enableOptionSharing = !0, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0 } linkScales() { } parse(t, e) { const i = this.getDataset().data, n = this._cachedMeta; if (!1 === this._parsing) n._parsed = i; else { let s, r, o = t => +i[t]; if (Tw(i[t])) { const { key: t = "value" } = this._parsing; o = e => +zw(i[e], t) } for (s = t, r = t + e; s < r; ++s)n._parsed[s] = o(s) } } _getRotation() { return ax(this.options.rotation - 90) } _getCircumference() { return ax(this.options.circumference) } _getRotationExtents() { let t = Zw, e = -Zw; for (let i = 0; i < this.chart.data.datasets.length; ++i)if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) { const n = this.chart.getDatasetMeta(i).controller, s = n._getRotation(), r = n._getCircumference(); t = Math.min(t, s), e = Math.max(e, s + r) } return { rotation: t, circumference: e - t } } update(t) { const e = this.chart, { chartArea: i } = e, n = this._cachedMeta, s = n.data, r = this.getMaxBorderWidth() + this.getMaxOffset(s) + this.options.spacing, o = Math.max((Math.min(i.width, i.height) - r) / 2, 0), a = Math.min((c = o, "string" == typeof (l = this.options.cutout) && l.endsWith("%") ? parseFloat(l) / 100 : +l / c), 1); var l, c; const h = this._getRingWeight(this.index), { circumference: u, rotation: d } = this._getRotationExtents(), { ratioX: p, ratioY: f, offsetX: g, offsetY: m } = function (t, e, i) { let n = 1, s = 1, r = 0, o = 0; if (e < Zw) { const a = t, l = a + e, c = Math.cos(a), h = Math.sin(a), u = Math.cos(l), d = Math.sin(l), p = (t, e, n) => fx(t, a, l, !0) ? 1 : Math.max(e, e * i, n, n * i), f = (t, e, n) => fx(t, a, l, !0) ? -1 : Math.min(e, e * i, n, n * i), g = p(0, c, u), m = p(Xw, h, d), _ = f(Gw, c, u), v = f(Gw + Xw, h, d); n = (g - _) / 2, s = (m - v) / 2, r = -(g + _) / 2, o = -(m + v) / 2 } return { ratioX: n, ratioY: s, offsetX: r, offsetY: o } }(d, u, a), _ = Math.max(Math.min((i.width - r) / p, (i.height - r) / f) / 2, 0), v = Ow(this.options.radius, _), y = (v - Math.max(v * a, 0)) / this._getVisibleDatasetWeightTotal(); this.offsetX = g * v, this.offsetY = m * v, n.total = this.calculateTotal(), this.outerRadius = v - y * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - y * h, 0), this.updateElements(s, 0, s.length, t) } _circumference(t, e) { const i = this.options, n = this._cachedMeta, s = this._getCircumference(); return e && i.animation.animateRotate || !this.chart.getDataVisibility(t) || null === n._parsed[t] || n.data[t].hidden ? 0 : this.calculateCircumference(n._parsed[t] * s / Zw) } updateElements(t, e, i, n) { const s = "reset" === n, r = this.chart, o = r.chartArea, a = (o.left + o.right) / 2, l = (o.top + o.bottom) / 2, c = s && r.options.animation.animateScale, h = c ? 0 : this.innerRadius, u = c ? 0 : this.outerRadius, { sharedOptions: d, includeOptions: p } = this._getSharedOptions(e, n); let f, g = this._getRotation(); for (f = 0; f < e; ++f)g += this._circumference(f, s); for (f = e; f < e + i; ++f) { const e = this._circumference(f, s), i = t[f], r = { x: a + this.offsetX, y: l + this.offsetY, startAngle: g, endAngle: g + e, circumference: e, outerRadius: u, innerRadius: h }; p && (r.options = d || this.resolveDataElementOptions(f, i.active ? "active" : n)), g += e, this.updateElement(i, f, r, n) } } calculateTotal() { const t = this._cachedMeta, e = t.data; let i, n = 0; for (i = 0; i < e.length; i++) { const s = t._parsed[i]; null === s || isNaN(s) || !this.chart.getDataVisibility(i) || e[i].hidden || (n += Math.abs(s)) } return n } calculateCircumference(t) { const e = this._cachedMeta.total; return e > 0 && !isNaN(t) ? Zw * (Math.abs(t) / e) : 0 } getLabelAndValue(t) { const e = this.chart, i = e.data.labels || [], n = Vx(this._cachedMeta._parsed[t], e.options.locale); return { label: i[t] || "", value: n } } getMaxBorderWidth(t) { let e = 0; const i = this.chart; let n, s, r, o, a; if (!t) for (n = 0, s = i.data.datasets.length; n < s; ++n)if (i.isDatasetVisible(n)) { r = i.getDatasetMeta(n), t = r.data, o = r.controller; break } if (!t) return 0; for (n = 0, s = t.length; n < s; ++n)a = o.resolveDataElementOptions(n), "inner" !== a.borderAlign && (e = Math.max(e, a.borderWidth || 0, a.hoverBorderWidth || 0)); return e } getMaxOffset(t) { let e = 0; for (let i = 0, n = t.length; i < n; ++i) { const t = this.resolveDataElementOptions(i); e = Math.max(e, t.offset || 0, t.hoverOffset || 0) } return e } _getRingWeightOffset(t) { let e = 0; for (let i = 0; i < t; ++i)this.chart.isDatasetVisible(i) && (e += this._getRingWeight(i)); return e } _getRingWeight(t) { return Math.max(Aw(this.chart.data.datasets[t].weight, 1), 0) } _getVisibleDatasetWeightTotal() { return this._getRingWeightOffset(this.chart.data.datasets.length) || 1 } } class Ik extends kk { static id = "polarArea"; static defaults = { dataElementType: "arc", animation: { animateRotate: !0, animateScale: !0 }, animations: { numbers: { type: "number", properties: ["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"] } }, indexAxis: "r", startAngle: 0 }; static overrides = { aspectRatio: 1, plugins: { legend: { labels: { generateLabels(t) { const e = t.data; if (e.labels.length && e.datasets.length) { const { labels: { pointStyle: i, color: n } } = t.legend.options; return e.labels.map((e, s) => { const r = t.getDatasetMeta(0).controller.getStyle(s); return { text: e, fillStyle: r.backgroundColor, strokeStyle: r.borderColor, fontColor: n, lineWidth: r.borderWidth, pointStyle: i, hidden: !t.getDataVisibility(s), index: s } }) } return [] } }, onClick(t, e, i) { i.chart.toggleDataVisibility(e.index), i.chart.update() } } }, scales: { r: { type: "radialLinear", angleLines: { display: !1 }, beginAtZero: !0, grid: { circular: !0 }, pointLabels: { display: !1 }, startAngle: 0 } } }; constructor(t, e) { super(t, e), this.innerRadius = void 0, this.outerRadius = void 0 } getLabelAndValue(t) { const e = this.chart, i = e.data.labels || [], n = Vx(this._cachedMeta._parsed[t].r, e.options.locale); return { label: i[t] || "", value: n } } parseObjectData(t, e, i, n) { return RS.bind(this)(t, e, i, n) } update(t) { const e = this._cachedMeta.data; this._updateRadius(), this.updateElements(e, 0, e.length, t) } getMinMax() { const t = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY }; return this._cachedMeta.data.forEach((e, i) => { const n = this.getParsed(i).r; !isNaN(n) && this.chart.getDataVisibility(i) && (n < t.min && (t.min = n), n > t.max && (t.max = n)) }), t } _updateRadius() { const t = this.chart, e = t.chartArea, i = t.options, n = Math.min(e.right - e.left, e.bottom - e.top), s = Math.max(n / 2, 0), r = (s - Math.max(i.cutoutPercentage ? s / 100 * i.cutoutPercentage : 1, 0)) / t.getVisibleDatasetCount(); this.outerRadius = s - r * this.index, this.innerRadius = this.outerRadius - r } updateElements(t, e, i, n) { const s = "reset" === n, r = this.chart, o = r.options.animation, a = this._cachedMeta.rScale, l = a.xCenter, c = a.yCenter, h = a.getIndexAngle(0) - .5 * Gw; let u, d = h; const p = 360 / this.countVisibleElements(); for (u = 0; u < e; ++u)d += this._computeAngle(u, n, p); for (u = e; u < e + i; u++) { const e = t[u]; let i = d, f = d + this._computeAngle(u, n, p), g = r.getDataVisibility(u) ? a.getDistanceFromCenterForValue(this.getParsed(u).r) : 0; d = f, s && (o.animateScale && (g = 0), o.animateRotate && (i = f = h)); const m = { x: l, y: c, innerRadius: 0, outerRadius: g, startAngle: i, endAngle: f, options: this.resolveDataElementOptions(u, e.active ? "active" : n) }; this.updateElement(e, u, m, n) } } countVisibleElements() { let t = 0; return this._cachedMeta.data.forEach((e, i) => { !isNaN(this.getParsed(i).r) && this.chart.getDataVisibility(i) && t++ }), t } _computeAngle(t, e, i) { return this.chart.getDataVisibility(t) ? ax(this.resolveDataElementOptions(t, e).angle || i) : 0 } } var Lk = Object.freeze({ __proto__: null, BarController: class extends kk { static id = "bar"; static defaults = { datasetElementType: !1, dataElementType: "bar", categoryPercentage: .8, barPercentage: .9, grouped: !0, animations: { numbers: { type: "number", properties: ["x", "y", "base", "width", "height"] } } }; static overrides = { scales: { _index_: { type: "category", offset: !0, grid: { offset: !0 } }, _value_: { type: "linear", beginAtZero: !0 } } }; parsePrimitiveData(t, e, i, n) { return Tk(t, e, i, n) } parseArrayData(t, e, i, n) { return Tk(t, e, i, n) } parseObjectData(t, e, i, n) { const { iScale: s, vScale: r } = t, { xAxisKey: o = "x", yAxisKey: a = "y" } = this._parsing, l = "x" === s.axis ? o : a, c = "x" === r.axis ? o : a, h = []; let u, d, p, f; for (u = i, d = i + n; u < d; ++u)f = e[u], p = {}, p[s.axis] = s.parse(zw(f, l), u), h.push(Ek(zw(f, c), p, r, u)); return h } updateRangeFromParsed(t, e, i, n) { super.updateRangeFromParsed(t, e, i, n); const s = i._custom; s && e === this._cachedMeta.vScale && (t.min = Math.min(t.min, s.min), t.max = Math.max(t.max, s.max)) } getMaxOverflow() { return 0 } getLabelAndValue(t) { const e = this._cachedMeta, { iScale: i, vScale: n } = e, s = this.getParsed(t), r = s._custom, o = Pk(r) ? "[" + r.start + ", " + r.end + "]" : "" + n.getLabelForValue(s[n.axis]); return { label: "" + i.getLabelForValue(s[i.axis]), value: o } } initialize() { this.enableOptionSharing = !0, super.initialize(), this._cachedMeta.stack = this.getDataset().stack } update(t) { const e = this._cachedMeta; this.updateElements(e.data, 0, e.data.length, t) } updateElements(t, e, i, n) { const s = "reset" === n, { index: r, _cachedMeta: { vScale: o } } = this, a = o.getBasePixel(), l = o.isHorizontal(), c = this._getRuler(), { sharedOptions: h, includeOptions: u } = this._getSharedOptions(e, n); for (let d = e; d < e + i; d++) { const e = this.getParsed(d), i = s || Cw(e[o.axis]) ? { base: a, head: a } : this._calculateBarValuePixels(d), p = this._calculateBarIndexPixels(d, c), f = (e._stacks || {})[o.axis], g = { horizontal: l, base: i.base, enableBorderRadius: !f || Pk(e._custom) || r === f._top || r === f._bottom, x: l ? i.head : p.center, y: l ? p.center : i.head, height: l ? p.size : Math.abs(i.size), width: l ? Math.abs(i.size) : p.size }; u && (g.options = h || this.resolveDataElementOptions(d, t[d].active ? "active" : n)); const m = g.options || t[d].options; Dk(g, m, f, r), Rk(g, m, c.ratio), this.updateElement(t[d], d, g, n) } } _getStacks(t, e) { const { iScale: i } = this._cachedMeta, n = i.getMatchingVisibleMetas(this._type).filter(t => t.controller.options.grouped), s = i.options.stacked, r = [], o = t => { const i = t.controller.getParsed(e), n = i && i[t.vScale.axis]; if (Cw(n) || isNaN(n)) return !0 }; for (const a of n) if ((void 0 === e || !o(a)) && ((!1 === s || -1 === r.indexOf(a.stack) || void 0 === s && void 0 === a.stack) && r.push(a.stack), a.index === t)) break; return r.length || r.push(void 0), r } _getStackCount(t) { return this._getStacks(void 0, t).length } _getStackIndex(t, e, i) { const n = this._getStacks(t, i), s = void 0 !== e ? n.indexOf(e) : -1; return -1 === s ? n.length - 1 : s } _getRuler() { const t = this.options, e = this._cachedMeta, i = e.iScale, n = []; let s, r; for (s = 0, r = e.data.length; s < r; ++s)n.push(i.getPixelForValue(this.getParsed(s)[i.axis], s)); const o = t.barThickness; return { min: o || Ck(e), pixels: n, start: i._startPixel, end: i._endPixel, stackCount: this._getStackCount(), scale: i, grouped: t.grouped, ratio: o ? 1 : t.categoryPercentage * t.barPercentage } } _calculateBarValuePixels(t) { const { _cachedMeta: { vScale: e, _stacked: i, index: n }, options: { base: s, minBarLength: r } } = this, o = s || 0, a = this.getParsed(t), l = a._custom, c = Pk(l); let h, u, d = a[e.axis], p = 0, f = i ? this.applyStack(e, a, i) : d; f !== d && (p = f - d, f = d), c && (d = l.barStart, f = l.barEnd - l.barStart, 0 !== d && ix(d) !== ix(l.barEnd) && (p = 0), p += d); const g = Cw(s) || c ? p : s; let m = e.getPixelForValue(g); if (h = this.chart.getDataVisibility(t) ? e.getPixelForValue(p + f) : m, u = h - m, Math.abs(u) < r) { u = function (t, e, i) { return 0 !== t ? ix(t) : (e.isHorizontal() ? 1 : -1) * (e.min >= i ? 1 : -1) }(u, e, o) * r, d === o && (m -= u / 2); const t = e.getPixelForDecimal(0), s = e.getPixelForDecimal(1), l = Math.min(t, s), p = Math.max(t, s); m = Math.max(Math.min(m, p), l), h = m + u, i && !c && (a._stacks[e.axis]._visualValues[n] = e.getValueForPixel(h) - e.getValueForPixel(m)) } if (m === e.getPixelForValue(o)) { const t = ix(u) * e.getLineWidthForValue(o) / 2; m += t, u -= t } return { size: u, base: m, head: h, center: h + u / 2 } } _calculateBarIndexPixels(t, e) { const i = e.scale, n = this.options, s = n.skipNull, r = Aw(n.maxBarThickness, 1 / 0); let o, a; if (e.grouped) { const i = s ? this._getStackCount(t) : e.stackCount, l = "flex" === n.barThickness ? function (t, e, i, n) { const s = e.pixels, r = s[t]; let o = t > 0 ? s[t - 1] : null, a = t < s.length - 1 ? s[t + 1] : null; const l = i.categoryPercentage; null === o && (o = r - (null === a ? e.end - e.start : a - r)), null === a && (a = r + r - o); const c = r - (r - Math.min(o, a)) / 2 * l; return { chunk: Math.abs(a - o) / 2 * l / n, ratio: i.barPercentage, start: c } }(t, e, n, i) : function (t, e, i, n) { const s = i.barThickness; let r, o; return Cw(s) ? (r = e.min * i.categoryPercentage, o = i.barPercentage) : (r = s * n, o = 1), { chunk: r / n, ratio: o, start: e.pixels[t] - r / 2 } }(t, e, n, i), c = this._getStackIndex(this.index, this._cachedMeta.stack, s ? t : void 0); o = l.start + l.chunk * c + l.chunk / 2, a = Math.min(r, l.chunk * l.ratio) } else o = i.getPixelForValue(this.getParsed(t)[i.axis], t), a = Math.min(r, e.min * e.ratio); return { base: o - a / 2, head: o + a / 2, center: o, size: a } } draw() { const t = this._cachedMeta, e = t.vScale, i = t.data, n = i.length; let s = 0; for (; s < n; ++s)null !== this.getParsed(s)[e.axis] && i[s].draw(this._ctx) } }, BubbleController: class extends kk { static id = "bubble"; static defaults = { datasetElementType: !1, dataElementType: "point", animations: { numbers: { type: "number", properties: ["x", "y", "borderWidth", "radius"] } } }; static overrides = { scales: { x: { type: "linear" }, y: { type: "linear" } } }; initialize() { this.enableOptionSharing = !0, super.initialize() } parsePrimitiveData(t, e, i, n) { const s = super.parsePrimitiveData(t, e, i, n); for (let r = 0; r < s.length; r++)s[r]._custom = this.resolveDataElementOptions(r + i).radius; return s } parseArrayData(t, e, i, n) { const s = super.parseArrayData(t, e, i, n); for (let r = 0; r < s.length; r++)s[r]._custom = Aw(e[i + r][2], this.resolveDataElementOptions(r + i).radius); return s } parseObjectData(t, e, i, n) { const s = super.parseObjectData(t, e, i, n); for (let r = 0; r < s.length; r++) { const t = e[i + r]; s[r]._custom = Aw(t && t.r && +t.r, this.resolveDataElementOptions(r + i).radius) } return s } getMaxOverflow() { const t = this._cachedMeta.data; let e = 0; for (let i = t.length - 1; i >= 0; --i)e = Math.max(e, t[i].size(this.resolveDataElementOptions(i)) / 2); return e > 0 && e } getLabelAndValue(t) { const e = this._cachedMeta, i = this.chart.data.labels || [], { xScale: n, yScale: s } = e, r = this.getParsed(t), o = n.getLabelForValue(r.x), a = s.getLabelForValue(r.y), l = r._custom; return { label: i[t] || "", value: "(" + o + ", " + a + (l ? ", " + l : "") + ")" } } update(t) { const e = this._cachedMeta.data; this.updateElements(e, 0, e.length, t) } updateElements(t, e, i, n) { const s = "reset" === n, { iScale: r, vScale: o } = this._cachedMeta, { sharedOptions: a, includeOptions: l } = this._getSharedOptions(e, n), c = r.axis, h = o.axis; for (let u = e; u < e + i; u++) { const e = t[u], i = !s && this.getParsed(u), d = {}, p = d[c] = s ? r.getPixelForDecimal(.5) : r.getPixelForValue(i[c]), f = d[h] = s ? o.getBasePixel() : o.getPixelForValue(i[h]); d.skip = isNaN(p) || isNaN(f), l && (d.options = a || this.resolveDataElementOptions(u, e.active ? "active" : n), s && (d.options.radius = 0)), this.updateElement(e, u, d, n) } } resolveDataElementOptions(t, e) { const i = this.getParsed(t); let n = super.resolveDataElementOptions(t, e); n.$shared && (n = Object.assign({}, n, { $shared: !1 })); const s = n.radius; return "active" !== e && (n.radius = 0), n.radius += Aw(i && i._custom, s), n } }, DoughnutController: Mk, LineController: class extends kk { static id = "line"; static defaults = { datasetElementType: "line", dataElementType: "point", showLine: !0, spanGaps: !1 }; static overrides = { scales: { _index_: { type: "category" }, _value_: { type: "linear" } } }; initialize() { this.enableOptionSharing = !0, this.supportsDecimation = !0, super.initialize() } update(t) { const e = this._cachedMeta, { dataset: i, data: n = [], _dataset: s } = e, r = this.chart._animationsDisabled; let { start: o, count: a } = Tx(e, n, r); this._drawStart = o, this._drawCount = a, Px(e) && (o = 0, a = n.length), i._chart = this.chart, i._datasetIndex = this.index, i._decimated = !!s._decimated, i.points = n; const l = this.resolveDatasetElementOptions(t); this.options.showLine || (l.borderWidth = 0), l.segment = this.options.segment, this.updateElement(i, void 0, { animated: !r, options: l }, t), this.updateElements(n, o, a, t) } updateElements(t, e, i, n) { const s = "reset" === n, { iScale: r, vScale: o, _stacked: a, _dataset: l } = this._cachedMeta, { sharedOptions: c, includeOptions: h } = this._getSharedOptions(e, n), u = r.axis, d = o.axis, { spanGaps: p, segment: f } = this.options, g = rx(p) ? p : Number.POSITIVE_INFINITY, m = this.chart._animationsDisabled || s || "none" === n, _ = e + i, v = t.length; let y = e > 0 && this.getParsed(e - 1); for (let b = 0; b < v; ++b) { const i = t[b], p = m ? i : {}; if (b < e || b >= _) { p.skip = !0; continue } const v = this.getParsed(b), w = Cw(v[d]), x = p[u] = r.getPixelForValue(v[u], b), S = p[d] = s || w ? o.getBasePixel() : o.getPixelForValue(a ? this.applyStack(o, v, a) : v[d], b); p.skip = isNaN(x) || isNaN(S) || w, p.stop = b > 0 && Math.abs(v[u] - y[u]) > g, f && (p.parsed = v, p.raw = l.data[b]), h && (p.options = c || this.resolveDataElementOptions(b, i.active ? "active" : n)), m || this.updateElement(i, b, p, n), y = v } } getMaxOverflow() { const t = this._cachedMeta, e = t.dataset, i = e.options && e.options.borderWidth || 0, n = t.data || []; if (!n.length) return i; const s = n[0].size(this.resolveDataElementOptions(0)), r = n[n.length - 1].size(this.resolveDataElementOptions(n.length - 1)); return Math.max(i, s, r) / 2 } draw() { const t = this._cachedMeta; t.dataset.updateControlPoints(this.chart.chartArea, t.iScale.axis), super.draw() } }, PieController: class extends Mk { static id = "pie"; static defaults = { cutout: 0, rotation: 0, circumference: 360, radius: "100%" } }, PolarAreaController: Ik, RadarController: class extends kk { static id = "radar"; static defaults = { datasetElementType: "line", dataElementType: "point", indexAxis: "r", showLine: !0, elements: { line: { fill: "start" } } }; static overrides = { aspectRatio: 1, scales: { r: { type: "radialLinear" } } }; getLabelAndValue(t) { const e = this._cachedMeta.vScale, i = this.getParsed(t); return { label: e.getLabels()[t], value: "" + e.getLabelForValue(i[e.axis]) } } parseObjectData(t, e, i, n) { return RS.bind(this)(t, e, i, n) } update(t) { const e = this._cachedMeta, i = e.dataset, n = e.data || [], s = e.iScale.getLabels(); if (i.points = n, "resize" !== t) { const e = this.resolveDatasetElementOptions(t); this.options.showLine || (e.borderWidth = 0), this.updateElement(i, void 0, { _loop: !0, _fullLoop: s.length === n.length, options: e }, t) } this.updateElements(n, 0, n.length, t) } updateElements(t, e, i, n) { const s = this._cachedMeta.rScale, r = "reset" === n; for (let o = e; o < e + i; o++) { const e = t[o], i = this.resolveDataElementOptions(o, e.active ? "active" : n), a = s.getPointPositionForValue(o, this.getParsed(o).r), l = r ? s.xCenter : a.x, c = r ? s.yCenter : a.y, h = { x: l, y: c, angle: a.angle, skip: isNaN(l) || isNaN(c), options: i }; this.updateElement(e, o, h, n) } } }, ScatterController: class extends kk { static id = "scatter"; static defaults = { datasetElementType: !1, dataElementType: "point", showLine: !1, fill: !1 }; static overrides = { interaction: { mode: "point" }, scales: { x: { type: "linear" }, y: { type: "linear" } } }; getLabelAndValue(t) { const e = this._cachedMeta, i = this.chart.data.labels || [], { xScale: n, yScale: s } = e, r = this.getParsed(t), o = n.getLabelForValue(r.x), a = s.getLabelForValue(r.y); return { label: i[t] || "", value: "(" + o + ", " + a + ")" } } update(t) { const e = this._cachedMeta, { data: i = [] } = e, n = this.chart._animationsDisabled; let { start: s, count: r } = Tx(e, i, n); if (this._drawStart = s, this._drawCount = r, Px(e) && (s = 0, r = i.length), this.options.showLine) { this.datasetElementType || this.addElements(); const { dataset: s, _dataset: r } = e; s._chart = this.chart, s._datasetIndex = this.index, s._decimated = !!r._decimated, s.points = i; const o = this.resolveDatasetElementOptions(t); o.segment = this.options.segment, this.updateElement(s, void 0, { animated: !n, options: o }, t) } else this.datasetElementType && (delete e.dataset, this.datasetElementType = !1); this.updateElements(i, s, r, t) } addElements() { const { showLine: t } = this.options; !this.datasetElementType && t && (this.datasetElementType = this.chart.registry.getElement("line")), super.addElements() } updateElements(t, e, i, n) { const s = "reset" === n, { iScale: r, vScale: o, _stacked: a, _dataset: l } = this._cachedMeta, c = this.resolveDataElementOptions(e, n), h = this.getSharedOptions(c), u = this.includeOptions(n, h), d = r.axis, p = o.axis, { spanGaps: f, segment: g } = this.options, m = rx(f) ? f : Number.POSITIVE_INFINITY, _ = this.chart._animationsDisabled || s || "none" === n; let v = e > 0 && this.getParsed(e - 1); for (let y = e; y < e + i; ++y) { const e = t[y], i = this.getParsed(y), c = _ ? e : {}, f = Cw(i[p]), b = c[d] = r.getPixelForValue(i[d], y), w = c[p] = s || f ? o.getBasePixel() : o.getPixelForValue(a ? this.applyStack(o, i, a) : i[p], y); c.skip = isNaN(b) || isNaN(w) || f, c.stop = y > 0 && Math.abs(i[d] - v[d]) > m, g && (c.parsed = i, c.raw = l.data[y]), u && (c.options = h || this.resolveDataElementOptions(y, e.active ? "active" : n)), _ || this.updateElement(e, y, c, n), v = i } this.updateSharedOptions(h, n, c) } getMaxOverflow() { const t = this._cachedMeta, e = t.data || []; if (!this.options.showLine) { let t = 0; for (let i = e.length - 1; i >= 0; --i)t = Math.max(t, e[i].size(this.resolveDataElementOptions(i)) / 2); return t > 0 && t } const i = t.dataset, n = i.options && i.options.borderWidth || 0; if (!e.length) return n; const s = e[0].size(this.resolveDataElementOptions(0)), r = e[e.length - 1].size(this.resolveDataElementOptions(e.length - 1)); return Math.max(n, s, r) / 2 } } }); function Fk() { throw new Error("This method is not implemented: Check that a complete date adapter is provided.") } class Nk { static override(t) { Object.assign(Nk.prototype, t) } options; constructor(t) { this.options = t || {} } init() { } formats() { return Fk() } parse() { return Fk() } format() { return Fk() } add() { return Fk() } diff() { return Fk() } startOf() { return Fk() } endOf() { return Fk() } } var jk = Nk; function Vk(t, e, i, n) { const { controller: s, data: r, _sorted: o } = t, a = s._cachedMeta.iScale; if (a && e === a.axis && "r" !== e && o && r.length) { const t = a._reversePixels ? yx : vx; if (!n) return t(r, e, i); if (s._sharedOptions) { const n = r[0], s = "function" == typeof n.getRange && n.getRange(e); if (s) { const n = t(r, e, i - s), o = t(r, e, i + s); return { lo: n.lo, hi: o.hi } } } } return { lo: 0, hi: r.length - 1 } } function Bk(t, e, i, n, s) { const r = t.getSortedVisibleDatasetMetas(), o = i[e]; for (let a = 0, l = r.length; a < l; ++a) { const { index: t, data: i } = r[a], { lo: l, hi: c } = Vk(r[a], e, o, s); for (let e = l; e <= c; ++e) { const s = i[e]; s.skip || n(s, t, e) } } } function Hk(t, e, i, n, s) { const r = []; return s || t.isPointInArea(e) ? (Bk(t, i, e, function (i, o, a) { (s || tS(i, t.chartArea, 0)) && i.inRange(e.x, e.y, n) && r.push({ element: i, datasetIndex: o, index: a }) }, !0), r) : r } function zk(t, e, i, n, s, r) { return r || t.isPointInArea(e) ? "r" !== i || n ? function (t, e, i, n, s, r) { let o = []; const a = function (t) { const e = -1 !== t.indexOf("x"), i = -1 !== t.indexOf("y"); return function (t, n) { const s = e ? Math.abs(t.x - n.x) : 0, r = i ? Math.abs(t.y - n.y) : 0; return Math.sqrt(Math.pow(s, 2) + Math.pow(r, 2)) } }(i); let l = Number.POSITIVE_INFINITY; return Bk(t, i, e, function (i, c, h) { const u = i.inRange(e.x, e.y, s); if (n && !u) return; const d = i.getCenterPoint(s); if (!r && !t.isPointInArea(d) && !u) return; const p = a(e, d); p < l ? (o = [{ element: i, datasetIndex: c, index: h }], l = p) : p === l && o.push({ element: i, datasetIndex: c, index: h }) }), o }(t, e, i, n, s, r) : function (t, e, i, n) { let s = []; return Bk(t, i, e, function (t, i, r) { const { startAngle: o, endAngle: a } = t.getProps(["startAngle", "endAngle"], n), { angle: l } = hx(t, { x: e.x, y: e.y }); fx(l, o, a) && s.push({ element: t, datasetIndex: i, index: r }) }), s }(t, e, i, s) : [] } function $k(t, e, i, n, s) { const r = [], o = "x" === i ? "inXRange" : "inYRange"; let a = !1; return Bk(t, i, e, (t, n, l) => { t[o](e[i], s) && (r.push({ element: t, datasetIndex: n, index: l }), a = a || t.inRange(e.x, e.y, s)) }), n && !a ? [] : r } var Uk = { evaluateInteractionItems: Bk, modes: { index(t, e, i, n) { const s = US(e, t), r = i.axis || "x", o = i.includeInvisible || !1, a = i.intersect ? Hk(t, s, r, n, o) : zk(t, s, r, !1, n, o), l = []; return a.length ? (t.getSortedVisibleDatasetMetas().forEach(t => { const e = a[0].index, i = t.data[e]; i && !i.skip && l.push({ element: i, datasetIndex: t.index, index: e }) }), l) : [] }, dataset(t, e, i, n) { const s = US(e, t), r = i.axis || "xy", o = i.includeInvisible || !1; let a = i.intersect ? Hk(t, s, r, n, o) : zk(t, s, r, !1, n, o); if (a.length > 0) { const e = a[0].datasetIndex, i = t.getDatasetMeta(e).data; a = []; for (let t = 0; t < i.length; ++t)a.push({ element: i[t], datasetIndex: e, index: t }) } return a }, point: (t, e, i, n) => Hk(t, US(e, t), i.axis || "xy", n, i.includeInvisible || !1), nearest: (t, e, i, n) => zk(t, US(e, t), i.axis || "xy", i.intersect, n, i.includeInvisible || !1), x: (t, e, i, n) => $k(t, US(e, t), "x", i.intersect, n), y: (t, e, i, n) => $k(t, US(e, t), "y", i.intersect, n) } }; const Wk = ["left", "top", "right", "bottom"]; function qk(t, e) { return t.filter(t => t.pos === e) } function Gk(t, e) { return t.filter(t => -1 === Wk.indexOf(t.pos) && t.box.axis === e) } function Zk(t, e) { return t.sort((t, i) => { const n = e ? i : t, s = e ? t : i; return n.weight === s.weight ? n.index - s.index : n.weight - s.weight }) } function Kk(t, e, i, n) { return Math.max(t[i], e[i]) + Math.max(t[n], e[n]) } function Yk(t, e) { t.top = Math.max(t.top, e.top), t.left = Math.max(t.left, e.left), t.bottom = Math.max(t.bottom, e.bottom), t.right = Math.max(t.right, e.right) } function Qk(t, e, i, n) { const { pos: s, box: r } = i, o = t.maxPadding; if (!Tw(s)) { i.size && (t[s] -= i.size); const e = n[i.stack] || { size: 0, count: 1 }; e.size = Math.max(e.size, i.horizontal ? r.height : r.width), i.size = e.size / e.count, t[s] += i.size } r.getPadding && Yk(o, r.getPadding()); const a = Math.max(0, e.outerWidth - Kk(o, t, "left", "right")), l = Math.max(0, e.outerHeight - Kk(o, t, "top", "bottom")), c = a !== t.w, h = l !== t.h; return t.w = a, t.h = l, i.horizontal ? { same: c, other: h } : { same: h, other: c } } function Xk(t, e) { const i = e.maxPadding; return function (t) { const n = { left: 0, top: 0, right: 0, bottom: 0 }; return t.forEach(t => { n[t] = Math.max(e[t], i[t]) }), n }(t ? ["left", "right"] : ["top", "bottom"]) } function Jk(t, e, i, n) { const s = []; let r, o, a, l, c, h; for (r = 0, o = t.length, c = 0; r < o; ++r) { a = t[r], l = a.box, l.update(a.width || e.w, a.height || e.h, Xk(a.horizontal, e)); const { same: o, other: u } = Qk(e, i, a, n); c |= o && s.length, h = h || u, l.fullSize || s.push(a) } return c && Jk(s, e, i, n) || h } function tC(t, e, i, n, s) { t.top = i, t.left = e, t.right = e + n, t.bottom = i + s, t.width = n, t.height = s } function eC(t, e, i, n) { const s = i.padding; let { x: r, y: o } = e; for (const a of t) { const t = a.box, l = n[a.stack] || { count: 1, placed: 0, weight: 1 }, c = a.stackWeight / l.weight || 1; if (a.horizontal) { const n = e.w * c, r = l.size || t.height; Uw(l.start) && (o = l.start), t.fullSize ? tC(t, s.left, o, i.outerWidth - s.right - s.left, r) : tC(t, e.left + l.placed, o, n, r), l.start = o, l.placed += n, o = t.bottom } else { const n = e.h * c, o = l.size || t.width; Uw(l.start) && (r = l.start), t.fullSize ? tC(t, r, s.top, o, i.outerHeight - s.bottom - s.top) : tC(t, r, e.top + l.placed, o, n), l.start = r, l.placed += n, r = t.right } } e.x = r, e.y = o } var iC = { addBox(t, e) { t.boxes || (t.boxes = []), e.fullSize = e.fullSize || !1, e.position = e.position || "top", e.weight = e.weight || 0, e._layers = e._layers || function () { return [{ z: 0, draw(t) { e.draw(t) } }] }, t.boxes.push(e) }, removeBox(t, e) { const i = t.boxes ? t.boxes.indexOf(e) : -1; -1 !== i && t.boxes.splice(i, 1) }, configure(t, e, i) { e.fullSize = i.fullSize, e.position = i.position, e.weight = i.weight }, update(t, e, i, n) { if (!t) return; const s = gS(t.options.layout.padding), r = Math.max(e - s.width, 0), o = Math.max(i - s.height, 0), a = function (t) { const e = function (t) { const e = []; let i, n, s, r, o, a; for (i = 0, n = (t || []).length; i < n; ++i)s = t[i], ({ position: r, options: { stack: o, stackWeight: a = 1 } } = s), e.push({ index: i, box: s, pos: r, horizontal: s.isHorizontal(), weight: s.weight, stack: o && r + o, stackWeight: a }); return e }(t), i = Zk(e.filter(t => t.box.fullSize), !0), n = Zk(qk(e, "left"), !0), s = Zk(qk(e, "right")), r = Zk(qk(e, "top"), !0), o = Zk(qk(e, "bottom")), a = Gk(e, "x"), l = Gk(e, "y"); return { fullSize: i, leftAndTop: n.concat(r), rightAndBottom: s.concat(l).concat(o).concat(a), chartArea: qk(e, "chartArea"), vertical: n.concat(s).concat(l), horizontal: r.concat(o).concat(a) } }(t.boxes), l = a.vertical, c = a.horizontal; Mw(t.boxes, t => { "function" == typeof t.beforeLayout && t.beforeLayout() }); const h = l.reduce((t, e) => e.box.options && !1 === e.box.options.display ? t : t + 1, 0) || 1, u = Object.freeze({ outerWidth: e, outerHeight: i, padding: s, availableWidth: r, availableHeight: o, vBoxMaxWidth: r / 2 / h, hBoxMaxHeight: o / 2 }), d = Object.assign({}, s); Yk(d, gS(n)); const p = Object.assign({ maxPadding: d, w: r, h: o, x: s.left, y: s.top }, s), f = function (t, e) { const i = function (t) { const e = {}; for (const i of t) { const { stack: t, pos: n, stackWeight: s } = i; if (!t || !Wk.includes(n)) continue; const r = e[t] || (e[t] = { count: 0, placed: 0, weight: 0, size: 0 }); r.count++, r.weight += s } return e }(t), { vBoxMaxWidth: n, hBoxMaxHeight: s } = e; let r, o, a; for (r = 0, o = t.length; r < o; ++r) { a = t[r]; const { fullSize: o } = a.box, l = i[a.stack], c = l && a.stackWeight / l.weight; a.horizontal ? (a.width = c ? c * n : o && e.availableWidth, a.height = s) : (a.width = n, a.height = c ? c * s : o && e.availableHeight) } return i }(l.concat(c), u); Jk(a.fullSize, p, u, f), Jk(l, p, u, f), Jk(c, p, u, f) && Jk(l, p, u, f), function (t) { const e = t.maxPadding; function i(i) { const n = Math.max(e[i] - t[i], 0); return t[i] += n, n } t.y += i("top"), t.x += i("left"), i("right"), i("bottom") }(p), eC(a.leftAndTop, p, u, f), p.x += p.w, p.y += p.h, eC(a.rightAndBottom, p, u, f), t.chartArea = { left: p.left, top: p.top, right: p.left + p.w, bottom: p.top + p.h, height: p.h, width: p.w }, Mw(a.chartArea, e => { const i = e.box; Object.assign(i, t.chartArea), i.update(p.w, p.h, { left: 0, top: 0, right: 0, bottom: 0 }) }) } }; class nC { acquireContext(t, e) { } releaseContext(t) { return !1 } addEventListener(t, e, i) { } removeEventListener(t, e, i) { } getDevicePixelRatio() { return 1 } getMaximumSize(t, e, i, n) { return e = Math.max(0, e || t.width), i = i || t.height, { width: e, height: Math.max(0, n ? Math.floor(e / n) : i) } } isAttached(t) { return !0 } updateConfig(t) { } } class sC extends nC { acquireContext(t) { return t && t.getContext && t.getContext("2d") || null } updateConfig(t) { t.options.animation = !1 } } const rC = { touchstart: "mousedown", touchmove: "mousemove", touchend: "mouseup", pointerenter: "mouseenter", pointerdown: "mousedown", pointermove: "mousemove", pointerup: "mouseup", pointerleave: "mouseout", pointerout: "mouseout" }, oC = t => null === t || "" === t, aC = !!GS && { passive: !0 }; function lC(t, e, i) { t.canvas.removeEventListener(e, i, aC) } function cC(t, e) { for (const i of t) if (i === e || i.contains(e)) return !0 } function hC(t, e, i) { const n = t.canvas, s = new MutationObserver(t => { let e = !1; for (const i of t) e = e || cC(i.addedNodes, n), e = e && !cC(i.removedNodes, n); e && i() }); return s.observe(document, { childList: !0, subtree: !0 }), s } function uC(t, e, i) { const n = t.canvas, s = new MutationObserver(t => { let e = !1; for (const i of t) e = e || cC(i.removedNodes, n), e = e && !cC(i.addedNodes, n); e && i() }); return s.observe(document, { childList: !0, subtree: !0 }), s } const dC = new Map; let pC = 0; function fC() { const t = window.devicePixelRatio; t !== pC && (pC = t, dC.forEach((e, i) => { i.currentDevicePixelRatio !== t && e() })) } function gC(t, e, i) { const n = t.canvas, s = n && VS(n); if (!s) return; const r = kx((t, e) => { const n = s.clientWidth; i(t, e), n < s.clientWidth && i() }, window), o = new ResizeObserver(t => { const e = t[0], i = e.contentRect.width, n = e.contentRect.height; 0 === i && 0 === n || r(i, n) }); return o.observe(s), function (t, e) { dC.size || window.addEventListener("resize", fC), dC.set(t, e) }(t, r), o } function mC(t, e, i) { i && i.disconnect(), "resize" === e && function (t) { dC.delete(t), dC.size || window.removeEventListener("resize", fC) }(t) } function _C(t, e, i) { const n = t.canvas, s = kx(e => { null !== t.ctx && i(function (t, e) { const i = rC[t.type] || t.type, { x: n, y: s } = US(t, e); return { type: i, chart: e, native: t, x: void 0 !== n ? n : null, y: void 0 !== s ? s : null } }(e, t)) }, t); return function (t, e, i) { t.addEventListener(e, i, aC) }(n, e, s), s } class vC extends nC { acquireContext(t, e) { const i = t && t.getContext && t.getContext("2d"); return i && i.canvas === t ? (function (t, e) { const i = t.style, n = t.getAttribute("height"), s = t.getAttribute("width"); if (t.$chartjs = { initial: { height: n, width: s, style: { display: i.display, height: i.height, width: i.width } } }, i.display = i.display || "block", i.boxSizing = i.boxSizing || "border-box", oC(s)) { const e = ZS(t, "width"); void 0 !== e && (t.width = e) } if (oC(n)) if ("" === t.style.height) t.height = t.width / (e || 2); else { const e = ZS(t, "height"); void 0 !== e && (t.height = e) } }(t, e), i) : null } releaseContext(t) { const e = t.canvas; if (!e.$chartjs) return !1; const i = e.$chartjs.initial;["height", "width"].forEach(t => { const n = i[t]; Cw(n) ? e.removeAttribute(t) : e.setAttribute(t, n) }); const n = i.style || {}; return Object.keys(n).forEach(t => { e.style[t] = n[t] }), e.width = e.width, delete e.$chartjs, !0 } addEventListener(t, e, i) { this.removeEventListener(t, e), (t.$proxies || (t.$proxies = {}))[e] = ({ attach: hC, detach: uC, resize: gC }[e] || _C)(t, e, i) } removeEventListener(t, e) { const i = t.$proxies || (t.$proxies = {}), n = i[e]; n && (({ attach: mC, detach: mC, resize: mC }[e] || lC)(t, e, n), i[e] = void 0) } getDevicePixelRatio() { return window.devicePixelRatio } getMaximumSize(t, e, i, n) { return function (t, e, i, n) { const s = HS(t), r = $S(s, "margin"), o = BS(s.maxWidth, t, "clientWidth") || Yw, a = BS(s.maxHeight, t, "clientHeight") || Yw, l = function (t, e, i) { let n, s; if (void 0 === e || void 0 === i) { const r = VS(t); if (r) { const t = r.getBoundingClientRect(), o = HS(r), a = $S(o, "border", "width"), l = $S(o, "padding"); e = t.width - l.width - a.width, i = t.height - l.height - a.height, n = BS(o.maxWidth, r, "clientWidth"), s = BS(o.maxHeight, r, "clientHeight") } else e = t.clientWidth, i = t.clientHeight } return { width: e, height: i, maxWidth: n || Yw, maxHeight: s || Yw } }(t, e, i); let { width: c, height: h } = l; if ("content-box" === s.boxSizing) { const t = $S(s, "border", "width"), e = $S(s, "padding"); c -= e.width + t.width, h -= e.height + t.height } return c = Math.max(0, c - r.width), h = Math.max(0, n ? c / n : h - r.height), c = WS(Math.min(c, o, l.maxWidth)), h = WS(Math.min(h, a, l.maxHeight)), c && !h && (h = WS(c / 2)), (void 0 !== e || void 0 !== i) && n && l.height && h > l.height && (h = l.height, c = WS(Math.floor(h * n))), { width: c, height: h } }(t, e, i, n) } isAttached(t) { const e = VS(t); return !(!e || !e.isConnected) } } class yC { static defaults = {}; static defaultRoutes = void 0; x; y; active = !1; options; $animations; tooltipPosition(t) { const { x: e, y: i } = this.getProps(["x", "y"], t); return { x: e, y: i } } hasValue() { return rx(this.x) && rx(this.y) } getProps(t, e) { const i = this.$animations; if (!e || !i) return this; const n = {}; return t.forEach(t => { n[t] = i[t] && i[t].active() ? i[t]._to : this[t] }), n } } function bC(t, e, i, n, s) { const r = Aw(n, 0), o = Math.min(Aw(s, t.length), t.length); let a, l, c, h = 0; for (i = Math.ceil(i), s && (a = s - n, i = a / Math.floor(a / i)), c = r; c < 0;)h++, c = Math.round(r + h * i); for (l = Math.max(r, 0); l < o; l++)l === c && (e.push(t[l]), h++, c = Math.round(r + h * i)) } const wC = (t, e, i) => "top" === e || "left" === e ? t[e] + i : t[e] - i, xC = (t, e) => Math.min(e || t, t); function SC(t, e) { const i = [], n = t.length / e, s = t.length; let r = 0; for (; r < s; r += n)i.push(t[Math.floor(r)]); return i } function kC(t, e, i) { const n = t.ticks.length, s = Math.min(e, n - 1), r = t._startPixel, o = t._endPixel, a = 1e-6; let l, c = t.getPixelForTick(s); if (!(i && (l = 1 === n ? Math.max(c - r, o - c) : 0 === e ? (t.getPixelForTick(1) - c) / 2 : (c - t.getPixelForTick(s - 1)) / 2, c += s < e ? l : -l, c < r - a || c > o + a))) return c } function CC(t) { return t.drawTicks ? t.tickLength : 0 } function EC(t, e) { if (!t.display) return 0; const i = mS(t.font, e), n = gS(t.padding); return (Ew(t.text) ? t.text.length : 1) * i.lineHeight + n.height } function TC(t, e, i) { let n = Cx(t); return (i && "right" !== e || !i && "right" === e) && (n = (t => "left" === t ? "right" : "right" === t ? "left" : t)(n)), n } class PC extends yC { constructor(t) { super(), this.id = t.id, this.type = t.type, this.options = void 0, this.ctx = t.ctx, this.chart = t.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = { left: 0, right: 0, top: 0, bottom: 0 }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0 } init(t) { this.options = t.setContext(this.getContext()), this.axis = t.axis, this._userMin = this.parse(t.min), this._userMax = this.parse(t.max), this._suggestedMin = this.parse(t.suggestedMin), this._suggestedMax = this.parse(t.suggestedMax) } parse(t, e) { return t } getUserBounds() { let { _userMin: t, _userMax: e, _suggestedMin: i, _suggestedMax: n } = this; return t = Dw(t, Number.POSITIVE_INFINITY), e = Dw(e, Number.NEGATIVE_INFINITY), i = Dw(i, Number.POSITIVE_INFINITY), n = Dw(n, Number.NEGATIVE_INFINITY), { min: Dw(t, i), max: Dw(e, n), minDefined: Pw(t), maxDefined: Pw(e) } } getMinMax(t) { let e, { min: i, max: n, minDefined: s, maxDefined: r } = this.getUserBounds(); if (s && r) return { min: i, max: n }; const o = this.getMatchingVisibleMetas(); for (let a = 0, l = o.length; a < l; ++a)e = o[a].controller.getMinMax(this, t), s || (i = Math.min(i, e.min)), r || (n = Math.max(n, e.max)); return i = r && i > n ? n : i, n = s && i > n ? i : n, { min: Dw(i, Dw(n, i)), max: Dw(n, Dw(i, n)) } } getPadding() { return { left: this.paddingLeft || 0, top: this.paddingTop || 0, right: this.paddingRight || 0, bottom: this.paddingBottom || 0 } } getTicks() { return this.ticks } getLabels() { const t = this.chart.data; return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels || [] } getLabelItems(t = this.chart.chartArea) { return this._labelItems || (this._labelItems = this._computeLabelItems(t)) } beforeLayout() { this._cache = {}, this._dataLimitsCached = !1 } beforeUpdate() { Rw(this.options.beforeUpdate, [this]) } update(t, e, i) { const { beginAtZero: n, grace: s, ticks: r } = this.options, o = r.sampleSize; this.beforeUpdate(), this.maxWidth = t, this.maxHeight = e, this._margins = i = Object.assign({ left: 0, right: 0, top: 0, bottom: 0 }, i), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + i.left + i.right : this.height + i.top + i.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = function (t, e, i) { const { min: n, max: s } = t, r = Ow(e, (s - n) / 2), o = (t, e) => i && 0 === t ? 0 : t + e; return { min: o(n, -Math.abs(r)), max: o(s, r) } }(this, s, n), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks(); const a = o < this.ticks.length; this._convertTicksToLabels(a ? SC(this.ticks, o) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), r.display && (r.autoSkip || "auto" === r.source) && (this.ticks = function (t, e) { const i = t.options.ticks, n = function (t) { const e = t.options.offset, i = t._tickSize(); return Math.floor(Math.min(t._length / i + (e ? 0 : 1), t._maxLength / i)) }(t), s = Math.min(i.maxTicksLimit || n, n), r = i.major.enabled ? function (t) { const e = []; let i, n; for (i = 0, n = t.length; i < n; i++)t[i].major && e.push(i); return e }(e) : [], o = r.length, a = r[0], l = r[o - 1], c = []; if (o > s) return function (t, e, i, n) { let s, r = 0, o = i[0]; for (n = Math.ceil(n), s = 0; s < t.length; s++)s === o && (e.push(t[s]), r++, o = i[r * n]) }(e, c, r, o / s), c; const h = function (t, e, i) { const n = function (t) { const e = t.length; let i, n; if (e < 2) return !1; for (n = t[0], i = 1; i < e; ++i)if (t[i] - t[i - 1] !== n) return !1; return n }(t), s = e.length / i; if (!n) return Math.max(s, 1); const r = function (t) { const e = [], i = Math.sqrt(t); let n; for (n = 1; n < i; n++)t % n == 0 && (e.push(n), e.push(t / n)); return i === (0 | i) && e.push(i), e.sort((t, e) => t - e).pop(), e }(n); for (let o = 0, a = r.length - 1; o < a; o++) { const t = r[o]; if (t > s) return t } return Math.max(s, 1) }(r, e, s); if (o > 0) { let t, i; const n = o > 1 ? Math.round((l - a) / (o - 1)) : null; for (bC(e, c, h, Cw(n) ? 0 : a - n, a), t = 0, i = o - 1; t < i; t++)bC(e, c, h, r[t], r[t + 1]); return bC(e, c, h, l, Cw(n) ? e.length : l + n), c } return bC(e, c, h), c }(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), a && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate() } configure() { let t, e, i = this.options.reverse; this.isHorizontal() ? (t = this.left, e = this.right) : (t = this.top, e = this.bottom, i = !i), this._startPixel = t, this._endPixel = e, this._reversePixels = i, this._length = e - t, this._alignToPixels = this.options.alignToPixels } afterUpdate() { Rw(this.options.afterUpdate, [this]) } beforeSetDimensions() { Rw(this.options.beforeSetDimensions, [this]) } setDimensions() { this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0 } afterSetDimensions() { Rw(this.options.afterSetDimensions, [this]) } _callHooks(t) { this.chart.notifyPlugins(t, this.getContext()), Rw(this.options[t], [this]) } beforeDataLimits() { this._callHooks("beforeDataLimits") } determineDataLimits() { } afterDataLimits() { this._callHooks("afterDataLimits") } beforeBuildTicks() { this._callHooks("beforeBuildTicks") } buildTicks() { return [] } afterBuildTicks() { this._callHooks("afterBuildTicks") } beforeTickToLabelConversion() { Rw(this.options.beforeTickToLabelConversion, [this]) } generateTickLabels(t) { const e = this.options.ticks; let i, n, s; for (i = 0, n = t.length; i < n; i++)s = t[i], s.label = Rw(e.callback, [s.value, i, t], this) } afterTickToLabelConversion() { Rw(this.options.afterTickToLabelConversion, [this]) } beforeCalculateLabelRotation() { Rw(this.options.beforeCalculateLabelRotation, [this]) } calculateLabelRotation() { const t = this.options, e = t.ticks, i = xC(this.ticks.length, t.ticks.maxTicksLimit), n = e.minRotation || 0, s = e.maxRotation; let r, o, a, l = n; if (!this._isVisible() || !e.display || n >= s || i <= 1 || !this.isHorizontal()) return void (this.labelRotation = n); const c = this._getLabelSizes(), h = c.widest.width, u = c.highest.height, d = gx(this.chart.width - h, 0, this.maxWidth); r = t.offset ? this.maxWidth / i : d / (i - 1), h + 6 > r && (r = d / (i - (t.offset ? .5 : 1)), o = this.maxHeight - CC(t.grid) - e.padding - EC(t.title, this.chart.options.font), a = Math.sqrt(h * h + u * u), l = lx(Math.min(Math.asin(gx((c.highest.height + 6) / r, -1, 1)), Math.asin(gx(o / a, -1, 1)) - Math.asin(gx(u / a, -1, 1)))), l = Math.max(n, Math.min(s, l))), this.labelRotation = l } afterCalculateLabelRotation() { Rw(this.options.afterCalculateLabelRotation, [this]) } afterAutoSkip() { } beforeFit() { Rw(this.options.beforeFit, [this]) } fit() { const t = { width: 0, height: 0 }, { chart: e, options: { ticks: i, title: n, grid: s } } = this, r = this._isVisible(), o = this.isHorizontal(); if (r) { const r = EC(n, e.options.font); if (o ? (t.width = this.maxWidth, t.height = CC(s) + r) : (t.height = this.maxHeight, t.width = CC(s) + r), i.display && this.ticks.length) { const { first: e, last: n, widest: s, highest: r } = this._getLabelSizes(), a = 2 * i.padding, l = ax(this.labelRotation), c = Math.cos(l), h = Math.sin(l); o ? t.height = Math.min(this.maxHeight, t.height + (i.mirror ? 0 : h * s.width + c * r.height) + a) : t.width = Math.min(this.maxWidth, t.width + (i.mirror ? 0 : c * s.width + h * r.height) + a), this._calculatePadding(e, n, h, c) } } this._handleMargins(), o ? (this.width = this._length = e.width - this._margins.left - this._margins.right, this.height = t.height) : (this.width = t.width, this.height = this._length = e.height - this._margins.top - this._margins.bottom) } _calculatePadding(t, e, i, n) { const { ticks: { align: s, padding: r }, position: o } = this.options, a = 0 !== this.labelRotation, l = "top" !== o && "x" === this.axis; if (this.isHorizontal()) { const o = this.getPixelForTick(0) - this.left, c = this.right - this.getPixelForTick(this.ticks.length - 1); let h = 0, u = 0; a ? l ? (h = n * t.width, u = i * e.height) : (h = i * t.height, u = n * e.width) : "start" === s ? u = e.width : "end" === s ? h = t.width : "inner" !== s && (h = t.width / 2, u = e.width / 2), this.paddingLeft = Math.max((h - o + r) * this.width / (this.width - o), 0), this.paddingRight = Math.max((u - c + r) * this.width / (this.width - c), 0) } else { let i = e.height / 2, n = t.height / 2; "start" === s ? (i = 0, n = t.height) : "end" === s && (i = e.height, n = 0), this.paddingTop = i + r, this.paddingBottom = n + r } } _handleMargins() { this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom)) } afterFit() { Rw(this.options.afterFit, [this]) } isHorizontal() { const { axis: t, position: e } = this.options; return "top" === e || "bottom" === e || "x" === t } isFullSize() { return this.options.fullSize } _convertTicksToLabels(t) { let e, i; for (this.beforeTickToLabelConversion(), this.generateTickLabels(t), e = 0, i = t.length; e < i; e++)Cw(t[e].label) && (t.splice(e, 1), i--, e--); this.afterTickToLabelConversion() } _getLabelSizes() { let t = this._labelSizes; if (!t) { const e = this.options.ticks.sampleSize; let i = this.ticks; e < i.length && (i = SC(i, e)), this._labelSizes = t = this._computeLabelSizes(i, i.length, this.options.ticks.maxTicksLimit) } return t } _computeLabelSizes(t, e, i) { const { ctx: n, _longestTextCache: s } = this, r = [], o = [], a = Math.floor(e / xC(e, i)); let l, c, h, u, d, p, f, g, m, _, v, y = 0, b = 0; for (l = 0; l < e; l += a) { if (u = t[l].label, d = this._resolveTickFontOptions(l), n.font = p = d.string, f = s[p] = s[p] || { data: {}, gc: [] }, g = d.lineHeight, m = _ = 0, Cw(u) || Ew(u)) { if (Ew(u)) for (c = 0, h = u.length; c < h; ++c)v = u[c], Cw(v) || Ew(v) || (m = Zx(n, f.data, f.gc, m, v), _ += g) } else m = Zx(n, f.data, f.gc, m, u), _ = g; r.push(m), o.push(_), y = Math.max(m, y), b = Math.max(_, b) } !function (t, e) { Mw(t, t => { const i = t.gc, n = i.length / 2; let s; if (n > e) { for (s = 0; s < n; ++s)delete t.data[i[s]]; i.splice(0, n) } }) }(s, e); const w = r.indexOf(y), x = o.indexOf(b), S = t => ({ width: r[t] || 0, height: o[t] || 0 }); return { first: S(0), last: S(e - 1), widest: S(w), highest: S(x), widths: r, heights: o } } getLabelForValue(t) { return t } getPixelForValue(t, e) { return NaN } getValueForPixel(t) { } getPixelForTick(t) { const e = this.ticks; return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value) } getPixelForDecimal(t) { this._reversePixels && (t = 1 - t); const e = this._startPixel + t * this._length; return gx(this._alignToPixels ? Yx(this.chart, e, 0) : e, -32768, 32767) } getDecimalForPixel(t) { const e = (t - this._startPixel) / this._length; return this._reversePixels ? 1 - e : e } getBasePixel() { return this.getPixelForValue(this.getBaseValue()) } getBaseValue() { const { min: t, max: e } = this; return t < 0 && e < 0 ? e : t > 0 && e > 0 ? t : 0 } getContext(t) { const e = this.ticks || []; if (t >= 0 && t < e.length) { const i = e[t]; return i.$context || (i.$context = function (t, e, i) { return vS(t, { tick: i, index: e, type: "tick" }) }(this.getContext(), t, i)) } return this.$context || (this.$context = vS(this.chart.getContext(), { scale: this, type: "scale" })) } _tickSize() { const t = this.options.ticks, e = ax(this.labelRotation), i = Math.abs(Math.cos(e)), n = Math.abs(Math.sin(e)), s = this._getLabelSizes(), r = t.autoSkipPadding || 0, o = s ? s.widest.width + r : 0, a = s ? s.highest.height + r : 0; return this.isHorizontal() ? a * i > o * n ? o / i : a / n : a * n < o * i ? a / i : o / n } _isVisible() { const t = this.options.display; return "auto" !== t ? !!t : this.getMatchingVisibleMetas().length > 0 } _computeGridLineItems(t) { const e = this.axis, i = this.chart, n = this.options, { grid: s, position: r, border: o } = n, a = s.offset, l = this.isHorizontal(), c = this.ticks.length + (a ? 1 : 0), h = CC(s), u = [], d = o.setContext(this.getContext()), p = d.display ? d.width : 0, f = p / 2, g = function (t) { return Yx(i, t, p) }; let m, _, v, y, b, w, x, S, k, C, E, T; if ("top" === r) m = g(this.bottom), w = this.bottom - h, S = m - f, C = g(t.top) + f, T = t.bottom; else if ("bottom" === r) m = g(this.top), C = t.top, T = g(t.bottom) - f, w = m + f, S = this.top + h; else if ("left" === r) m = g(this.right), b = this.right - h, x = m - f, k = g(t.left) + f, E = t.right; else if ("right" === r) m = g(this.left), k = t.left, E = g(t.right) - f, b = m + f, x = this.left + h; else if ("x" === e) { if ("center" === r) m = g((t.top + t.bottom) / 2 + .5); else if (Tw(r)) { const t = Object.keys(r)[0]; m = g(this.chart.scales[t].getPixelForValue(r[t])) } C = t.top, T = t.bottom, w = m + f, S = w + h } else if ("y" === e) { if ("center" === r) m = g((t.left + t.right) / 2); else if (Tw(r)) { const t = Object.keys(r)[0]; m = g(this.chart.scales[t].getPixelForValue(r[t])) } b = m - f, x = b - h, k = t.left, E = t.right } const P = Aw(n.ticks.maxTicksLimit, c), D = Math.max(1, Math.ceil(c / P)); for (_ = 0; _ < c; _ += D) { const t = this.getContext(_), e = s.setContext(t), n = o.setContext(t), r = e.lineWidth, c = e.color, h = n.dash || [], d = n.dashOffset, p = e.tickWidth, f = e.tickColor, g = e.tickBorderDash || [], m = e.tickBorderDashOffset; v = kC(this, _, a), void 0 !== v && (y = Yx(i, v, r), l ? b = x = k = E = y : w = S = C = T = y, u.push({ tx1: b, ty1: w, tx2: x, ty2: S, x1: k, y1: C, x2: E, y2: T, width: r, color: c, borderDash: h, borderDashOffset: d, tickWidth: p, tickColor: f, tickBorderDash: g, tickBorderDashOffset: m })) } return this._ticksLength = c, this._borderValue = m, u } _computeLabelItems(t) { const e = this.axis, i = this.options, { position: n, ticks: s } = i, r = this.isHorizontal(), o = this.ticks, { align: a, crossAlign: l, padding: c, mirror: h } = s, u = CC(i.grid), d = u + c, p = h ? -c : d, f = -ax(this.labelRotation), g = []; let m, _, v, y, b, w, x, S, k, C, E, T, P = "middle"; if ("top" === n) w = this.bottom - p, x = this._getXAxisLabelAlignment(); else if ("bottom" === n) w = this.top + p, x = this._getXAxisLabelAlignment(); else if ("left" === n) { const t = this._getYAxisLabelAlignment(u); x = t.textAlign, b = t.x } else if ("right" === n) { const t = this._getYAxisLabelAlignment(u); x = t.textAlign, b = t.x } else if ("x" === e) { if ("center" === n) w = (t.top + t.bottom) / 2 + d; else if (Tw(n)) { const t = Object.keys(n)[0]; w = this.chart.scales[t].getPixelForValue(n[t]) + d } x = this._getXAxisLabelAlignment() } else if ("y" === e) { if ("center" === n) b = (t.left + t.right) / 2 - d; else if (Tw(n)) { const t = Object.keys(n)[0]; b = this.chart.scales[t].getPixelForValue(n[t]) } x = this._getYAxisLabelAlignment(u).textAlign } "y" === e && ("start" === a ? P = "top" : "end" === a && (P = "bottom")); const D = this._getLabelSizes(); for (m = 0, _ = o.length; m < _; ++m) { v = o[m], y = v.label; const t = s.setContext(this.getContext(m)); S = this.getPixelForTick(m) + s.labelOffset, k = this._resolveTickFontOptions(m), C = k.lineHeight, E = Ew(y) ? y.length : 1; const e = E / 2, i = t.color, a = t.textStrokeColor, c = t.textStrokeWidth; let u, d = x; if (r ? (b = S, "inner" === x && (d = m === _ - 1 ? this.options.reverse ? "left" : "right" : 0 === m ? this.options.reverse ? "right" : "left" : "center"), T = "top" === n ? "near" === l || 0 !== f ? -E * C + C / 2 : "center" === l ? -D.highest.height / 2 - e * C + C : C / 2 - D.highest.height : "near" === l || 0 !== f ? C / 2 : "center" === l ? D.highest.height / 2 - e * C : D.highest.height - E * C, h && (T *= -1), 0 === f || t.showLabelBackdrop || (b += C / 2 * Math.sin(f))) : (w = S, T = (1 - E) * C / 2), t.showLabelBackdrop) { const e = gS(t.backdropPadding), i = D.heights[m], n = D.widths[m]; let s = T - e.top, r = 0 - e.left; switch (P) { case "middle": s -= i / 2; break; case "bottom": s -= i }switch (x) { case "center": r -= n / 2; break; case "right": r -= n; break; case "inner": m === _ - 1 ? r -= n : m > 0 && (r -= n / 2) }u = { left: r, top: s, width: n + e.width, height: i + e.height, color: t.backdropColor } } g.push({ label: y, font: k, textOffset: T, options: { rotation: f, color: i, strokeColor: a, strokeWidth: c, textAlign: d, textBaseline: P, translation: [b, w], backdrop: u } }) } return g } _getXAxisLabelAlignment() { const { position: t, ticks: e } = this.options; if (-ax(this.labelRotation)) return "top" === t ? "left" : "right"; let i = "center"; return "start" === e.align ? i = "left" : "end" === e.align ? i = "right" : "inner" === e.align && (i = "inner"), i } _getYAxisLabelAlignment(t) { const { position: e, ticks: { crossAlign: i, mirror: n, padding: s } } = this.options, r = t + s, o = this._getLabelSizes().widest.width; let a, l; return "left" === e ? n ? (l = this.right + s, "near" === i ? a = "left" : "center" === i ? (a = "center", l += o / 2) : (a = "right", l += o)) : (l = this.right - r, "near" === i ? a = "right" : "center" === i ? (a = "center", l -= o / 2) : (a = "left", l = this.left)) : "right" === e ? n ? (l = this.left + s, "near" === i ? a = "right" : "center" === i ? (a = "center", l -= o / 2) : (a = "left", l -= o)) : (l = this.left + r, "near" === i ? a = "left" : "center" === i ? (a = "center", l += o / 2) : (a = "right", l = this.right)) : a = "right", { textAlign: a, x: l } } _computeLabelArea() { if (this.options.ticks.mirror) return; const t = this.chart, e = this.options.position; return "left" === e || "right" === e ? { top: 0, left: this.left, bottom: t.height, right: this.right } : "top" === e || "bottom" === e ? { top: this.top, left: 0, bottom: this.bottom, right: t.width } : void 0 } drawBackground() { const { ctx: t, options: { backgroundColor: e }, left: i, top: n, width: s, height: r } = this; e && (t.save(), t.fillStyle = e, t.fillRect(i, n, s, r), t.restore()) } getLineWidthForValue(t) { const e = this.options.grid; if (!this._isVisible() || !e.display) return 0; const i = this.ticks.findIndex(e => e.value === t); return i >= 0 ? e.setContext(this.getContext(i)).lineWidth : 0 } drawGrid(t) { const e = this.options.grid, i = this.ctx, n = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(t)); let s, r; const o = (t, e, n) => { n.width && n.color && (i.save(), i.lineWidth = n.width, i.strokeStyle = n.color, i.setLineDash(n.borderDash || []), i.lineDashOffset = n.borderDashOffset, i.beginPath(), i.moveTo(t.x, t.y), i.lineTo(e.x, e.y), i.stroke(), i.restore()) }; if (e.display) for (s = 0, r = n.length; s < r; ++s) { const t = n[s]; e.drawOnChartArea && o({ x: t.x1, y: t.y1 }, { x: t.x2, y: t.y2 }, t), e.drawTicks && o({ x: t.tx1, y: t.ty1 }, { x: t.tx2, y: t.ty2 }, { color: t.tickColor, width: t.tickWidth, borderDash: t.tickBorderDash, borderDashOffset: t.tickBorderDashOffset }) } } drawBorder() { const { chart: t, ctx: e, options: { border: i, grid: n } } = this, s = i.setContext(this.getContext()), r = i.display ? s.width : 0; if (!r) return; const o = n.setContext(this.getContext(0)).lineWidth, a = this._borderValue; let l, c, h, u; this.isHorizontal() ? (l = Yx(t, this.left, r) - r / 2, c = Yx(t, this.right, o) + o / 2, h = u = a) : (h = Yx(t, this.top, r) - r / 2, u = Yx(t, this.bottom, o) + o / 2, l = c = a), e.save(), e.lineWidth = s.width, e.strokeStyle = s.color, e.beginPath(), e.moveTo(l, h), e.lineTo(c, u), e.stroke(), e.restore() } drawLabels(t) { if (!this.options.ticks.display) return; const e = this.ctx, i = this._computeLabelArea(); i && eS(e, i); const n = this.getLabelItems(t); for (const s of n) aS(e, s.label, 0, s.textOffset, s.font, s.options); i && iS(e) } drawTitle() { const { ctx: t, options: { position: e, title: i, reverse: n } } = this; if (!i.display) return; const s = mS(i.font), r = gS(i.padding), o = i.align; let a = s.lineHeight / 2; "bottom" === e || "center" === e || Tw(e) ? (a += r.bottom, Ew(i.text) && (a += s.lineHeight * (i.text.length - 1))) : a += r.top; const { titleX: l, titleY: c, maxWidth: h, rotation: u } = function (t, e, i, n) { const { top: s, left: r, bottom: o, right: a, chart: l } = t, { chartArea: c, scales: h } = l; let u, d, p, f = 0; const g = o - s, m = a - r; if (t.isHorizontal()) { if (d = Ex(n, r, a), Tw(i)) { const t = Object.keys(i)[0]; p = h[t].getPixelForValue(i[t]) + g - e } else p = "center" === i ? (c.bottom + c.top) / 2 + g - e : wC(t, i, e); u = a - r } else { if (Tw(i)) { const t = Object.keys(i)[0]; d = h[t].getPixelForValue(i[t]) - m + e } else d = "center" === i ? (c.left + c.right) / 2 - m + e : wC(t, i, e); p = Ex(n, o, s), f = "left" === i ? -Xw : Xw } return { titleX: d, titleY: p, maxWidth: u, rotation: f } }(this, a, e, o); aS(t, i.text, 0, 0, s, { color: i.color, maxWidth: h, rotation: u, textAlign: TC(o, e, n), textBaseline: "middle", translation: [l, c] }) } draw(t) { this._isVisible() && (this.drawBackground(), this.drawGrid(t), this.drawBorder(), this.drawTitle(), this.drawLabels(t)) } _layers() { const t = this.options, e = t.ticks && t.ticks.z || 0, i = Aw(t.grid && t.grid.z, -1), n = Aw(t.border && t.border.z, 0); return this._isVisible() && this.draw === PC.prototype.draw ? [{ z: i, draw: t => { this.drawBackground(), this.drawGrid(t), this.drawTitle() } }, { z: n, draw: () => { this.drawBorder() } }, { z: e, draw: t => { this.drawLabels(t) } }] : [{ z: e, draw: t => { this.draw(t) } }] } getMatchingVisibleMetas(t) { const e = this.chart.getSortedVisibleDatasetMetas(), i = this.axis + "AxisID", n = []; let s, r; for (s = 0, r = e.length; s < r; ++s) { const r = e[s]; r[i] !== this.id || t && r.type !== t || n.push(r) } return n } _resolveTickFontOptions(t) { return mS(this.options.ticks.setContext(this.getContext(t)).font) } _maxDigits() { const t = this._resolveTickFontOptions(0).lineHeight; return (this.isHorizontal() ? this.width : this.height) / t } } class DC { constructor(t, e, i) { this.type = t, this.scope = e, this.override = i, this.items = Object.create(null) } isForType(t) { return Object.prototype.isPrototypeOf.call(this.type.prototype, t.prototype) } register(t) { const e = Object.getPrototypeOf(t); let i; (function (t) { return "id" in t && "defaults" in t })(e) && (i = this.register(e)); const n = this.items, s = t.id, r = this.scope + "." + s; if (!s) throw new Error("class does not have id: " + t); return s in n || (n[s] = t, function (t, e, i) { const n = jw(Object.create(null), [i ? Gx.get(i) : {}, Gx.get(e), t.defaults]); Gx.set(e, n), t.defaultRoutes && function (t, e) { Object.keys(e).forEach(i => { const n = i.split("."), s = n.pop(), r = [t].concat(n).join("."), o = e[i].split("."), a = o.pop(), l = o.join("."); Gx.route(r, s, l, a) }) }(e, t.defaultRoutes), t.descriptors && Gx.describe(e, t.descriptors) }(t, r, i), this.override && Gx.override(t.id, t.overrides)), r } get(t) { return this.items[t] } unregister(t) { const e = this.items, i = t.id, n = this.scope; i in e && delete e[i], n && i in Gx[n] && (delete Gx[n][i], this.override && delete zx[i]) } } class AC { constructor() { this.controllers = new DC(kk, "datasets", !0), this.elements = new DC(yC, "elements"), this.plugins = new DC(Object, "plugins"), this.scales = new DC(PC, "scales"), this._typedRegistries = [this.controllers, this.scales, this.elements] } add(...t) { this._each("register", t) } remove(...t) { this._each("unregister", t) } addControllers(...t) { this._each("register", t, this.controllers) } addElements(...t) { this._each("register", t, this.elements) } addPlugins(...t) { this._each("register", t, this.plugins) } addScales(...t) { this._each("register", t, this.scales) } getController(t) { return this._get(t, this.controllers, "controller") } getElement(t) { return this._get(t, this.elements, "element") } getPlugin(t) { return this._get(t, this.plugins, "plugin") } getScale(t) { return this._get(t, this.scales, "scale") } removeControllers(...t) { this._each("unregister", t, this.controllers) } removeElements(...t) { this._each("unregister", t, this.elements) } removePlugins(...t) { this._each("unregister", t, this.plugins) } removeScales(...t) { this._each("unregister", t, this.scales) } _each(t, e, i) { [...e].forEach(e => { const n = i || this._getRegistryForType(e); i || n.isForType(e) || n === this.plugins && e.id ? this._exec(t, n, e) : Mw(e, e => { const n = i || this._getRegistryForType(e); this._exec(t, n, e) }) }) } _exec(t, e, i) { const n = $w(t); Rw(i["before" + n], [], i), e[t](i), Rw(i["after" + n], [], i) } _getRegistryForType(t) { for (let e = 0; e < this._typedRegistries.length; e++) { const i = this._typedRegistries[e]; if (i.isForType(t)) return i } return this.plugins } _get(t, e, i) { const n = e.get(t); if (void 0 === n) throw new Error('"' + t + '" is not a registered ' + i + "."); return n } } var OC = new AC; class RC { constructor() { this._init = [] } notify(t, e, i, n) { "beforeInit" === e && (this._init = this._createDescriptors(t, !0), this._notify(this._init, t, "install")); const s = n ? this._descriptors(t).filter(n) : this._descriptors(t), r = this._notify(s, t, e, i); return "afterDestroy" === e && (this._notify(s, t, "stop"), this._notify(this._init, t, "uninstall")), r } _notify(t, e, i, n) { n = n || {}; for (const s of t) { const t = s.plugin; if (!1 === Rw(t[i], [e, n, s.options], t) && n.cancelable) return !1 } return !0 } invalidate() { Cw(this._cache) || (this._oldCache = this._cache, this._cache = void 0) } _descriptors(t) { if (this._cache) return this._cache; const e = this._cache = this._createDescriptors(t); return this._notifyStateChanges(t), e } _createDescriptors(t, e) { const i = t && t.config, n = Aw(i.options && i.options.plugins, {}), s = function (t) { const e = {}, i = [], n = Object.keys(OC.plugins.items); for (let r = 0; r < n.length; r++)i.push(OC.getPlugin(n[r])); const s = t.plugins || []; for (let r = 0; r < s.length; r++) { const t = s[r]; -1 === i.indexOf(t) && (i.push(t), e[t.id] = !0) } return { plugins: i, localIds: e } }(i); return !1 !== n || e ? function (t, { plugins: e, localIds: i }, n, s) { const r = [], o = t.getContext(); for (const a of e) { const e = a.id, l = MC(n[e], s); null !== l && r.push({ plugin: a, options: IC(t.config, { plugin: a, local: i[e] }, l, o) }) } return r }(t, s, n, e) : [] } _notifyStateChanges(t) { const e = this._oldCache || [], i = this._cache, n = (t, e) => t.filter(t => !e.some(e => t.plugin.id === e.plugin.id)); this._notify(n(e, i), t, "stop"), this._notify(n(i, e), t, "start") } } function MC(t, e) { return e || !1 !== t ? !0 === t ? {} : t : null } function IC(t, { plugin: e, local: i }, n, s) { const r = t.pluginScopeKeys(e), o = t.getOptionScopes(n, r); return i && e.defaults && o.push(e.defaults), t.createResolver(o, s, [""], { scriptable: !1, indexable: !1, allKeys: !0 }) } function LC(t, e) { return ((e.datasets || {})[t] || {}).indexAxis || e.indexAxis || (Gx.datasets[t] || {}).indexAxis || "x" } function FC(t) { if ("x" === t || "y" === t || "r" === t) return t } function NC(t, ...e) { if (FC(t)) return t; for (const n of e) { const e = n.axis || ("top" === (i = n.position) || "bottom" === i ? "x" : "left" === i || "right" === i ? "y" : void 0) || t.length > 1 && FC(t[0].toLowerCase()); if (e) return e } var i; throw new Error(`Cannot determine type of '${t}' axis. Please provide 'axis' or 'position' option.`) } function jC(t, e, i) { if (i[e + "AxisID"] === t) return { axis: e } } function VC(t) { const e = t.options || (t.options = {}); e.plugins = Aw(e.plugins, {}), e.scales = function (t, e) { const i = zx[t.type] || { scales: {} }, n = e.scales || {}, s = LC(t.type, e), r = Object.create(null); return Object.keys(n).forEach(e => { const o = n[e]; if (!Tw(o)) return console.error(`Invalid scale configuration for scale: ${e}`); if (o._proxy) return console.warn(`Ignoring resolver passed as options for scale: ${e}`); const a = NC(e, o, function (t, e) { if (e.data && e.data.datasets) { const i = e.data.datasets.filter(e => e.xAxisID === t || e.yAxisID === t); if (i.length) return jC(t, "x", i[0]) || jC(t, "y", i[0]) } return {} }(e, t), Gx.scales[o.type]), l = function (t, e) { return t === e ? "_index_" : "_value_" }(a, s), c = i.scales || {}; r[e] = Vw(Object.create(null), [{ axis: a }, o, c[a], c[l]]) }), t.data.datasets.forEach(i => { const s = i.type || t.type, o = i.indexAxis || LC(s, e), a = (zx[s] || {}).scales || {}; Object.keys(a).forEach(t => { const e = function (t, e) { let i = t; return "_index_" === t ? i = e : "_value_" === t && (i = "x" === e ? "y" : "x"), i }(t, o), s = i[e + "AxisID"] || e; r[s] = r[s] || Object.create(null), Vw(r[s], [{ axis: e }, n[s], a[t]]) }) }), Object.keys(r).forEach(t => { const e = r[t]; Vw(e, [Gx.scales[e.type], Gx.scale]) }), r }(t, e) } function BC(t) { return (t = t || {}).datasets = t.datasets || [], t.labels = t.labels || [], t } const HC = new Map, zC = new Set; function $C(t, e) { let i = HC.get(t); return i || (i = e(), HC.set(t, i), zC.add(i)), i } const UC = (t, e, i) => { const n = zw(e, i); void 0 !== n && t.add(n) }; class WC { constructor(t) { this._config = function (t) { return (t = t || {}).data = BC(t.data), VC(t), t }(t), this._scopeCache = new Map, this._resolverCache = new Map } get platform() { return this._config.platform } get type() { return this._config.type } set type(t) { this._config.type = t } get data() { return this._config.data } set data(t) { this._config.data = BC(t) } get options() { return this._config.options } set options(t) { this._config.options = t } get plugins() { return this._config.plugins } update() { const t = this._config; this.clearCache(), VC(t) } clearCache() { this._scopeCache.clear(), this._resolverCache.clear() } datasetScopeKeys(t) { return $C(t, () => [[`datasets.${t}`, ""]]) } datasetAnimationScopeKeys(t, e) { return $C(`${t}.transition.${e}`, () => [[`datasets.${t}.transitions.${e}`, `transitions.${e}`], [`datasets.${t}`, ""]]) } datasetElementScopeKeys(t, e) { return $C(`${t}-${e}`, () => [[`datasets.${t}.elements.${e}`, `datasets.${t}`, `elements.${e}`, ""]]) } pluginScopeKeys(t) { const e = t.id; return $C(`${this.type}-plugin-${e}`, () => [[`plugins.${e}`, ...t.additionalOptionScopes || []]]) } _cachedScopes(t, e) { const i = this._scopeCache; let n = i.get(t); return n && !e || (n = new Map, i.set(t, n)), n } getOptionScopes(t, e, i) { const { options: n, type: s } = this, r = this._cachedScopes(t, i), o = r.get(e); if (o) return o; const a = new Set; e.forEach(e => { t && (a.add(t), e.forEach(e => UC(a, t, e))), e.forEach(t => UC(a, n, t)), e.forEach(t => UC(a, zx[s] || {}, t)), e.forEach(t => UC(a, Gx, t)), e.forEach(t => UC(a, $x, t)) }); const l = Array.from(a); return 0 === l.length && l.push(Object.create(null)), zC.has(e) && r.set(e, l), l } chartOptionScopes() { const { options: t, type: e } = this; return [t, zx[e] || {}, Gx.datasets[e] || {}, { type: e }, Gx, $x] } resolveNamedOptions(t, e, i, n = [""]) { const s = { $shared: !0 }, { resolver: r, subPrefixes: o } = qC(this._resolverCache, t, n); let a = r; (function (t, e) { const { isScriptable: i, isIndexable: n } = wS(t); for (const s of e) { const e = i(s), r = n(s), o = (r || e) && t[s]; if (e && (Ww(o) || GC(o)) || r && Ew(o)) return !0 } return !1 })(r, e) && (s.$shared = !1, a = bS(r, i = Ww(i) ? i() : i, this.createResolver(t, i, o))); for (const l of e) s[l] = a[l]; return s } createResolver(t, e, i = [""], n) { const { resolver: s } = qC(this._resolverCache, t, i); return Tw(e) ? bS(s, e, void 0, n) : s } } function qC(t, e, i) { let n = t.get(e); n || (n = new Map, t.set(e, n)); const s = i.join(); let r = n.get(s); return r || (r = { resolver: yS(e, i), subPrefixes: i.filter(t => !t.toLowerCase().includes("hover")) }, n.set(s, r)), r } const GC = t => Tw(t) && Object.getOwnPropertyNames(t).some(e => Ww(t[e])), ZC = ["top", "bottom", "left", "right", "chartArea"]; function KC(t, e) { return "top" === t || "bottom" === t || -1 === ZC.indexOf(t) && "x" === e } function YC(t, e) { return function (i, n) { return i[t] === n[t] ? i[e] - n[e] : i[t] - n[t] } } function QC(t) { const e = t.chart, i = e.options.animation; e.notifyPlugins("afterRender"), Rw(i && i.onComplete, [t], e) } function XC(t) { const e = t.chart, i = e.options.animation; Rw(i && i.onProgress, [t], e) } function JC(t) { return jS() && "string" == typeof t ? t = document.getElementById(t) : t && t.length && (t = t[0]), t && t.canvas && (t = t.canvas), t } const tE = {}, eE = t => { const e = JC(t); return Object.values(tE).filter(t => t.canvas === e).pop() }; function iE(t, e, i) { const n = Object.keys(t); for (const s of n) { const n = +s; if (n >= e) { const r = t[s]; delete t[s], (i > 0 || n > e) && (t[n + i] = r) } } } function nE(t, e, i) { return t.options.clip ? t[i] : e[i] } class sE { static defaults = Gx; static instances = tE; static overrides = zx; static registry = OC; static version = "4.4.1"; static getChart = eE; static register(...t) { OC.add(...t), rE() } static unregister(...t) { OC.remove(...t), rE() } constructor(t, e) { const i = this.config = new WC(e), n = JC(t), s = eE(n); if (s) throw new Error("Canvas is already in use. Chart with ID '" + s.id + "' must be destroyed before the canvas with ID '" + s.canvas.id + "' can be reused."); const r = i.createResolver(i.chartOptionScopes(), this.getContext()); this.platform = new (i.platform || function (t) { return !jS() || "undefined" != typeof OffscreenCanvas && t instanceof OffscreenCanvas ? sC : vC }(n)), this.platform.updateConfig(i); const o = this.platform.acquireContext(n, r.aspectRatio), a = o && o.canvas, l = a && a.height, c = a && a.width; this.id = kw(), this.ctx = o, this.canvas = a, this.width = c, this.height = l, this._options = r, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new RC, this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = function (t, e) { let i; return function (...n) { return e ? (clearTimeout(i), i = setTimeout(t, e, n)) : t.apply(this, n), e } }(t => this.update(t), r.resizeDelay || 0), this._dataChanges = [], tE[this.id] = this, o && a ? (lk.listen(this, "complete", QC), lk.listen(this, "progress", XC), this._initialize(), this.attached && this.update()) : console.error("Failed to create chart: can't acquire context from the given item") } get aspectRatio() { const { options: { aspectRatio: t, maintainAspectRatio: e }, width: i, height: n, _aspectRatio: s } = this; return Cw(t) ? e && s ? s : n ? i / n : null : t } get data() { return this.config.data } set data(t) { this.config.data = t } get options() { return this._options } set options(t) { this.config.options = t } get registry() { return OC } _initialize() { return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : qS(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this } clear() { return Qx(this.canvas, this.ctx), this } stop() { return lk.stop(this), this } resize(t, e) { lk.running(this) ? this._resizeBeforeDraw = { width: t, height: e } : this._resize(t, e) } _resize(t, e) { const i = this.options, n = this.platform.getMaximumSize(this.canvas, t, e, i.maintainAspectRatio && this.aspectRatio), s = i.devicePixelRatio || this.platform.getDevicePixelRatio(), r = this.width ? "resize" : "attach"; this.width = n.width, this.height = n.height, this._aspectRatio = this.aspectRatio, qS(this, s, !0) && (this.notifyPlugins("resize", { size: n }), Rw(i.onResize, [this, n], this), this.attached && this._doResize(r) && this.render()) } ensureScalesHaveIDs() { Mw(this.options.scales || {}, (t, e) => { t.id = e }) } buildOrUpdateScales() { const t = this.options, e = t.scales, i = this.scales, n = Object.keys(i).reduce((t, e) => (t[e] = !1, t), {}); let s = []; e && (s = s.concat(Object.keys(e).map(t => { const i = e[t], n = NC(t, i), s = "r" === n, r = "x" === n; return { options: i, dposition: s ? "chartArea" : r ? "bottom" : "left", dtype: s ? "radialLinear" : r ? "category" : "linear" } }))), Mw(s, e => { const s = e.options, r = s.id, o = NC(r, s), a = Aw(s.type, e.dtype); void 0 !== s.position && KC(s.position, o) === KC(e.dposition) || (s.position = e.dposition), n[r] = !0; let l = null; r in i && i[r].type === a ? l = i[r] : (l = new (OC.getScale(a))({ id: r, type: a, ctx: this.ctx, chart: this }), i[l.id] = l), l.init(s, t) }), Mw(n, (t, e) => { t || delete i[e] }), Mw(i, t => { iC.configure(this, t, t.options), iC.addBox(this, t) }) } _updateMetasets() { const t = this._metasets, e = this.data.datasets.length, i = t.length; if (t.sort((t, e) => t.index - e.index), i > e) { for (let t = e; t < i; ++t)this._destroyDatasetMeta(t); t.splice(e, i - e) } this._sortedMetasets = t.slice(0).sort(YC("order", "index")) } _removeUnreferencedMetasets() { const { _metasets: t, data: { datasets: e } } = this; t.length > e.length && delete this._stacks, t.forEach((t, i) => { 0 === e.filter(e => e === t._dataset).length && this._destroyDatasetMeta(i) }) } buildOrUpdateControllers() { const t = [], e = this.data.datasets; let i, n; for (this._removeUnreferencedMetasets(), i = 0, n = e.length; i < n; i++) { const n = e[i]; let s = this.getDatasetMeta(i); const r = n.type || this.config.type; if (s.type && s.type !== r && (this._destroyDatasetMeta(i), s = this.getDatasetMeta(i)), s.type = r, s.indexAxis = n.indexAxis || LC(r, this.options), s.order = n.order || 0, s.index = i, s.label = "" + n.label, s.visible = this.isDatasetVisible(i), s.controller) s.controller.updateIndex(i), s.controller.linkScales(); else { const e = OC.getController(r), { datasetElementType: n, dataElementType: o } = Gx.datasets[r]; Object.assign(e, { dataElementType: OC.getElement(o), datasetElementType: n && OC.getElement(n) }), s.controller = new e(this, i), t.push(s.controller) } } return this._updateMetasets(), t } _resetElements() { Mw(this.data.datasets, (t, e) => { this.getDatasetMeta(e).controller.reset() }, this) } reset() { this._resetElements(), this.notifyPlugins("reset") } update(t) { const e = this.config; e.update(); const i = this._options = e.createResolver(e.chartOptionScopes(), this.getContext()), n = this._animationsDisabled = !i.animation; if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), !1 === this.notifyPlugins("beforeUpdate", { mode: t, cancelable: !0 })) return; const s = this.buildOrUpdateControllers(); this.notifyPlugins("beforeElementsUpdate"); let r = 0; for (let l = 0, c = this.data.datasets.length; l < c; l++) { const { controller: t } = this.getDatasetMeta(l), e = !n && -1 === s.indexOf(t); t.buildOrUpdateElements(e), r = Math.max(+t.getMaxOverflow(), r) } r = this._minPadding = i.layout.autoPadding ? r : 0, this._updateLayout(r), n || Mw(s, t => { t.reset() }), this._updateDatasets(t), this.notifyPlugins("afterUpdate", { mode: t }), this._layers.sort(YC("z", "_idx")); const { _active: o, _lastEvent: a } = this; a ? this._eventHandler(a, !0) : o.length && this._updateHoverStyles(o, o, !0), this.render() } _updateScales() { Mw(this.scales, t => { iC.removeBox(this, t) }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales() } _checkEventBindings() { const t = this.options, e = new Set(Object.keys(this._listeners)), i = new Set(t.events); qw(e, i) && !!this._responsiveListeners === t.responsive || (this.unbindEvents(), this.bindEvents()) } _updateHiddenIndices() { const { _hiddenIndices: t } = this, e = this._getUniformDataChanges() || []; for (const { method: i, start: n, count: s } of e) iE(t, n, "_removeElements" === i ? -s : s) } _getUniformDataChanges() { const t = this._dataChanges; if (!t || !t.length) return; this._dataChanges = []; const e = this.data.datasets.length, i = e => new Set(t.filter(t => t[0] === e).map((t, e) => e + "," + t.splice(1).join(","))), n = i(0); for (let s = 1; s < e; s++)if (!qw(n, i(s))) return; return Array.from(n).map(t => t.split(",")).map(t => ({ method: t[1], start: +t[2], count: +t[3] })) } _updateLayout(t) { if (!1 === this.notifyPlugins("beforeLayout", { cancelable: !0 })) return; iC.update(this, this.width, this.height, t); const e = this.chartArea, i = e.width <= 0 || e.height <= 0; this._layers = [], Mw(this.boxes, t => { i && "chartArea" === t.position || (t.configure && t.configure(), this._layers.push(...t._layers())) }, this), this._layers.forEach((t, e) => { t._idx = e }), this.notifyPlugins("afterLayout") } _updateDatasets(t) { if (!1 !== this.notifyPlugins("beforeDatasetsUpdate", { mode: t, cancelable: !0 })) { for (let t = 0, e = this.data.datasets.length; t < e; ++t)this.getDatasetMeta(t).controller.configure(); for (let e = 0, i = this.data.datasets.length; e < i; ++e)this._updateDataset(e, Ww(t) ? t({ datasetIndex: e }) : t); this.notifyPlugins("afterDatasetsUpdate", { mode: t }) } } _updateDataset(t, e) { const i = this.getDatasetMeta(t), n = { meta: i, index: t, mode: e, cancelable: !0 }; !1 !== this.notifyPlugins("beforeDatasetUpdate", n) && (i.controller._update(e), n.cancelable = !1, this.notifyPlugins("afterDatasetUpdate", n)) } render() { !1 !== this.notifyPlugins("beforeRender", { cancelable: !0 }) && (lk.has(this) ? this.attached && !lk.running(this) && lk.start(this) : (this.draw(), QC({ chart: this }))) } draw() { let t; if (this._resizeBeforeDraw) { const { width: t, height: e } = this._resizeBeforeDraw; this._resize(t, e), this._resizeBeforeDraw = null } if (this.clear(), this.width <= 0 || this.height <= 0) return; if (!1 === this.notifyPlugins("beforeDraw", { cancelable: !0 })) return; const e = this._layers; for (t = 0; t < e.length && e[t].z <= 0; ++t)e[t].draw(this.chartArea); for (this._drawDatasets(); t < e.length; ++t)e[t].draw(this.chartArea); this.notifyPlugins("afterDraw") } _getSortedDatasetMetas(t) { const e = this._sortedMetasets, i = []; let n, s; for (n = 0, s = e.length; n < s; ++n) { const s = e[n]; t && !s.visible || i.push(s) } return i } getSortedVisibleDatasetMetas() { return this._getSortedDatasetMetas(!0) } _drawDatasets() { if (!1 === this.notifyPlugins("beforeDatasetsDraw", { cancelable: !0 })) return; const t = this.getSortedVisibleDatasetMetas(); for (let e = t.length - 1; e >= 0; --e)this._drawDataset(t[e]); this.notifyPlugins("afterDatasetsDraw") } _drawDataset(t) { const e = this.ctx, i = t._clip, n = !i.disabled, s = function (t, e) { const { xScale: i, yScale: n } = t; return i && n ? { left: nE(i, e, "left"), right: nE(i, e, "right"), top: nE(n, e, "top"), bottom: nE(n, e, "bottom") } : e }(t, this.chartArea), r = { meta: t, index: t.index, cancelable: !0 }; !1 !== this.notifyPlugins("beforeDatasetDraw", r) && (n && eS(e, { left: !1 === i.left ? 0 : s.left - i.left, right: !1 === i.right ? this.width : s.right + i.right, top: !1 === i.top ? 0 : s.top - i.top, bottom: !1 === i.bottom ? this.height : s.bottom + i.bottom }), t.controller.draw(), n && iS(e), r.cancelable = !1, this.notifyPlugins("afterDatasetDraw", r)) } isPointInArea(t) { return tS(t, this.chartArea, this._minPadding) } getElementsAtEventForMode(t, e, i, n) { const s = Uk.modes[e]; return "function" == typeof s ? s(this, t, i, n) : [] } getDatasetMeta(t) { const e = this.data.datasets[t], i = this._metasets; let n = i.filter(t => t && t._dataset === e).pop(); return n || (n = { type: null, data: [], dataset: null, controller: null, hidden: null, xAxisID: null, yAxisID: null, order: e && e.order || 0, index: t, _dataset: e, _parsed: [], _sorted: !1 }, i.push(n)), n } getContext() { return this.$context || (this.$context = vS(null, { chart: this, type: "chart" })) } getVisibleDatasetCount() { return this.getSortedVisibleDatasetMetas().length } isDatasetVisible(t) { const e = this.data.datasets[t]; if (!e) return !1; const i = this.getDatasetMeta(t); return "boolean" == typeof i.hidden ? !i.hidden : !e.hidden } setDatasetVisibility(t, e) { this.getDatasetMeta(t).hidden = !e } toggleDataVisibility(t) { this._hiddenIndices[t] = !this._hiddenIndices[t] } getDataVisibility(t) { return !this._hiddenIndices[t] } _updateVisibility(t, e, i) { const n = i ? "show" : "hide", s = this.getDatasetMeta(t), r = s.controller._resolveAnimations(void 0, n); Uw(e) ? (s.data[e].hidden = !i, this.update()) : (this.setDatasetVisibility(t, i), r.update(s, { visible: i }), this.update(e => e.datasetIndex === t ? n : void 0)) } hide(t, e) { this._updateVisibility(t, e, !1) } show(t, e) { this._updateVisibility(t, e, !0) } _destroyDatasetMeta(t) { const e = this._metasets[t]; e && e.controller && e.controller._destroy(), delete this._metasets[t] } _stop() { let t, e; for (this.stop(), lk.remove(this), t = 0, e = this.data.datasets.length; t < e; ++t)this._destroyDatasetMeta(t) } destroy() { this.notifyPlugins("beforeDestroy"); const { canvas: t, ctx: e } = this; this._stop(), this.config.clearCache(), t && (this.unbindEvents(), Qx(t, e), this.platform.releaseContext(e), this.canvas = null, this.ctx = null), delete tE[this.id], this.notifyPlugins("afterDestroy") } toBase64Image(...t) { return this.canvas.toDataURL(...t) } bindEvents() { this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0 } bindUserEvents() { const t = this._listeners, e = this.platform, i = (i, n) => { e.addEventListener(this, i, n), t[i] = n }, n = (t, e, i) => { t.offsetX = e, t.offsetY = i, this._eventHandler(t) }; Mw(this.options.events, t => i(t, n)) } bindResponsiveEvents() { this._responsiveListeners || (this._responsiveListeners = {}); const t = this._responsiveListeners, e = this.platform, i = (i, n) => { e.addEventListener(this, i, n), t[i] = n }, n = (i, n) => { t[i] && (e.removeEventListener(this, i, n), delete t[i]) }, s = (t, e) => { this.canvas && this.resize(t, e) }; let r; const o = () => { n("attach", o), this.attached = !0, this.resize(), i("resize", s), i("detach", r) }; r = () => { this.attached = !1, n("resize", s), this._stop(), this._resize(0, 0), i("attach", o) }, e.isAttached(this.canvas) ? o() : r() } unbindEvents() { Mw(this._listeners, (t, e) => { this.platform.removeEventListener(this, e, t) }), this._listeners = {}, Mw(this._responsiveListeners, (t, e) => { this.platform.removeEventListener(this, e, t) }), this._responsiveListeners = void 0 } updateHoverStyle(t, e, i) { const n = i ? "set" : "remove"; let s, r, o, a; for ("dataset" === e && (s = this.getDatasetMeta(t[0].datasetIndex), s.controller["_" + n + "DatasetHoverStyle"]()), o = 0, a = t.length; o < a; ++o) { r = t[o]; const e = r && this.getDatasetMeta(r.datasetIndex).controller; e && e[n + "HoverStyle"](r.element, r.datasetIndex, r.index) } } getActiveElements() { return this._active || [] } setActiveElements(t) { const e = this._active || [], i = t.map(({ datasetIndex: t, index: e }) => { const i = this.getDatasetMeta(t); if (!i) throw new Error("No dataset found at index " + t); return { datasetIndex: t, element: i.data[e], index: e } }); !Iw(i, e) && (this._active = i, this._lastEvent = null, this._updateHoverStyles(i, e)) } notifyPlugins(t, e, i) { return this._plugins.notify(this, t, e, i) } isPluginEnabled(t) { return 1 === this._plugins._cache.filter(e => e.plugin.id === t).length } _updateHoverStyles(t, e, i) { const n = this.options.hover, s = (t, e) => t.filter(t => !e.some(e => t.datasetIndex === e.datasetIndex && t.index === e.index)), r = s(e, t), o = i ? t : s(t, e); r.length && this.updateHoverStyle(r, n.mode, !1), o.length && n.mode && this.updateHoverStyle(o, n.mode, !0) } _eventHandler(t, e) { const i = { event: t, replay: e, cancelable: !0, inChartArea: this.isPointInArea(t) }, n = e => (e.options.events || this.options.events).includes(t.native.type); if (!1 === this.notifyPlugins("beforeEvent", i, n)) return; const s = this._handleEvent(t, e, i.inChartArea); return i.cancelable = !1, this.notifyPlugins("afterEvent", i, n), (s || i.changed) && this.render(), this } _handleEvent(t, e, i) { const { _active: n = [], options: s } = this, r = this._getActiveElements(t, n, i, e), o = function (t) { return "mouseup" === t.type || "click" === t.type || "contextmenu" === t.type }(t), a = function (t, e, i, n) { return i && "mouseout" !== t.type ? n ? e : t : null }(t, this._lastEvent, i, o); i && (this._lastEvent = null, Rw(s.onHover, [t, r, this], this), o && Rw(s.onClick, [t, r, this], this)); const l = !Iw(r, n); return (l || e) && (this._active = r, this._updateHoverStyles(r, n, e)), this._lastEvent = a, l } _getActiveElements(t, e, i, n) { if ("mouseout" === t.type) return []; if (!i) return e; const s = this.options.hover; return this.getElementsAtEventForMode(t, s.mode, s, n) } } function rE() { return Mw(sE.instances, t => t._plugins.invalidate()) } function oE(t, e, i, n) { return { x: i + t * Math.cos(e), y: n + t * Math.sin(e) } } function aE(t, e, i, n, s, r) { const { x: o, y: a, startAngle: l, pixelMargin: c, innerRadius: h } = e, u = Math.max(e.outerRadius + n + i - c, 0), d = h > 0 ? h + n + i + c : 0; let p = 0; const f = s - l; if (n) { const t = ((h > 0 ? h - n : 0) + (u > 0 ? u - n : 0)) / 2; p = (f - (0 !== t ? f * t / (t + n) : f)) / 2 } const g = (f - Math.max(.001, f * u - i / Gw) / u) / 2, m = l + g + p, _ = s - g - p, { outerStart: v, outerEnd: y, innerStart: b, innerEnd: w } = function (t, e, i, n) { const s = dS(t.options.borderRadius, ["outerStart", "outerEnd", "innerStart", "innerEnd"]), r = (i - e) / 2, o = Math.min(r, n * e / 2), a = t => { const e = (i - Math.min(r, t)) * n / 2; return gx(t, 0, Math.min(r, e)) }; return { outerStart: a(s.outerStart), outerEnd: a(s.outerEnd), innerStart: gx(s.innerStart, 0, o), innerEnd: gx(s.innerEnd, 0, o) } }(e, d, u, _ - m), x = u - v, S = u - y, k = m + v / x, C = _ - y / S, E = d + b, T = d + w, P = m + b / E, D = _ - w / T; if (t.beginPath(), r) { const e = (k + C) / 2; if (t.arc(o, a, u, k, e), t.arc(o, a, u, e, C), y > 0) { const e = oE(S, C, o, a); t.arc(e.x, e.y, y, C, _ + Xw) } const i = oE(T, _, o, a); if (t.lineTo(i.x, i.y), w > 0) { const e = oE(T, D, o, a); t.arc(e.x, e.y, w, _ + Xw, D + Math.PI) } const n = (_ - w / d + (m + b / d)) / 2; if (t.arc(o, a, d, _ - w / d, n, !0), t.arc(o, a, d, n, m + b / d, !0), b > 0) { const e = oE(E, P, o, a); t.arc(e.x, e.y, b, P + Math.PI, m - Xw) } const s = oE(x, m, o, a); if (t.lineTo(s.x, s.y), v > 0) { const e = oE(x, k, o, a); t.arc(e.x, e.y, v, m - Xw, k) } } else { t.moveTo(o, a); const e = Math.cos(k) * u + o, i = Math.sin(k) * u + a; t.lineTo(e, i); const n = Math.cos(C) * u + o, s = Math.sin(C) * u + a; t.lineTo(n, s) } t.closePath() } function lE(t, e, i = e) { t.lineCap = Aw(i.borderCapStyle, e.borderCapStyle), t.setLineDash(Aw(i.borderDash, e.borderDash)), t.lineDashOffset = Aw(i.borderDashOffset, e.borderDashOffset), t.lineJoin = Aw(i.borderJoinStyle, e.borderJoinStyle), t.lineWidth = Aw(i.borderWidth, e.borderWidth), t.strokeStyle = Aw(i.borderColor, e.borderColor) } function cE(t, e, i) { t.lineTo(i.x, i.y) } function hE(t, e, i = {}) { const n = t.length, { start: s = 0, end: r = n - 1 } = i, { start: o, end: a } = e, l = Math.max(s, o), c = Math.min(r, a); return { count: n, start: l, loop: e.loop, ilen: c < l && !(s < o && r < o || s > a && r > a) ? n + c - l : c - l } } function uE(t, e, i, n) { const { points: s, options: r } = e, { count: o, start: a, loop: l, ilen: c } = hE(s, i, n), h = function (t) { return t.stepped ? nS : t.tension || "monotone" === t.cubicInterpolationMode ? sS : cE }(r); let u, d, p, { move: f = !0, reverse: g } = n || {}; for (u = 0; u <= c; ++u)d = s[(a + (g ? c - u : u)) % o], d.skip || (f ? (t.moveTo(d.x, d.y), f = !1) : h(t, p, d, g, r.stepped), p = d); return l && (d = s[(a + (g ? c : 0)) % o], h(t, p, d, g, r.stepped)), !!l } function dE(t, e, i, n) { const s = e.points, { count: r, start: o, ilen: a } = hE(s, i, n), { move: l = !0, reverse: c } = n || {}; let h, u, d, p, f, g, m = 0, _ = 0; const v = t => (o + (c ? a - t : t)) % r, y = () => { p !== f && (t.lineTo(m, f), t.lineTo(m, p), t.lineTo(m, g)) }; for (l && (u = s[v(0)], t.moveTo(u.x, u.y)), h = 0; h <= a; ++h) { if (u = s[v(h)], u.skip) continue; const e = u.x, i = u.y, n = 0 | e; n === d ? (i < p ? p = i : i > f && (f = i), m = (_ * m + e) / ++_) : (y(), t.lineTo(e, i), d = n, _ = 0, p = f = i), g = i } y() } function pE(t) { const e = t.options; return t._decimated || t._loop || e.tension || "monotone" === e.cubicInterpolationMode || e.stepped || e.borderDash && e.borderDash.length ? uE : dE } const fE = "function" == typeof Path2D; class gE extends yC { static id = "line"; static defaults = { borderCapStyle: "butt", borderDash: [], borderDashOffset: 0, borderJoinStyle: "miter", borderWidth: 3, capBezierPoints: !0, cubicInterpolationMode: "default", fill: !1, spanGaps: !1, stepped: !1, tension: 0 }; static defaultRoutes = { backgroundColor: "backgroundColor", borderColor: "borderColor" }; static descriptors = { _scriptable: !0, _indexable: t => "borderDash" !== t && "fill" !== t }; constructor(t) { super(), this.animated = !0, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = !1, this._pointsUpdated = !1, this._datasetIndex = void 0, t && Object.assign(this, t) } updateControlPoints(t, e) { const i = this.options; !i.tension && "monotone" !== i.cubicInterpolationMode || i.stepped || this._pointsUpdated || (function (t, e, i, n, s) { let r, o, a, l; if (e.spanGaps && (t = t.filter(t => !t.skip)), "monotone" === e.cubicInterpolationMode) !function (t, e = "x") { const i = LS(e), n = t.length, s = Array(n).fill(0), r = Array(n); let o, a, l, c = IS(t, 0); for (o = 0; o < n; ++o)if (a = l, l = c, c = IS(t, o + 1), l) { if (c) { const t = c[e] - l[e]; s[o] = 0 !== t ? (c[i] - l[i]) / t : 0 } r[o] = a ? c ? ix(s[o - 1]) !== ix(s[o]) ? 0 : (s[o - 1] + s[o]) / 2 : s[o - 1] : s[o] } !function (t, e, i) { const n = t.length; let s, r, o, a, l, c = IS(t, 0); for (let h = 0; h < n - 1; ++h)l = c, c = IS(t, h + 1), l && c && (nx(e[h], 0, MS) ? i[h] = i[h + 1] = 0 : (s = i[h] / e[h], r = i[h + 1] / e[h], a = Math.pow(s, 2) + Math.pow(r, 2), a <= 9 || (o = 3 / Math.sqrt(a), i[h] = s * o * e[h], i[h + 1] = r * o * e[h]))) }(t, s, r), function (t, e, i = "x") { const n = LS(i), s = t.length; let r, o, a, l = IS(t, 0); for (let c = 0; c < s; ++c) { if (o = a, a = l, l = IS(t, c + 1), !a) continue; const s = a[i], h = a[n]; o && (r = (s - o[i]) / 3, a[`cp1${i}`] = s - r, a[`cp1${n}`] = h - r * e[c]), l && (r = (l[i] - s) / 3, a[`cp2${i}`] = s + r, a[`cp2${n}`] = h + r * e[c]) } }(t, r, e) }(t, s); else { let i = n ? t[t.length - 1] : t[0]; for (r = 0, o = t.length; r < o; ++r)a = t[r], l = FS(i, a, t[Math.min(r + 1, o - (n ? 0 : 1)) % o], e.tension), a.cp1x = l.previous.x, a.cp1y = l.previous.y, a.cp2x = l.next.x, a.cp2y = l.next.y, i = a } e.capBezierPoints && function (t, e) { let i, n, s, r, o, a = tS(t[0], e); for (i = 0, n = t.length; i < n; ++i)o = r, r = a, a = i < n - 1 && tS(t[i + 1], e), r && (s = t[i], o && (s.cp1x = NS(s.cp1x, e.left, e.right), s.cp1y = NS(s.cp1y, e.top, e.bottom)), a && (s.cp2x = NS(s.cp2x, e.left, e.right), s.cp2y = NS(s.cp2y, e.top, e.bottom))) }(t, i) }(this._points, i, t, i.spanGaps ? this._loop : this._fullLoop, e), this._pointsUpdated = !0) } set points(t) { this._points = t, delete this._segments, delete this._path, this._pointsUpdated = !1 } get points() { return this._points } get segments() { return this._segments || (this._segments = function (t, e) { const i = t.points, n = t.options.spanGaps, s = i.length; if (!s) return []; const r = !!t._loop, { start: o, end: a } = function (t, e, i, n) { let s = 0, r = e - 1; if (i && !n) for (; s < e && !t[s].skip;)s++; for (; s < e && t[s].skip;)s++; for (s %= e, i && (r += s); r > s && t[r % e].skip;)r--; return r %= e, { start: s, end: r } }(i, s, r, n); return function (t, e, i, n) { return n && n.setContext && i ? function (t, e, i, n) { const s = t._chart.getContext(), r = rk(t.options), { _datasetIndex: o, options: { spanGaps: a } } = t, l = i.length, c = []; let h = r, u = e[0].start, d = u; function p(t, e, n, s) { const r = a ? -1 : 1; if (t !== e) { for (t += l; i[t % l].skip;)t -= r; for (; i[e % l].skip;)e += r; t % l != e % l && (c.push({ start: t % l, end: e % l, loop: n, style: s }), h = s, u = e % l) } } for (const f of e) { u = a ? u : f.start; let t, e = i[u % l]; for (d = u + 1; d <= f.end; d++) { const r = i[d % l]; t = rk(n.setContext(vS(s, { type: "segment", p0: e, p1: r, p0DataIndex: (d - 1) % l, p1DataIndex: d % l, datasetIndex: o }))), ok(t, h) && p(u, d - 1, f.loop, h), e = r, h = t } u < d - 1 && p(u, d - 1, f.loop, h) } return c }(t, e, i, n) : e }(t, !0 === n ? [{ start: o, end: a, loop: r }] : function (t, e, i, n) { const s = t.length, r = []; let o, a = e, l = t[e]; for (o = e + 1; o <= i; ++o) { const i = t[o % s]; i.skip || i.stop ? l.skip || (r.push({ start: e % s, end: (o - 1) % s, loop: n = !1 }), e = a = i.stop ? o : null) : (a = o, l.skip && (e = o)), l = i } return null !== a && r.push({ start: e % s, end: a % s, loop: n }), r }(i, o, a < o ? a + s : a, !!t._fullLoop && 0 === o && a === s - 1), i, e) }(this, this.options.segment)) } first() { const t = this.segments; return t.length && this.points[t[0].start] } last() { const t = this.segments, e = t.length; return e && this.points[t[e - 1].end] } interpolate(t, e) { const i = this.options, n = t[e], s = this.points, r = sk(this, { property: e, start: n, end: n }); if (!r.length) return; const o = [], a = function (t) { return t.stepped ? YS : t.tension || "monotone" === t.cubicInterpolationMode ? QS : KS }(i); let l, c; for (l = 0, c = r.length; l < c; ++l) { const { start: c, end: h } = r[l], u = s[c], d = s[h]; if (u === d) { o.push(u); continue } const p = a(u, d, Math.abs((n - u[e]) / (d[e] - u[e])), i.stepped); p[e] = t[e], o.push(p) } return 1 === o.length ? o[0] : o } pathSegment(t, e, i) { return pE(this)(t, this, e, i) } path(t, e, i) { const n = this.segments, s = pE(this); let r = this._loop; e = e || 0, i = i || this.points.length - e; for (const o of n) r &= s(t, this, o, { start: e, end: e + i - 1 }); return !!r } draw(t, e, i, n) { (this.points || []).length && (this.options || {}).borderWidth && (t.save(), function (t, e, i, n) { fE && !e.options.segment ? function (t, e, i, n) { let s = e._path; s || (s = e._path = new Path2D, e.path(s, i, n) && s.closePath()), lE(t, e.options), t.stroke(s) }(t, e, i, n) : function (t, e, i, n) { const { segments: s, options: r } = e, o = pE(e); for (const a of s) lE(t, r, a.style), t.beginPath(), o(t, e, a, { start: i, end: i + n - 1 }) && t.closePath(), t.stroke() }(t, e, i, n) }(t, this, i, n), t.restore()), this.animated && (this._pointsUpdated = !1, this._path = void 0) } } function mE(t, e, i, n) { const s = t.options, { [i]: r } = t.getProps([i], n); return Math.abs(e - r) < s.radius + s.hitRadius } function _E(t, e) { const { x: i, y: n, base: s, width: r, height: o } = t.getProps(["x", "y", "base", "width", "height"], e); let a, l, c, h, u; return t.horizontal ? (u = o / 2, a = Math.min(i, s), l = Math.max(i, s), c = n - u, h = n + u) : (u = r / 2, a = i - u, l = i + u, c = Math.min(n, s), h = Math.max(n, s)), { left: a, top: c, right: l, bottom: h } } function vE(t, e, i, n) { return t ? 0 : gx(e, i, n) } function yE(t, e, i, n) { const s = null === e, r = null === i, o = t && !(s && r) && _E(t, n); return o && (s || mx(e, o.left, o.right)) && (r || mx(i, o.top, o.bottom)) } function bE(t, e) { t.rect(e.x, e.y, e.w, e.h) } function wE(t, e, i = {}) { const n = t.x !== i.x ? -e : 0, s = t.y !== i.y ? -e : 0; return { x: t.x + n, y: t.y + s, w: t.w + ((t.x + t.w !== i.x + i.w ? e : 0) - n), h: t.h + ((t.y + t.h !== i.y + i.h ? e : 0) - s), radius: t.radius } } var xE = Object.freeze({ __proto__: null, ArcElement: class extends yC { static id = "arc"; static defaults = { borderAlign: "center", borderColor: "#fff", borderDash: [], borderDashOffset: 0, borderJoinStyle: void 0, borderRadius: 0, borderWidth: 2, offset: 0, spacing: 0, angle: void 0, circular: !0 }; static defaultRoutes = { backgroundColor: "backgroundColor" }; static descriptors = { _scriptable: !0, _indexable: t => "borderDash" !== t }; circumference; endAngle; fullCircles; innerRadius; outerRadius; pixelMargin; startAngle; constructor(t) { super(), this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, t && Object.assign(this, t) } inRange(t, e, i) { const n = this.getProps(["x", "y"], i), { angle: s, distance: r } = hx(n, { x: t, y: e }), { startAngle: o, endAngle: a, innerRadius: l, outerRadius: c, circumference: h } = this.getProps(["startAngle", "endAngle", "innerRadius", "outerRadius", "circumference"], i), u = (this.options.spacing + this.options.borderWidth) / 2, d = Aw(h, a - o) >= Zw || fx(s, o, a), p = mx(r, l + u, c + u); return d && p } getCenterPoint(t) { const { x: e, y: i, startAngle: n, endAngle: s, innerRadius: r, outerRadius: o } = this.getProps(["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"], t), { offset: a, spacing: l } = this.options, c = (n + s) / 2, h = (r + o + l + a) / 2; return { x: e + Math.cos(c) * h, y: i + Math.sin(c) * h } } tooltipPosition(t) { return this.getCenterPoint(t) } draw(t) { const { options: e, circumference: i } = this, n = (e.offset || 0) / 4, s = (e.spacing || 0) / 2, r = e.circular; if (this.pixelMargin = "inner" === e.borderAlign ? .33 : 0, this.fullCircles = i > Zw ? Math.floor(i / Zw) : 0, 0 === i || this.innerRadius < 0 || this.outerRadius < 0) return; t.save(); const o = (this.startAngle + this.endAngle) / 2; t.translate(Math.cos(o) * n, Math.sin(o) * n); const a = n * (1 - Math.sin(Math.min(Gw, i || 0))); t.fillStyle = e.backgroundColor, t.strokeStyle = e.borderColor, function (t, e, i, n, s) { const { fullCircles: r, startAngle: o, circumference: a } = e; let l = e.endAngle; if (r) { aE(t, e, i, n, l, s); for (let e = 0; e < r; ++e)t.fill(); isNaN(a) || (l = o + (a % Zw || Zw)) } aE(t, e, i, n, l, s), t.fill() }(t, this, a, s, r), function (t, e, i, n, s) { const { fullCircles: r, startAngle: o, circumference: a, options: l } = e, { borderWidth: c, borderJoinStyle: h, borderDash: u, borderDashOffset: d } = l, p = "inner" === l.borderAlign; if (!c) return; t.setLineDash(u || []), t.lineDashOffset = d, p ? (t.lineWidth = 2 * c, t.lineJoin = h || "round") : (t.lineWidth = c, t.lineJoin = h || "bevel"); let f = e.endAngle; if (r) { aE(t, e, i, n, f, s); for (let e = 0; e < r; ++e)t.stroke(); isNaN(a) || (f = o + (a % Zw || Zw)) } p && function (t, e, i) { const { startAngle: n, pixelMargin: s, x: r, y: o, outerRadius: a, innerRadius: l } = e; let c = s / a; t.beginPath(), t.arc(r, o, a, n - c, i + c), l > s ? (c = s / l, t.arc(r, o, l, i + c, n - c, !0)) : t.arc(r, o, s, i + Xw, n - Xw), t.closePath(), t.clip() }(t, e, f), r || (aE(t, e, i, n, f, s), t.stroke()) }(t, this, a, s, r), t.restore() } }, BarElement: class extends yC { static id = "bar"; static defaults = { borderSkipped: "start", borderWidth: 0, borderRadius: 0, inflateAmount: "auto", pointStyle: void 0 }; static defaultRoutes = { backgroundColor: "backgroundColor", borderColor: "borderColor" }; constructor(t) { super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, t && Object.assign(this, t) } draw(t) { const { inflateAmount: e, options: { borderColor: i, backgroundColor: n } } = this, { inner: s, outer: r } = function (t) { const e = _E(t), i = e.right - e.left, n = e.bottom - e.top, s = function (t, e, i) { const n = t.borderSkipped, s = pS(t.options.borderWidth); return { t: vE(n.top, s.top, 0, i), r: vE(n.right, s.right, 0, e), b: vE(n.bottom, s.bottom, 0, i), l: vE(n.left, s.left, 0, e) } }(t, i / 2, n / 2), r = function (t, e, i) { const { enableBorderRadius: n } = t.getProps(["enableBorderRadius"]), s = t.options.borderRadius, r = fS(s), o = Math.min(e, i), a = t.borderSkipped, l = n || Tw(s); return { topLeft: vE(!l || a.top || a.left, r.topLeft, 0, o), topRight: vE(!l || a.top || a.right, r.topRight, 0, o), bottomLeft: vE(!l || a.bottom || a.left, r.bottomLeft, 0, o), bottomRight: vE(!l || a.bottom || a.right, r.bottomRight, 0, o) } }(t, i / 2, n / 2); return { outer: { x: e.left, y: e.top, w: i, h: n, radius: r }, inner: { x: e.left + s.l, y: e.top + s.t, w: i - s.l - s.r, h: n - s.t - s.b, radius: { topLeft: Math.max(0, r.topLeft - Math.max(s.t, s.l)), topRight: Math.max(0, r.topRight - Math.max(s.t, s.r)), bottomLeft: Math.max(0, r.bottomLeft - Math.max(s.b, s.l)), bottomRight: Math.max(0, r.bottomRight - Math.max(s.b, s.r)) } } } }(this), o = (a = r.radius).topLeft || a.topRight || a.bottomLeft || a.bottomRight ? lS : bE; var a; t.save(), r.w === s.w && r.h === s.h || (t.beginPath(), o(t, wE(r, e, s)), t.clip(), o(t, wE(s, -e, r)), t.fillStyle = i, t.fill("evenodd")), t.beginPath(), o(t, wE(s, e)), t.fillStyle = n, t.fill(), t.restore() } inRange(t, e, i) { return yE(this, t, e, i) } inXRange(t, e) { return yE(this, t, null, e) } inYRange(t, e) { return yE(this, null, t, e) } getCenterPoint(t) { const { x: e, y: i, base: n, horizontal: s } = this.getProps(["x", "y", "base", "horizontal"], t); return { x: s ? (e + n) / 2 : e, y: s ? i : (i + n) / 2 } } getRange(t) { return "x" === t ? this.width / 2 : this.height / 2 } }, LineElement: gE, PointElement: class extends yC { static id = "point"; parsed; skip; stop; static defaults = { borderWidth: 1, hitRadius: 1, hoverBorderWidth: 1, hoverRadius: 4, pointStyle: "circle", radius: 3, rotation: 0 }; static defaultRoutes = { backgroundColor: "backgroundColor", borderColor: "borderColor" }; constructor(t) { super(), this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, t && Object.assign(this, t) } inRange(t, e, i) { const n = this.options, { x: s, y: r } = this.getProps(["x", "y"], i); return Math.pow(t - s, 2) + Math.pow(e - r, 2) < Math.pow(n.hitRadius + n.radius, 2) } inXRange(t, e) { return mE(this, t, "x", e) } inYRange(t, e) { return mE(this, t, "y", e) } getCenterPoint(t) { const { x: e, y: i } = this.getProps(["x", "y"], t); return { x: e, y: i } } size(t) { let e = (t = t || this.options || {}).radius || 0; return e = Math.max(e, e && t.hoverRadius || 0), 2 * (e + (e && t.borderWidth || 0)) } draw(t, e) { const i = this.options; this.skip || i.radius < .1 || !tS(this, e, this.size(i) / 2) || (t.strokeStyle = i.borderColor, t.lineWidth = i.borderWidth, t.fillStyle = i.backgroundColor, Xx(t, i, this.x, this.y)) } getRange() { const t = this.options || {}; return t.radius + t.hitRadius } } }); const SE = ["rgb(54, 162, 235)", "rgb(255, 99, 132)", "rgb(255, 159, 64)", "rgb(255, 205, 86)", "rgb(75, 192, 192)", "rgb(153, 102, 255)", "rgb(201, 203, 207)"], kE = SE.map(t => t.replace("rgb(", "rgba(").replace(")", ", 0.5)")); function CE(t) { return SE[t % SE.length] } function EE(t) { return kE[t % kE.length] } function TE(t) { let e; for (e in t) if (t[e].borderColor || t[e].backgroundColor) return !0; return !1 } var PE = { id: "colors", defaults: { enabled: !0, forceOverride: !1 }, beforeLayout(t, e, i) { if (!i.enabled) return; const { data: { datasets: n }, options: s } = t.config, { elements: r } = s; if (!i.forceOverride && (TE(n) || (o = s) && (o.borderColor || o.backgroundColor) || r && TE(r))) return; var o; const a = function (t) { let e = 0; return (i, n) => { const s = t.getDatasetMeta(n).controller; s instanceof Mk ? e = function (t, e) { return t.backgroundColor = t.data.map(() => CE(e++)), e }(i, e) : s instanceof Ik ? e = function (t, e) { return t.backgroundColor = t.data.map(() => EE(e++)), e }(i, e) : s && (e = function (t, e) { return t.borderColor = CE(e), t.backgroundColor = EE(e), ++e }(i, e)) } }(t); n.forEach(a) } }; function DE(t) { if (t._decimated) { const e = t._data; delete t._decimated, delete t._data, Object.defineProperty(t, "data", { configurable: !0, enumerable: !0, writable: !0, value: e }) } } function AE(t) { t.data.datasets.forEach(t => { DE(t) }) } var OE = { id: "decimation", defaults: { algorithm: "min-max", enabled: !1 }, beforeElementsUpdate: (t, e, i) => { if (!i.enabled) return void AE(t); const n = t.width; t.data.datasets.forEach((e, s) => { const { _data: r, indexAxis: o } = e, a = t.getDatasetMeta(s), l = r || e.data; if ("y" === _S([o, t.options.indexAxis])) return; if (!a.controller.supportsDecimation) return; const c = t.scales[a.xAxisID]; if ("linear" !== c.type && "time" !== c.type) return; if (t.options.parsing) return; let h, { start: u, count: d } = function (t, e) { const i = e.length; let n, s = 0; const { iScale: r } = t, { min: o, max: a, minDefined: l, maxDefined: c } = r.getUserBounds(); return l && (s = gx(vx(e, r.axis, o).lo, 0, i - 1)), n = c ? gx(vx(e, r.axis, a).hi + 1, s, i) - s : i - s, { start: s, count: n } }(a, l); if (d <= (i.threshold || 4 * n)) DE(e); else { switch (Cw(r) && (e._data = l, delete e.data, Object.defineProperty(e, "data", { configurable: !0, enumerable: !0, get: function () { return this._decimated }, set: function (t) { this._data = t } })), i.algorithm) { case "lttb": h = function (t, e, i, n, s) { const r = s.samples || n; if (r >= i) return t.slice(e, e + i); const o = [], a = (i - 2) / (r - 2); let l = 0; const c = e + i - 1; let h, u, d, p, f, g = e; for (o[l++] = t[g], h = 0; h < r - 2; h++) { let n, s = 0, r = 0; const c = Math.floor((h + 1) * a) + 1 + e, m = Math.min(Math.floor((h + 2) * a) + 1, i) + e, _ = m - c; for (n = c; n < m; n++)s += t[n].x, r += t[n].y; s /= _, r /= _; const v = Math.floor(h * a) + 1 + e, y = Math.min(Math.floor((h + 1) * a) + 1, i) + e, { x: b, y: w } = t[g]; for (d = p = -1, n = v; n < y; n++)p = .5 * Math.abs((b - s) * (t[n].y - w) - (b - t[n].x) * (r - w)), p > d && (d = p, u = t[n], f = n); o[l++] = u, g = f } return o[l++] = t[c], o }(l, u, d, n, i); break; case "min-max": h = function (t, e, i, n) { let s, r, o, a, l, c, h, u, d, p, f = 0, g = 0; const m = [], _ = t[e].x, v = t[e + i - 1].x - _; for (s = e; s < e + i; ++s) { r = t[s], o = (r.x - _) / v * n, a = r.y; const e = 0 | o; if (e === l) a < d ? (d = a, c = s) : a > p && (p = a, h = s), f = (g * f + r.x) / ++g; else { const i = s - 1; if (!Cw(c) && !Cw(h)) { const e = Math.min(c, h), n = Math.max(c, h); e !== u && e !== i && m.push({ ...t[e], x: f }), n !== u && n !== i && m.push({ ...t[n], x: f }) } s > 0 && i !== u && m.push(t[i]), m.push(r), l = e, g = 0, d = p = a, c = h = u = s } } return m }(l, u, d, n); break; default: throw new Error(`Unsupported decimation algorithm '${i.algorithm}'`) }e._decimated = h } }) }, destroy(t) { AE(t) } }; function RE(t, e, i, n) { if (n) return; let s = e[t], r = i[t]; return "angle" === t && (s = px(s), r = px(r)), { property: t, start: s, end: r } } function ME(t, e, i) { for (; e > t; e--) { const t = i[e]; if (!isNaN(t.x) && !isNaN(t.y)) break } return e } function IE(t, e, i, n) { return t && e ? n(t[i], e[i]) : t ? t[i] : e ? e[i] : 0 } function LE(t, e) { let i = [], n = !1; return Ew(t) ? (n = !0, i = t) : i = function (t, e) { const { x: i = null, y: n = null } = t || {}, s = e.points, r = []; return e.segments.forEach(({ start: t, end: e }) => { e = ME(t, e, s); const o = s[t], a = s[e]; null !== n ? (r.push({ x: o.x, y: n }), r.push({ x: a.x, y: n })) : null !== i && (r.push({ x: i, y: o.y }), r.push({ x: i, y: a.y })) }), r }(t, e), i.length ? new gE({ points: i, options: { tension: 0 }, _loop: n, _fullLoop: n }) : null } function FE(t) { return t && !1 !== t.fill } function NE(t, e, i) { let n = t[e].fill; const s = [e]; let r; if (!i) return n; for (; !1 !== n && -1 === s.indexOf(n);) { if (!Pw(n)) return n; if (r = t[n], !r) return !1; if (r.visible) return n; s.push(n), n = r.fill } return !1 } function jE(t, e, i) { const n = function (t) { const e = t.options, i = e.fill; let n = Aw(i && i.target, i); return void 0 === n && (n = !!e.backgroundColor), !1 !== n && null !== n && (!0 === n ? "origin" : n) }(t); if (Tw(n)) return !isNaN(n.value) && n; let s = parseFloat(n); return Pw(s) && Math.floor(s) === s ? function (t, e, i, n) { return "-" !== t && "+" !== t || (i = e + i), !(i === e || i < 0 || i >= n) && i }(n[0], e, s, i) : ["origin", "start", "end", "stack", "shape"].indexOf(n) >= 0 && n } function VE(t, e, i) { const n = []; for (let s = 0; s < i.length; s++) { const r = i[s], { first: o, last: a, point: l } = BE(r, e, "x"); if (!(!l || o && a)) if (o) n.unshift(l); else if (t.push(l), !a) break } t.push(...n) } function BE(t, e, i) { const n = t.interpolate(e, i); if (!n) return {}; const s = n[i], r = t.segments, o = t.points; let a = !1, l = !1; for (let c = 0; c < r.length; c++) { const t = r[c], e = o[t.start][i], n = o[t.end][i]; if (mx(s, e, n)) { a = s === e, l = s === n; break } } return { first: a, last: l, point: n } } class HE { constructor(t) { this.x = t.x, this.y = t.y, this.radius = t.radius } pathSegment(t, e, i) { const { x: n, y: s, radius: r } = this; return t.arc(n, s, r, (e = e || { start: 0, end: Zw }).end, e.start, !0), !i.bounds } interpolate(t) { const { x: e, y: i, radius: n } = this, s = t.angle; return { x: e + Math.cos(s) * n, y: i + Math.sin(s) * n, angle: s } } } function zE(t, e, i) { const n = function (t) { const { chart: e, fill: i, line: n } = t; if (Pw(i)) return function (t, e) { const i = t.getDatasetMeta(e); return i && t.isDatasetVisible(e) ? i.dataset : null }(e, i); if ("stack" === i) return function (t) { const { scale: e, index: i, line: n } = t, s = [], r = n.segments, o = n.points, a = function (t, e) { const i = [], n = t.getMatchingVisibleMetas("line"); for (let s = 0; s < n.length; s++) { const t = n[s]; if (t.index === e) break; t.hidden || i.unshift(t.dataset) } return i }(e, i); a.push(LE({ x: null, y: e.bottom }, n)); for (let l = 0; l < r.length; l++) { const t = r[l]; for (let e = t.start; e <= t.end; e++)VE(s, o[e], a) } return new gE({ points: s, options: {} }) }(t); if ("shape" === i) return !0; const s = function (t) { return (t.scale || {}).getPointPositionForValue ? function (t) { const { scale: e, fill: i } = t, n = e.options, s = e.getLabels().length, r = n.reverse ? e.max : e.min, o = function (t, e, i) { let n; return n = "start" === t ? i : "end" === t ? e.options.reverse ? e.min : e.max : Tw(t) ? t.value : e.getBaseValue(), n }(i, e, r), a = []; if (n.grid.circular) { const t = e.getPointPositionForValue(0, r); return new HE({ x: t.x, y: t.y, radius: e.getDistanceFromCenterForValue(o) }) } for (let l = 0; l < s; ++l)a.push(e.getPointPositionForValue(l, o)); return a }(t) : function (t) { const { scale: e = {}, fill: i } = t, n = function (t, e) { let i = null; return "start" === t ? i = e.bottom : "end" === t ? i = e.top : Tw(t) ? i = e.getPixelForValue(t.value) : e.getBasePixel && (i = e.getBasePixel()), i }(i, e); if (Pw(n)) { const t = e.isHorizontal(); return { x: t ? n : null, y: t ? null : n } } return null }(t) }(t); return s instanceof HE ? s : LE(s, n) }(e), { line: s, scale: r, axis: o } = e, a = s.options, l = a.fill, c = a.backgroundColor, { above: h = c, below: u = c } = l || {}; n && s.points.length && (eS(t, i), function (t, e) { const { line: i, target: n, above: s, below: r, area: o, scale: a } = e, l = i._loop ? "angle" : e.axis; t.save(), "x" === l && r !== s && ($E(t, n, o.top), UE(t, { line: i, target: n, color: s, scale: a, property: l }), t.restore(), t.save(), $E(t, n, o.bottom)), UE(t, { line: i, target: n, color: r, scale: a, property: l }), t.restore() }(t, { line: s, target: n, above: h, below: u, area: i, scale: r, axis: o }), iS(t)) } function $E(t, e, i) { const { segments: n, points: s } = e; let r = !0, o = !1; t.beginPath(); for (const a of n) { const { start: n, end: l } = a, c = s[n], h = s[ME(n, l, s)]; r ? (t.moveTo(c.x, c.y), r = !1) : (t.lineTo(c.x, i), t.lineTo(c.x, c.y)), o = !!e.pathSegment(t, a, { move: o }), o ? t.closePath() : t.lineTo(h.x, i) } t.lineTo(e.first().x, i), t.closePath(), t.clip() } function UE(t, e) { const { line: i, target: n, property: s, color: r, scale: o } = e, a = function (t, e, i) { const n = t.segments, s = t.points, r = e.points, o = []; for (const a of n) { let { start: t, end: n } = a; n = ME(t, n, s); const l = RE(i, s[t], s[n], a.loop); if (!e.segments) { o.push({ source: a, target: l, start: s[t], end: s[n] }); continue } const c = sk(e, l); for (const e of c) { const t = RE(i, r[e.start], r[e.end], e.loop), n = nk(a, s, t); for (const s of n) o.push({ source: s, target: e, start: { [i]: IE(l, t, "start", Math.max) }, end: { [i]: IE(l, t, "end", Math.min) } }) } } return o }(i, n, s); for (const { source: l, target: c, start: h, end: u } of a) { const { style: { backgroundColor: e = r } = {} } = l, a = !0 !== n; t.save(), t.fillStyle = e, WE(t, o, a && RE(s, h, u)), t.beginPath(); const d = !!i.pathSegment(t, l); let p; if (a) { d ? t.closePath() : qE(t, n, u, s); const e = !!n.pathSegment(t, c, { move: d, reverse: !0 }); p = d && e, p || qE(t, n, h, s) } t.closePath(), t.fill(p ? "evenodd" : "nonzero"), t.restore() } } function WE(t, e, i) { const { top: n, bottom: s } = e.chart.chartArea, { property: r, start: o, end: a } = i || {}; "x" === r && (t.beginPath(), t.rect(o, n, a - o, s - n), t.clip()) } function qE(t, e, i, n) { const s = e.interpolate(i, n); s && t.lineTo(s.x, s.y) } var GE = { id: "filler", afterDatasetsUpdate(t, e, i) { const n = (t.data.datasets || []).length, s = []; let r, o, a, l; for (o = 0; o < n; ++o)r = t.getDatasetMeta(o), a = r.dataset, l = null, a && a.options && a instanceof gE && (l = { visible: t.isDatasetVisible(o), index: o, fill: jE(a, o, n), chart: t, axis: r.controller.options.indexAxis, scale: r.vScale, line: a }), r.$filler = l, s.push(l); for (o = 0; o < n; ++o)l = s[o], l && !1 !== l.fill && (l.fill = NE(s, o, i.propagate)) }, beforeDraw(t, e, i) { const n = "beforeDraw" === i.drawTime, s = t.getSortedVisibleDatasetMetas(), r = t.chartArea; for (let o = s.length - 1; o >= 0; --o) { const e = s[o].$filler; e && (e.line.updateControlPoints(r, e.axis), n && e.fill && zE(t.ctx, e, r)) } }, beforeDatasetsDraw(t, e, i) { if ("beforeDatasetsDraw" !== i.drawTime) return; const n = t.getSortedVisibleDatasetMetas(); for (let s = n.length - 1; s >= 0; --s) { const e = n[s].$filler; FE(e) && zE(t.ctx, e, t.chartArea) } }, beforeDatasetDraw(t, e, i) { const n = e.meta.$filler; FE(n) && "beforeDatasetDraw" === i.drawTime && zE(t.ctx, n, t.chartArea) }, defaults: { propagate: !0, drawTime: "beforeDatasetDraw" } }; const ZE = (t, e) => { let { boxHeight: i = e, boxWidth: n = e } = t; return t.usePointStyle && (i = Math.min(i, e), n = t.pointStyleWidth || Math.min(n, e)), { boxWidth: n, boxHeight: i, itemHeight: Math.max(e, i) } }; class KE extends yC { constructor(t) { super(), this._added = !1, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1, this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0 } update(t, e, i) { this.maxWidth = t, this.maxHeight = e, this._margins = i, this.setDimensions(), this.buildLabels(), this.fit() } setDimensions() { this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height) } buildLabels() { const t = this.options.labels || {}; let e = Rw(t.generateLabels, [this.chart], this) || []; t.filter && (e = e.filter(e => t.filter(e, this.chart.data))), t.sort && (e = e.sort((e, i) => t.sort(e, i, this.chart.data))), this.options.reverse && e.reverse(), this.legendItems = e } fit() { const { options: t, ctx: e } = this; if (!t.display) return void (this.width = this.height = 0); const i = t.labels, n = mS(i.font), s = n.size, r = this._computeTitleHeight(), { boxWidth: o, itemHeight: a } = ZE(i, s); let l, c; e.font = n.string, this.isHorizontal() ? (l = this.maxWidth, c = this._fitRows(r, s, o, a) + 10) : (c = this.maxHeight, l = this._fitCols(r, n, o, a) + 10), this.width = Math.min(l, t.maxWidth || this.maxWidth), this.height = Math.min(c, t.maxHeight || this.maxHeight) } _fitRows(t, e, i, n) { const { ctx: s, maxWidth: r, options: { labels: { padding: o } } } = this, a = this.legendHitBoxes = [], l = this.lineWidths = [0], c = n + o; let h = t; s.textAlign = "left", s.textBaseline = "middle"; let u = -1, d = -c; return this.legendItems.forEach((t, p) => { const f = i + e / 2 + s.measureText(t.text).width; (0 === p || l[l.length - 1] + f + 2 * o > r) && (h += c, l[l.length - (p > 0 ? 0 : 1)] = 0, d += c, u++), a[p] = { left: 0, top: d, row: u, width: f, height: n }, l[l.length - 1] += f + o }), h } _fitCols(t, e, i, n) { const { ctx: s, maxHeight: r, options: { labels: { padding: o } } } = this, a = this.legendHitBoxes = [], l = this.columnSizes = [], c = r - t; let h = o, u = 0, d = 0, p = 0, f = 0; return this.legendItems.forEach((t, r) => { const { itemWidth: g, itemHeight: m } = function (t, e, i, n, s) { return { itemWidth: function (t, e, i, n) { let s = t.text; return s && "string" != typeof s && (s = s.reduce((t, e) => t.length > e.length ? t : e)), e + i.size / 2 + n.measureText(s).width }(n, t, e, i), itemHeight: function (t, e, i) { let n = t; return "string" != typeof e.text && (n = YE(e, i)), n }(s, n, e.lineHeight) } }(i, e, s, t, n); r > 0 && d + m + 2 * o > c && (h += u + o, l.push({ width: u, height: d }), p += u + o, f++, u = d = 0), a[r] = { left: p, top: d, col: f, width: g, height: m }, u = Math.max(u, g), d += m + o }), h += u, l.push({ width: u, height: d }), h } adjustHitBoxes() { if (!this.options.display) return; const t = this._computeTitleHeight(), { legendHitBoxes: e, options: { align: i, labels: { padding: n }, rtl: s } } = this, r = XS(s, this.left, this.width); if (this.isHorizontal()) { let s = 0, o = Ex(i, this.left + n, this.right - this.lineWidths[s]); for (const a of e) s !== a.row && (s = a.row, o = Ex(i, this.left + n, this.right - this.lineWidths[s])), a.top += this.top + t + n, a.left = r.leftForLtr(r.x(o), a.width), o += a.width + n } else { let s = 0, o = Ex(i, this.top + t + n, this.bottom - this.columnSizes[s].height); for (const a of e) a.col !== s && (s = a.col, o = Ex(i, this.top + t + n, this.bottom - this.columnSizes[s].height)), a.top = o, a.left += this.left + n, a.left = r.leftForLtr(r.x(a.left), a.width), o += a.height + n } } isHorizontal() { return "top" === this.options.position || "bottom" === this.options.position } draw() { if (this.options.display) { const t = this.ctx; eS(t, this), this._draw(), iS(t) } } _draw() { const { options: t, columnSizes: e, lineWidths: i, ctx: n } = this, { align: s, labels: r } = t, o = Gx.color, a = XS(t.rtl, this.left, this.width), l = mS(r.font), { padding: c } = r, h = l.size, u = h / 2; let d; this.drawTitle(), n.textAlign = a.textAlign("left"), n.textBaseline = "middle", n.lineWidth = .5, n.font = l.string; const { boxWidth: p, boxHeight: f, itemHeight: g } = ZE(r, h), m = this.isHorizontal(), _ = this._computeTitleHeight(); d = m ? { x: Ex(s, this.left + c, this.right - i[0]), y: this.top + c + _, line: 0 } : { x: this.left + c, y: Ex(s, this.top + _ + c, this.bottom - e[0].height), line: 0 }, JS(this.ctx, t.textDirection); const v = g + c; this.legendItems.forEach((y, b) => { n.strokeStyle = y.fontColor, n.fillStyle = y.fontColor; const w = n.measureText(y.text).width, x = a.textAlign(y.textAlign || (y.textAlign = r.textAlign)), S = p + u + w; let k = d.x, C = d.y; a.setWidth(this.width), m ? b > 0 && k + S + c > this.right && (C = d.y += v, d.line++, k = d.x = Ex(s, this.left + c, this.right - i[d.line])) : b > 0 && C + v > this.bottom && (k = d.x = k + e[d.line].width + c, d.line++, C = d.y = Ex(s, this.top + _ + c, this.bottom - e[d.line].height)), function (t, e, i) { if (isNaN(p) || p <= 0 || isNaN(f) || f < 0) return; n.save(); const s = Aw(i.lineWidth, 1); if (n.fillStyle = Aw(i.fillStyle, o), n.lineCap = Aw(i.lineCap, "butt"), n.lineDashOffset = Aw(i.lineDashOffset, 0), n.lineJoin = Aw(i.lineJoin, "miter"), n.lineWidth = s, n.strokeStyle = Aw(i.strokeStyle, o), n.setLineDash(Aw(i.lineDash, [])), r.usePointStyle) { const o = { radius: f * Math.SQRT2 / 2, pointStyle: i.pointStyle, rotation: i.rotation, borderWidth: s }, l = a.xPlus(t, p / 2); Jx(n, o, l, e + u, r.pointStyleWidth && p) } else { const r = e + Math.max((h - f) / 2, 0), o = a.leftForLtr(t, p), l = fS(i.borderRadius); n.beginPath(), Object.values(l).some(t => 0 !== t) ? lS(n, { x: o, y: r, w: p, h: f, radius: l }) : n.rect(o, r, p, f), n.fill(), 0 !== s && n.stroke() } n.restore() }(a.x(k), C, y), k = ((t, e, i, n) => t === (n ? "left" : "right") ? i : "center" === t ? (e + i) / 2 : e)(x, k + p + u, m ? k + S : this.right, t.rtl), function (t, e, i) { aS(n, i.text, t, e + g / 2, l, { strikethrough: i.hidden, textAlign: a.textAlign(i.textAlign) }) }(a.x(k), C, y), m ? d.x += S + c : d.y += "string" != typeof y.text ? YE(y, l.lineHeight) + c : v }), tk(this.ctx, t.textDirection) } drawTitle() { const t = this.options, e = t.title, i = mS(e.font), n = gS(e.padding); if (!e.display) return; const s = XS(t.rtl, this.left, this.width), r = this.ctx, o = e.position, a = n.top + i.size / 2; let l, c = this.left, h = this.width; if (this.isHorizontal()) h = Math.max(...this.lineWidths), l = this.top + a, c = Ex(t.align, c, this.right - h); else { const e = this.columnSizes.reduce((t, e) => Math.max(t, e.height), 0); l = a + Ex(t.align, this.top, this.bottom - e - t.labels.padding - this._computeTitleHeight()) } const u = Ex(o, c, c + h); r.textAlign = s.textAlign(Cx(o)), r.textBaseline = "middle", r.strokeStyle = e.color, r.fillStyle = e.color, r.font = i.string, aS(r, e.text, u, l, i) } _computeTitleHeight() { const t = this.options.title, e = mS(t.font), i = gS(t.padding); return t.display ? e.lineHeight + i.height : 0 } _getLegendItemAt(t, e) { let i, n, s; if (mx(t, this.left, this.right) && mx(e, this.top, this.bottom)) for (s = this.legendHitBoxes, i = 0; i < s.length; ++i)if (n = s[i], mx(t, n.left, n.left + n.width) && mx(e, n.top, n.top + n.height)) return this.legendItems[i]; return null } handleEvent(t) { const e = this.options; if (!function (t, e) { return !("mousemove" !== t && "mouseout" !== t || !e.onHover && !e.onLeave) || !(!e.onClick || "click" !== t && "mouseup" !== t) }(t.type, e)) return; const i = this._getLegendItemAt(t.x, t.y); if ("mousemove" === t.type || "mouseout" === t.type) { const r = this._hoveredItem, o = (s = i, null !== (n = r) && null !== s && n.datasetIndex === s.datasetIndex && n.index === s.index); r && !o && Rw(e.onLeave, [t, r, this], this), this._hoveredItem = i, i && !o && Rw(e.onHover, [t, i, this], this) } else i && Rw(e.onClick, [t, i, this], this); var n, s } } function YE(t, e) { return e * (t.text ? t.text.length : 0) } var QE = { id: "legend", _element: KE, start(t, e, i) { const n = t.legend = new KE({ ctx: t.ctx, options: i, chart: t }); iC.configure(t, n, i), iC.addBox(t, n) }, stop(t) { iC.removeBox(t, t.legend), delete t.legend }, beforeUpdate(t, e, i) { const n = t.legend; iC.configure(t, n, i), n.options = i }, afterUpdate(t) { const e = t.legend; e.buildLabels(), e.adjustHitBoxes() }, afterEvent(t, e) { e.replay || t.legend.handleEvent(e.event) }, defaults: { display: !0, position: "top", align: "center", fullSize: !0, reverse: !1, weight: 1e3, onClick(t, e, i) { const n = e.datasetIndex, s = i.chart; s.isDatasetVisible(n) ? (s.hide(n), e.hidden = !0) : (s.show(n), e.hidden = !1) }, onHover: null, onLeave: null, labels: { color: t => t.chart.options.color, boxWidth: 40, padding: 10, generateLabels(t) { const e = t.data.datasets, { labels: { usePointStyle: i, pointStyle: n, textAlign: s, color: r, useBorderRadius: o, borderRadius: a } } = t.legend.options; return t._getSortedDatasetMetas().map(t => { const l = t.controller.getStyle(i ? 0 : void 0), c = gS(l.borderWidth); return { text: e[t.index].label, fillStyle: l.backgroundColor, fontColor: r, hidden: !t.visible, lineCap: l.borderCapStyle, lineDash: l.borderDash, lineDashOffset: l.borderDashOffset, lineJoin: l.borderJoinStyle, lineWidth: (c.width + c.height) / 4, strokeStyle: l.borderColor, pointStyle: n || l.pointStyle, rotation: l.rotation, textAlign: s || l.textAlign, borderRadius: o && (a || l.borderRadius), datasetIndex: t.index } }, this) } }, title: { color: t => t.chart.options.color, display: !1, position: "center", text: "" } }, descriptors: { _scriptable: t => !t.startsWith("on"), labels: { _scriptable: t => !["generateLabels", "filter", "sort"].includes(t) } } }; class XE extends yC { constructor(t) { super(), this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this._padding = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0 } update(t, e) { const i = this.options; if (this.left = 0, this.top = 0, !i.display) return void (this.width = this.height = this.right = this.bottom = 0); this.width = this.right = t, this.height = this.bottom = e; const n = Ew(i.text) ? i.text.length : 1; this._padding = gS(i.padding); const s = n * mS(i.font).lineHeight + this._padding.height; this.isHorizontal() ? this.height = s : this.width = s } isHorizontal() { const t = this.options.position; return "top" === t || "bottom" === t } _drawArgs(t) { const { top: e, left: i, bottom: n, right: s, options: r } = this, o = r.align; let a, l, c, h = 0; return this.isHorizontal() ? (l = Ex(o, i, s), c = e + t, a = s - i) : ("left" === r.position ? (l = i + t, c = Ex(o, n, e), h = -.5 * Gw) : (l = s - t, c = Ex(o, e, n), h = .5 * Gw), a = n - e), { titleX: l, titleY: c, maxWidth: a, rotation: h } } draw() { const t = this.ctx, e = this.options; if (!e.display) return; const i = mS(e.font), n = i.lineHeight / 2 + this._padding.top, { titleX: s, titleY: r, maxWidth: o, rotation: a } = this._drawArgs(n); aS(t, e.text, 0, 0, i, { color: e.color, maxWidth: o, rotation: a, textAlign: Cx(e.align), textBaseline: "middle", translation: [s, r] }) } } var JE = { id: "title", _element: XE, start(t, e, i) { !function (t, e) { const i = new XE({ ctx: t.ctx, options: e, chart: t }); iC.configure(t, i, e), iC.addBox(t, i), t.titleBlock = i }(t, i) }, stop(t) { iC.removeBox(t, t.titleBlock), delete t.titleBlock }, beforeUpdate(t, e, i) { const n = t.titleBlock; iC.configure(t, n, i), n.options = i }, defaults: { align: "center", display: !1, font: { weight: "bold" }, fullSize: !0, padding: 10, position: "top", text: "", weight: 2e3 }, defaultRoutes: { color: "color" }, descriptors: { _scriptable: !0, _indexable: !1 } }; const tT = new WeakMap; var eT = { id: "subtitle", start(t, e, i) { const n = new XE({ ctx: t.ctx, options: i, chart: t }); iC.configure(t, n, i), iC.addBox(t, n), tT.set(t, n) }, stop(t) { iC.removeBox(t, tT.get(t)), tT.delete(t) }, beforeUpdate(t, e, i) { const n = tT.get(t); iC.configure(t, n, i), n.options = i }, defaults: { align: "center", display: !1, font: { weight: "normal" }, fullSize: !0, padding: 0, position: "top", text: "", weight: 1500 }, defaultRoutes: { color: "color" }, descriptors: { _scriptable: !0, _indexable: !1 } }; const iT = { average(t) { if (!t.length) return !1; let e, i, n = 0, s = 0, r = 0; for (e = 0, i = t.length; e < i; ++e) { const i = t[e].element; if (i && i.hasValue()) { const t = i.tooltipPosition(); n += t.x, s += t.y, ++r } } return { x: n / r, y: s / r } }, nearest(t, e) { if (!t.length) return !1; let i, n, s, r = e.x, o = e.y, a = Number.POSITIVE_INFINITY; for (i = 0, n = t.length; i < n; ++i) { const n = t[i].element; if (n && n.hasValue()) { const t = ux(e, n.getCenterPoint()); t < a && (a = t, s = n) } } if (s) { const t = s.tooltipPosition(); r = t.x, o = t.y } return { x: r, y: o } } }; function nT(t, e) { return e && (Ew(e) ? Array.prototype.push.apply(t, e) : t.push(e)), t } function sT(t) { return ("string" == typeof t || t instanceof String) && t.indexOf("\n") > -1 ? t.split("\n") : t } function rT(t, e) { const { element: i, datasetIndex: n, index: s } = e, r = t.getDatasetMeta(n).controller, { label: o, value: a } = r.getLabelAndValue(s); return { chart: t, label: o, parsed: r.getParsed(s), raw: t.data.datasets[n].data[s], formattedValue: a, dataset: r.getDataset(), dataIndex: s, datasetIndex: n, element: i } } function oT(t, e) { const i = t.chart.ctx, { body: n, footer: s, title: r } = t, { boxWidth: o, boxHeight: a } = e, l = mS(e.bodyFont), c = mS(e.titleFont), h = mS(e.footerFont), u = r.length, d = s.length, p = n.length, f = gS(e.padding); let g = f.height, m = 0, _ = n.reduce((t, e) => t + e.before.length + e.lines.length + e.after.length, 0); _ += t.beforeBody.length + t.afterBody.length, u && (g += u * c.lineHeight + (u - 1) * e.titleSpacing + e.titleMarginBottom), _ && (g += p * (e.displayColors ? Math.max(a, l.lineHeight) : l.lineHeight) + (_ - p) * l.lineHeight + (_ - 1) * e.bodySpacing), d && (g += e.footerMarginTop + d * h.lineHeight + (d - 1) * e.footerSpacing); let v = 0; const y = function (t) { m = Math.max(m, i.measureText(t).width + v) }; return i.save(), i.font = c.string, Mw(t.title, y), i.font = l.string, Mw(t.beforeBody.concat(t.afterBody), y), v = e.displayColors ? o + 2 + e.boxPadding : 0, Mw(n, t => { Mw(t.before, y), Mw(t.lines, y), Mw(t.after, y) }), v = 0, i.font = h.string, Mw(t.footer, y), i.restore(), m += f.width, { width: m, height: g } } function aT(t, e, i, n) { const { x: s, width: r } = i, { width: o, chartArea: { left: a, right: l } } = t; let c = "center"; return "center" === n ? c = s <= (a + l) / 2 ? "left" : "right" : s <= r / 2 ? c = "left" : s >= o - r / 2 && (c = "right"), function (t, e, i, n) { const { x: s, width: r } = n, o = i.caretSize + i.caretPadding; return "left" === t && s + r + o > e.width || "right" === t && s - r - o < 0 || void 0 }(c, t, e, i) && (c = "center"), c } function lT(t, e, i) { const n = i.yAlign || e.yAlign || function (t, e) { const { y: i, height: n } = e; return i < n / 2 ? "top" : i > t.height - n / 2 ? "bottom" : "center" }(t, i); return { xAlign: i.xAlign || e.xAlign || aT(t, e, i, n), yAlign: n } } function cT(t, e, i, n) { const { caretSize: s, caretPadding: r, cornerRadius: o } = t, { xAlign: a, yAlign: l } = i, c = s + r, { topLeft: h, topRight: u, bottomLeft: d, bottomRight: p } = fS(o); let f = function (t, e) { let { x: i, width: n } = t; return "right" === e ? i -= n : "center" === e && (i -= n / 2), i }(e, a); const g = function (t, e, i) { let { y: n, height: s } = t; return "top" === e ? n += i : n -= "bottom" === e ? s + i : s / 2, n }(e, l, c); return "center" === l ? "left" === a ? f += c : "right" === a && (f -= c) : "left" === a ? f -= Math.max(h, d) + s : "right" === a && (f += Math.max(u, p) + s), { x: gx(f, 0, n.width - e.width), y: gx(g, 0, n.height - e.height) } } function hT(t, e, i) { const n = gS(i.padding); return "center" === e ? t.x + t.width / 2 : "right" === e ? t.x + t.width - n.right : t.x + n.left } function uT(t) { return nT([], sT(t)) } function dT(t, e) { const i = e && e.dataset && e.dataset.tooltip && e.dataset.tooltip.callbacks; return i ? t.override(i) : t } const pT = { beforeTitle: Sw, title(t) { if (t.length > 0) { const e = t[0], i = e.chart.data.labels, n = i ? i.length : 0; if (this && this.options && "dataset" === this.options.mode) return e.dataset.label || ""; if (e.label) return e.label; if (n > 0 && e.dataIndex < n) return i[e.dataIndex] } return "" }, afterTitle: Sw, beforeBody: Sw, beforeLabel: Sw, label(t) { if (this && this.options && "dataset" === this.options.mode) return t.label + ": " + t.formattedValue || t.formattedValue; let e = t.dataset.label || ""; e && (e += ": "); const i = t.formattedValue; return Cw(i) || (e += i), e }, labelColor(t) { const e = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex); return { borderColor: e.borderColor, backgroundColor: e.backgroundColor, borderWidth: e.borderWidth, borderDash: e.borderDash, borderDashOffset: e.borderDashOffset, borderRadius: 0 } }, labelTextColor() { return this.options.bodyColor }, labelPointStyle(t) { const e = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex); return { pointStyle: e.pointStyle, rotation: e.rotation } }, afterLabel: Sw, afterBody: Sw, beforeFooter: Sw, footer: Sw, afterFooter: Sw }; function fT(t, e, i, n) { const s = t[e].call(i, n); return void 0 === s ? pT[e].call(i, n) : s } class gT extends yC { static positioners = iT; constructor(t) { super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = t.chart, this.options = t.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0 } initialize(t) { this.options = t, this._cachedAnimations = void 0, this.$context = void 0 } _resolveAnimations() { const t = this._cachedAnimations; if (t) return t; const e = this.chart, i = this.options.setContext(this.getContext()), n = i.enabled && e.options.animation && i.animations, s = new dk(this.chart, n); return n._cacheable && (this._cachedAnimations = Object.freeze(s)), s } getContext() { return this.$context || (this.$context = vS(this.chart.getContext(), { tooltip: this, tooltipItems: this._tooltipItems, type: "tooltip" })) } getTitle(t, e) { const { callbacks: i } = e, n = fT(i, "beforeTitle", this, t), s = fT(i, "title", this, t), r = fT(i, "afterTitle", this, t); let o = []; return o = nT(o, sT(n)), o = nT(o, sT(s)), o = nT(o, sT(r)), o } getBeforeBody(t, e) { return uT(fT(e.callbacks, "beforeBody", this, t)) } getBody(t, e) { const { callbacks: i } = e, n = []; return Mw(t, t => { const e = { before: [], lines: [], after: [] }, s = dT(i, t); nT(e.before, sT(fT(s, "beforeLabel", this, t))), nT(e.lines, fT(s, "label", this, t)), nT(e.after, sT(fT(s, "afterLabel", this, t))), n.push(e) }), n } getAfterBody(t, e) { return uT(fT(e.callbacks, "afterBody", this, t)) } getFooter(t, e) { const { callbacks: i } = e, n = fT(i, "beforeFooter", this, t), s = fT(i, "footer", this, t), r = fT(i, "afterFooter", this, t); let o = []; return o = nT(o, sT(n)), o = nT(o, sT(s)), o = nT(o, sT(r)), o } _createItems(t) { const e = this._active, i = this.chart.data, n = [], s = [], r = []; let o, a, l = []; for (o = 0, a = e.length; o < a; ++o)l.push(rT(this.chart, e[o])); return t.filter && (l = l.filter((e, n, s) => t.filter(e, n, s, i))), t.itemSort && (l = l.sort((e, n) => t.itemSort(e, n, i))), Mw(l, e => { const i = dT(t.callbacks, e); n.push(fT(i, "labelColor", this, e)), s.push(fT(i, "labelPointStyle", this, e)), r.push(fT(i, "labelTextColor", this, e)) }), this.labelColors = n, this.labelPointStyles = s, this.labelTextColors = r, this.dataPoints = l, l } update(t, e) { const i = this.options.setContext(this.getContext()), n = this._active; let s, r = []; if (n.length) { const t = iT[i.position].call(this, n, this._eventPosition); r = this._createItems(i), this.title = this.getTitle(r, i), this.beforeBody = this.getBeforeBody(r, i), this.body = this.getBody(r, i), this.afterBody = this.getAfterBody(r, i), this.footer = this.getFooter(r, i); const e = this._size = oT(this, i), o = Object.assign({}, t, e), a = lT(this.chart, i, o), l = cT(i, o, a, this.chart); this.xAlign = a.xAlign, this.yAlign = a.yAlign, s = { opacity: 1, x: l.x, y: l.y, width: e.width, height: e.height, caretX: t.x, caretY: t.y } } else 0 !== this.opacity && (s = { opacity: 0 }); this._tooltipItems = r, this.$context = void 0, s && this._resolveAnimations().update(this, s), t && i.external && i.external.call(this, { chart: this.chart, tooltip: this, replay: e }) } drawCaret(t, e, i, n) { const s = this.getCaretPosition(t, i, n); e.lineTo(s.x1, s.y1), e.lineTo(s.x2, s.y2), e.lineTo(s.x3, s.y3) } getCaretPosition(t, e, i) { const { xAlign: n, yAlign: s } = this, { caretSize: r, cornerRadius: o } = i, { topLeft: a, topRight: l, bottomLeft: c, bottomRight: h } = fS(o), { x: u, y: d } = t, { width: p, height: f } = e; let g, m, _, v, y, b; return "center" === s ? (y = d + f / 2, "left" === n ? (g = u, m = g - r, v = y + r, b = y - r) : (g = u + p, m = g + r, v = y - r, b = y + r), _ = g) : (m = "left" === n ? u + Math.max(a, c) + r : "right" === n ? u + p - Math.max(l, h) - r : this.caretX, "top" === s ? (v = d, y = v - r, g = m - r, _ = m + r) : (v = d + f, y = v + r, g = m + r, _ = m - r), b = v), { x1: g, x2: m, x3: _, y1: v, y2: y, y3: b } } drawTitle(t, e, i) { const n = this.title, s = n.length; let r, o, a; if (s) { const l = XS(i.rtl, this.x, this.width); for (t.x = hT(this, i.titleAlign, i), e.textAlign = l.textAlign(i.titleAlign), e.textBaseline = "middle", r = mS(i.titleFont), o = i.titleSpacing, e.fillStyle = i.titleColor, e.font = r.string, a = 0; a < s; ++a)e.fillText(n[a], l.x(t.x), t.y + r.lineHeight / 2), t.y += r.lineHeight + o, a + 1 === s && (t.y += i.titleMarginBottom - o) } } _drawColorBox(t, e, i, n, s) { const r = this.labelColors[i], o = this.labelPointStyles[i], { boxHeight: a, boxWidth: l } = s, c = mS(s.bodyFont), h = hT(this, "left", s), u = n.x(h), d = e.y + (a < c.lineHeight ? (c.lineHeight - a) / 2 : 0); if (s.usePointStyle) { const e = { radius: Math.min(l, a) / 2, pointStyle: o.pointStyle, rotation: o.rotation, borderWidth: 1 }, i = n.leftForLtr(u, l) + l / 2, c = d + a / 2; t.strokeStyle = s.multiKeyBackground, t.fillStyle = s.multiKeyBackground, Xx(t, e, i, c), t.strokeStyle = r.borderColor, t.fillStyle = r.backgroundColor, Xx(t, e, i, c) } else { t.lineWidth = Tw(r.borderWidth) ? Math.max(...Object.values(r.borderWidth)) : r.borderWidth || 1, t.strokeStyle = r.borderColor, t.setLineDash(r.borderDash || []), t.lineDashOffset = r.borderDashOffset || 0; const e = n.leftForLtr(u, l), i = n.leftForLtr(n.xPlus(u, 1), l - 2), o = fS(r.borderRadius); Object.values(o).some(t => 0 !== t) ? (t.beginPath(), t.fillStyle = s.multiKeyBackground, lS(t, { x: e, y: d, w: l, h: a, radius: o }), t.fill(), t.stroke(), t.fillStyle = r.backgroundColor, t.beginPath(), lS(t, { x: i, y: d + 1, w: l - 2, h: a - 2, radius: o }), t.fill()) : (t.fillStyle = s.multiKeyBackground, t.fillRect(e, d, l, a), t.strokeRect(e, d, l, a), t.fillStyle = r.backgroundColor, t.fillRect(i, d + 1, l - 2, a - 2)) } t.fillStyle = this.labelTextColors[i] } drawBody(t, e, i) { const { body: n } = this, { bodySpacing: s, bodyAlign: r, displayColors: o, boxHeight: a, boxWidth: l, boxPadding: c } = i, h = mS(i.bodyFont); let u = h.lineHeight, d = 0; const p = XS(i.rtl, this.x, this.width), f = function (i) { e.fillText(i, p.x(t.x + d), t.y + u / 2), t.y += u + s }, g = p.textAlign(r); let m, _, v, y, b, w, x; for (e.textAlign = r, e.textBaseline = "middle", e.font = h.string, t.x = hT(this, g, i), e.fillStyle = i.bodyColor, Mw(this.beforeBody, f), d = o && "right" !== g ? "center" === r ? l / 2 + c : l + 2 + c : 0, y = 0, w = n.length; y < w; ++y) { for (m = n[y], _ = this.labelTextColors[y], e.fillStyle = _, Mw(m.before, f), v = m.lines, o && v.length && (this._drawColorBox(e, t, y, p, i), u = Math.max(h.lineHeight, a)), b = 0, x = v.length; b < x; ++b)f(v[b]), u = h.lineHeight; Mw(m.after, f) } d = 0, u = h.lineHeight, Mw(this.afterBody, f), t.y -= s } drawFooter(t, e, i) { const n = this.footer, s = n.length; let r, o; if (s) { const a = XS(i.rtl, this.x, this.width); for (t.x = hT(this, i.footerAlign, i), t.y += i.footerMarginTop, e.textAlign = a.textAlign(i.footerAlign), e.textBaseline = "middle", r = mS(i.footerFont), e.fillStyle = i.footerColor, e.font = r.string, o = 0; o < s; ++o)e.fillText(n[o], a.x(t.x), t.y + r.lineHeight / 2), t.y += r.lineHeight + i.footerSpacing } } drawBackground(t, e, i, n) { const { xAlign: s, yAlign: r } = this, { x: o, y: a } = t, { width: l, height: c } = i, { topLeft: h, topRight: u, bottomLeft: d, bottomRight: p } = fS(n.cornerRadius); e.fillStyle = n.backgroundColor, e.strokeStyle = n.borderColor, e.lineWidth = n.borderWidth, e.beginPath(), e.moveTo(o + h, a), "top" === r && this.drawCaret(t, e, i, n), e.lineTo(o + l - u, a), e.quadraticCurveTo(o + l, a, o + l, a + u), "center" === r && "right" === s && this.drawCaret(t, e, i, n), e.lineTo(o + l, a + c - p), e.quadraticCurveTo(o + l, a + c, o + l - p, a + c), "bottom" === r && this.drawCaret(t, e, i, n), e.lineTo(o + d, a + c), e.quadraticCurveTo(o, a + c, o, a + c - d), "center" === r && "left" === s && this.drawCaret(t, e, i, n), e.lineTo(o, a + h), e.quadraticCurveTo(o, a, o + h, a), e.closePath(), e.fill(), n.borderWidth > 0 && e.stroke() } _updateAnimationTarget(t) { const e = this.chart, i = this.$animations, n = i && i.x, s = i && i.y; if (n || s) { const i = iT[t.position].call(this, this._active, this._eventPosition); if (!i) return; const r = this._size = oT(this, t), o = Object.assign({}, i, this._size), a = lT(e, t, o), l = cT(t, o, a, e); n._to === l.x && s._to === l.y || (this.xAlign = a.xAlign, this.yAlign = a.yAlign, this.width = r.width, this.height = r.height, this.caretX = i.x, this.caretY = i.y, this._resolveAnimations().update(this, l)) } } _willRender() { return !!this.opacity } draw(t) { const e = this.options.setContext(this.getContext()); let i = this.opacity; if (!i) return; this._updateAnimationTarget(e); const n = { width: this.width, height: this.height }, s = { x: this.x, y: this.y }; i = Math.abs(i) < .001 ? 0 : i; const r = gS(e.padding); e.enabled && (this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length) && (t.save(), t.globalAlpha = i, this.drawBackground(s, t, n, e), JS(t, e.textDirection), s.y += r.top, this.drawTitle(s, t, e), this.drawBody(s, t, e), this.drawFooter(s, t, e), tk(t, e.textDirection), t.restore()) } getActiveElements() { return this._active || [] } setActiveElements(t, e) { const i = this._active, n = t.map(({ datasetIndex: t, index: e }) => { const i = this.chart.getDatasetMeta(t); if (!i) throw new Error("Cannot find a dataset at index " + t); return { datasetIndex: t, element: i.data[e], index: e } }), s = !Iw(i, n), r = this._positionChanged(n, e); (s || r) && (this._active = n, this._eventPosition = e, this._ignoreReplayEvents = !0, this.update(!0)) } handleEvent(t, e, i = !0) { if (e && this._ignoreReplayEvents) return !1; this._ignoreReplayEvents = !1; const n = this.options, s = this._active || [], r = this._getActiveElements(t, s, e, i), o = this._positionChanged(r, t), a = e || !Iw(r, s) || o; return a && (this._active = r, (n.enabled || n.external) && (this._eventPosition = { x: t.x, y: t.y }, this.update(!0, e))), a } _getActiveElements(t, e, i, n) { const s = this.options; if ("mouseout" === t.type) return []; if (!n) return e.filter(t => this.chart.data.datasets[t.datasetIndex] && void 0 !== this.chart.getDatasetMeta(t.datasetIndex).controller.getParsed(t.index)); const r = this.chart.getElementsAtEventForMode(t, s.mode, s, i); return s.reverse && r.reverse(), r } _positionChanged(t, e) { const { caretX: i, caretY: n, options: s } = this, r = iT[s.position].call(this, t, e); return !1 !== r && (i !== r.x || n !== r.y) } } var mT = Object.freeze({ __proto__: null, Colors: PE, Decimation: OE, Filler: GE, Legend: QE, SubTitle: eT, Title: JE, Tooltip: { id: "tooltip", _element: gT, positioners: iT, afterInit(t, e, i) { i && (t.tooltip = new gT({ chart: t, options: i })) }, beforeUpdate(t, e, i) { t.tooltip && t.tooltip.initialize(i) }, reset(t, e, i) { t.tooltip && t.tooltip.initialize(i) }, afterDraw(t) { const e = t.tooltip; if (e && e._willRender()) { const i = { tooltip: e }; if (!1 === t.notifyPlugins("beforeTooltipDraw", { ...i, cancelable: !0 })) return; e.draw(t.ctx), t.notifyPlugins("afterTooltipDraw", i) } }, afterEvent(t, e) { t.tooltip && t.tooltip.handleEvent(e.event, e.replay, e.inChartArea) && (e.changed = !0) }, defaults: { enabled: !0, external: null, position: "average", backgroundColor: "rgba(0,0,0,0.8)", titleColor: "#fff", titleFont: { weight: "bold" }, titleSpacing: 2, titleMarginBottom: 6, titleAlign: "left", bodyColor: "#fff", bodySpacing: 2, bodyFont: {}, bodyAlign: "left", footerColor: "#fff", footerSpacing: 2, footerMarginTop: 6, footerFont: { weight: "bold" }, footerAlign: "left", padding: 6, caretPadding: 2, caretSize: 5, cornerRadius: 6, boxHeight: (t, e) => e.bodyFont.size, boxWidth: (t, e) => e.bodyFont.size, multiKeyBackground: "#fff", displayColors: !0, boxPadding: 0, borderColor: "rgba(0,0,0,0)", borderWidth: 0, animation: { duration: 400, easing: "easeOutQuart" }, animations: { numbers: { type: "number", properties: ["x", "y", "width", "height", "caretX", "caretY"] }, opacity: { easing: "linear", duration: 200 } }, callbacks: pT }, defaultRoutes: { bodyFont: "font", footerFont: "font", titleFont: "font" }, descriptors: { _scriptable: t => "filter" !== t && "itemSort" !== t && "external" !== t, _indexable: !1, callbacks: { _scriptable: !1, _indexable: !1 }, animation: { _fallback: !1 }, animations: { _fallback: "animation" } }, additionalOptionScopes: ["interaction"] } }); function _T(t) { const e = this.getLabels(); return t >= 0 && t < e.length ? e[t] : t } function vT(t, e, { horizontal: i, minRotation: n }) { const s = ax(n), r = (i ? Math.sin(s) : Math.cos(s)) || .001; return Math.min(e / r, .75 * e * ("" + t).length) } class yT extends PC { constructor(t) { super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0 } parse(t, e) { return Cw(t) || ("number" == typeof t || t instanceof Number) && !isFinite(+t) ? null : +t } handleTickRangeOptions() { const { beginAtZero: t } = this.options, { minDefined: e, maxDefined: i } = this.getUserBounds(); let { min: n, max: s } = this; const r = t => n = e ? n : t, o = t => s = i ? s : t; if (t) { const t = ix(n), e = ix(s); t < 0 && e < 0 ? o(0) : t > 0 && e > 0 && r(0) } if (n === s) { let e = 0 === s ? 1 : Math.abs(.05 * s); o(s + e), t || r(n - e) } this.min = n, this.max = s } getTickLimit() { const t = this.options.ticks; let e, { maxTicksLimit: i, stepSize: n } = t; return n ? (e = Math.ceil(this.max / n) - Math.floor(this.min / n) + 1, e > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${n} would result generating up to ${e} ticks. Limiting to 1000.`), e = 1e3)) : (e = this.computeTickLimit(), i = i || 11), i && (e = Math.min(i, e)), e } computeTickLimit() { return Number.POSITIVE_INFINITY } buildTicks() { const t = this.options, e = t.ticks; let i = this.getTickLimit(); i = Math.max(2, i); const n = function (t, e) { const i = [], { bounds: n, step: s, min: r, max: o, precision: a, count: l, maxTicks: c, maxDigits: h, includeBounds: u } = t, d = s || 1, p = c - 1, { min: f, max: g } = e, m = !Cw(r), _ = !Cw(o), v = !Cw(l), y = (g - f) / (h + 1); let b, w, x, S, k = sx((g - f) / p / d) * d; if (k < 1e-14 && !m && !_) return [{ value: f }, { value: g }]; S = Math.ceil(g / k) - Math.floor(f / k), S > p && (k = sx(S * k / p / d) * d), Cw(a) || (b = Math.pow(10, a), k = Math.ceil(k * b) / b), "ticks" === n ? (w = Math.floor(f / k) * k, x = Math.ceil(g / k) * k) : (w = f, x = g), m && _ && s && function (t, e) { const i = Math.round(t); return i - e <= t && i + e >= t }((o - r) / s, k / 1e3) ? (S = Math.round(Math.min((o - r) / k, c)), k = (o - r) / S, w = r, x = o) : v ? (w = m ? r : w, x = _ ? o : x, S = l - 1, k = (x - w) / S) : (S = (x - w) / k, S = nx(S, Math.round(S), k / 1e3) ? Math.round(S) : Math.ceil(S)); const C = Math.max(cx(k), cx(w)); b = Math.pow(10, Cw(a) ? C : a), w = Math.round(w * b) / b, x = Math.round(x * b) / b; let E = 0; for (m && (u && w !== r ? (i.push({ value: r }), w < r && E++, nx(Math.round((w + E * k) * b) / b, r, vT(r, y, t)) && E++) : w < r && E++); E < S; ++E) { const t = Math.round((w + E * k) * b) / b; if (_ && t > o) break; i.push({ value: t }) } return _ && u && x !== o ? i.length && nx(i[i.length - 1].value, o, vT(o, y, t)) ? i[i.length - 1].value = o : i.push({ value: o }) : _ && x !== o || i.push({ value: x }), i }({ maxTicks: i, bounds: t.bounds, min: t.min, max: t.max, precision: e.precision, step: e.stepSize, count: e.count, maxDigits: this._maxDigits(), horizontal: this.isHorizontal(), minRotation: e.minRotation || 0, includeBounds: !1 !== e.includeBounds }, this._range || this); return "ticks" === t.bounds && ox(n, this, "value"), t.reverse ? (n.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), n } configure() { const t = this.ticks; let e = this.min, i = this.max; if (super.configure(), this.options.offset && t.length) { const n = (i - e) / Math.max(t.length - 1, 1) / 2; e -= n, i += n } this._startValue = e, this._endValue = i, this._valueRange = i - e } getLabelForValue(t) { return Vx(t, this.chart.options.locale, this.options.ticks.format) } } const bT = t => Math.floor(ex(t)), wT = (t, e) => Math.pow(10, bT(t) + e); function xT(t) { return 1 == t / Math.pow(10, bT(t)) } function ST(t, e, i) { const n = Math.pow(10, i), s = Math.floor(t / n); return Math.ceil(e / n) - s } function kT(t) { const e = t.ticks; if (e.display && t.display) { const t = gS(e.backdropPadding); return Aw(e.font && e.font.size, Gx.font.size) + t.height } return 0 } function CT(t, e, i, n, s) { return t === n || t === s ? { start: e - i / 2, end: e + i / 2 } : t < n || t > s ? { start: e - i, end: e } : { start: e, end: e + i } } function ET(t, e, i, n, s) { const r = Math.abs(Math.sin(i)), o = Math.abs(Math.cos(i)); let a = 0, l = 0; n.start < e.l ? (a = (e.l - n.start) / r, t.l = Math.min(t.l, e.l - a)) : n.end > e.r && (a = (n.end - e.r) / r, t.r = Math.max(t.r, e.r + a)), s.start < e.t ? (l = (e.t - s.start) / o, t.t = Math.min(t.t, e.t - l)) : s.end > e.b && (l = (s.end - e.b) / o, t.b = Math.max(t.b, e.b + l)) } function TT(t, e, i) { const n = t.drawingArea, { extra: s, additionalAngle: r, padding: o, size: a } = i, l = t.getPointPosition(e, n + s + o, r), c = Math.round(lx(px(l.angle + Xw))), h = function (t, e, i) { return 90 === i || 270 === i ? t -= e / 2 : (i > 270 || i < 90) && (t -= e), t }(l.y, a.h, c), u = function (t) { return 0 === t || 180 === t ? "center" : t < 180 ? "left" : "right" }(c), d = (p = l.x, f = a.w, "right" === (g = u) ? p -= f : "center" === g && (p -= f / 2), p); var p, f, g; return { visible: !0, x: l.x, y: h, textAlign: u, left: d, top: h, right: d + a.w, bottom: h + a.h } } function PT(t, e) { if (!e) return !0; const { left: i, top: n, right: s, bottom: r } = t; return !(tS({ x: i, y: n }, e) || tS({ x: i, y: r }, e) || tS({ x: s, y: n }, e) || tS({ x: s, y: r }, e)) } function DT(t, e, i) { const { left: n, top: s, right: r, bottom: o } = i, { backdropColor: a } = e; if (!Cw(a)) { const i = fS(e.borderRadius), l = gS(e.backdropPadding); t.fillStyle = a; const c = n - l.left, h = s - l.top, u = r - n + l.width, d = o - s + l.height; Object.values(i).some(t => 0 !== t) ? (t.beginPath(), lS(t, { x: c, y: h, w: u, h: d, radius: i }), t.fill()) : t.fillRect(c, h, u, d) } } function AT(t, e, i, n) { const { ctx: s } = t; if (i) s.arc(t.xCenter, t.yCenter, e, 0, Zw); else { let i = t.getPointPosition(0, e); s.moveTo(i.x, i.y); for (let r = 1; r < n; r++)i = t.getPointPosition(r, e), s.lineTo(i.x, i.y) } } const OT = { millisecond: { common: !0, size: 1, steps: 1e3 }, second: { common: !0, size: 1e3, steps: 60 }, minute: { common: !0, size: 6e4, steps: 60 }, hour: { common: !0, size: 36e5, steps: 24 }, day: { common: !0, size: 864e5, steps: 30 }, week: { common: !1, size: 6048e5, steps: 4 }, month: { common: !0, size: 2628e6, steps: 12 }, quarter: { common: !1, size: 7884e6, steps: 4 }, year: { common: !0, size: 3154e7 } }, RT = Object.keys(OT); function MT(t, e) { return t - e } function IT(t, e) { if (Cw(e)) return null; const i = t._adapter, { parser: n, round: s, isoWeekday: r } = t._parseOpts; let o = e; return "function" == typeof n && (o = n(o)), Pw(o) || (o = "string" == typeof n ? i.parse(o, n) : i.parse(o)), null === o ? null : (s && (o = "week" !== s || !rx(r) && !0 !== r ? i.startOf(o, s) : i.startOf(o, "isoWeek", r)), +o) } function LT(t, e, i, n) { const s = RT.length; for (let r = RT.indexOf(t); r < s - 1; ++r) { const t = OT[RT[r]], s = t.steps ? t.steps : Number.MAX_SAFE_INTEGER; if (t.common && Math.ceil((i - e) / (s * t.size)) <= n) return RT[r] } return RT[s - 1] } function FT(t, e, i) { if (i) { if (i.length) { const { lo: n, hi: s } = _x(i, e); t[i[n] >= e ? i[n] : i[s]] = !0 } } else t[e] = !0 } function NT(t, e, i) { const n = [], s = {}, r = e.length; let o, a; for (o = 0; o < r; ++o)a = e[o], s[a] = o, n.push({ value: a, major: !1 }); return 0 !== r && i ? function (t, e, i, n) { const s = t._adapter, r = +s.startOf(e[0].value, n), o = e[e.length - 1].value; let a, l; for (a = r; a <= o; a = +s.add(a, 1, n))l = i[a], l >= 0 && (e[l].major = !0); return e }(t, n, s, i) : n } class jT extends PC { static id = "time"; static defaults = { bounds: "data", adapters: {}, time: { parser: !1, unit: !1, round: !1, isoWeekday: !1, minUnit: "millisecond", displayFormats: {} }, ticks: { source: "auto", callback: !1, major: { enabled: !1 } } }; constructor(t) { super(t), this._cache = { data: [], labels: [], all: [] }, this._unit = "day", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0 } init(t, e = {}) { const i = t.time || (t.time = {}), n = this._adapter = new jk(t.adapters.date); n.init(e), Vw(i.displayFormats, n.formats()), this._parseOpts = { parser: i.parser, round: i.round, isoWeekday: i.isoWeekday }, super.init(t), this._normalized = e.normalized } parse(t, e) { return void 0 === t ? null : IT(this, t) } beforeLayout() { super.beforeLayout(), this._cache = { data: [], labels: [], all: [] } } determineDataLimits() { const t = this.options, e = this._adapter, i = t.time.unit || "day"; let { min: n, max: s, minDefined: r, maxDefined: o } = this.getUserBounds(); function a(t) { r || isNaN(t.min) || (n = Math.min(n, t.min)), o || isNaN(t.max) || (s = Math.max(s, t.max)) } r && o || (a(this._getLabelBounds()), "ticks" === t.bounds && "labels" === t.ticks.source || a(this.getMinMax(!1))), n = Pw(n) && !isNaN(n) ? n : +e.startOf(Date.now(), i), s = Pw(s) && !isNaN(s) ? s : +e.endOf(Date.now(), i) + 1, this.min = Math.min(n, s - 1), this.max = Math.max(n + 1, s) } _getLabelBounds() { const t = this.getLabelTimestamps(); let e = Number.POSITIVE_INFINITY, i = Number.NEGATIVE_INFINITY; return t.length && (e = t[0], i = t[t.length - 1]), { min: e, max: i } } buildTicks() { const t = this.options, e = t.time, i = t.ticks, n = "labels" === i.source ? this.getLabelTimestamps() : this._generate(); "ticks" === t.bounds && n.length && (this.min = this._userMin || n[0], this.max = this._userMax || n[n.length - 1]); const s = this.min, r = function (t, e, i) { let n = 0, s = t.length; for (; n < s && t[n] < e;)n++; for (; s > n && t[s - 1] > i;)s--; return n > 0 || s < t.length ? t.slice(n, s) : t }(n, s, this.max); return this._unit = e.unit || (i.autoSkip ? LT(e.minUnit, this.min, this.max, this._getLabelCapacity(s)) : function (t, e, i, n, s) { for (let r = RT.length - 1; r >= RT.indexOf(i); r--) { const i = RT[r]; if (OT[i].common && t._adapter.diff(s, n, i) >= e - 1) return i } return RT[i ? RT.indexOf(i) : 0] }(this, r.length, e.minUnit, this.min, this.max)), this._majorUnit = i.major.enabled && "year" !== this._unit ? function (t) { for (let e = RT.indexOf(t) + 1, i = RT.length; e < i; ++e)if (OT[RT[e]].common) return RT[e] }(this._unit) : void 0, this.initOffsets(n), t.reverse && r.reverse(), NT(this, r, this._majorUnit) } afterAutoSkip() { this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map(t => +t.value)) } initOffsets(t = []) { let e, i, n = 0, s = 0; this.options.offset && t.length && (e = this.getDecimalForValue(t[0]), n = 1 === t.length ? 1 - e : (this.getDecimalForValue(t[1]) - e) / 2, i = this.getDecimalForValue(t[t.length - 1]), s = 1 === t.length ? i : (i - this.getDecimalForValue(t[t.length - 2])) / 2); const r = t.length < 3 ? .5 : .25; n = gx(n, 0, r), s = gx(s, 0, r), this._offsets = { start: n, end: s, factor: 1 / (n + 1 + s) } } _generate() { const t = this._adapter, e = this.min, i = this.max, n = this.options, s = n.time, r = s.unit || LT(s.minUnit, e, i, this._getLabelCapacity(e)), o = Aw(n.ticks.stepSize, 1), a = "week" === r && s.isoWeekday, l = rx(a) || !0 === a, c = {}; let h, u, d = e; if (l && (d = +t.startOf(d, "isoWeek", a)), d = +t.startOf(d, l ? "day" : r), t.diff(i, e, r) > 1e5 * o) throw new Error(e + " and " + i + " are too far apart with stepSize of " + o + " " + r); const p = "data" === n.ticks.source && this.getDataTimestamps(); for (h = d, u = 0; h < i; h = +t.add(h, o, r), u++)FT(c, h, p); return h !== i && "ticks" !== n.bounds && 1 !== u || FT(c, h, p), Object.keys(c).sort(MT).map(t => +t) } getLabelForValue(t) { const e = this.options.time; return this._adapter.format(t, e.tooltipFormat ? e.tooltipFormat : e.displayFormats.datetime) } format(t, e) { return this._adapter.format(t, e || this.options.time.displayFormats[this._unit]) } _tickFormatFunction(t, e, i, n) { const s = this.options, r = s.ticks.callback; if (r) return Rw(r, [t, e, i], this); const o = s.time.displayFormats, a = this._unit, l = this._majorUnit, c = l && o[l], h = i[e]; return this._adapter.format(t, n || (l && c && h && h.major ? c : a && o[a])) } generateTickLabels(t) { let e, i, n; for (e = 0, i = t.length; e < i; ++e)n = t[e], n.label = this._tickFormatFunction(n.value, e, t) } getDecimalForValue(t) { return null === t ? NaN : (t - this.min) / (this.max - this.min) } getPixelForValue(t) { const e = this._offsets, i = this.getDecimalForValue(t); return this.getPixelForDecimal((e.start + i) * e.factor) } getValueForPixel(t) { const e = this._offsets, i = this.getDecimalForPixel(t) / e.factor - e.end; return this.min + i * (this.max - this.min) } _getLabelSize(t) { const e = this.options.ticks, i = this.ctx.measureText(t).width, n = ax(this.isHorizontal() ? e.maxRotation : e.minRotation), s = Math.cos(n), r = Math.sin(n), o = this._resolveTickFontOptions(0).size; return { w: i * s + o * r, h: i * r + o * s } } _getLabelCapacity(t) { const e = this.options.time, i = e.displayFormats, n = i[e.unit] || i.millisecond, s = this._tickFormatFunction(t, 0, NT(this, [t], this._majorUnit), n), r = this._getLabelSize(s), o = Math.floor(this.isHorizontal() ? this.width / r.w : this.height / r.h) - 1; return o > 0 ? o : 1 } getDataTimestamps() { let t, e, i = this._cache.data || []; if (i.length) return i; const n = this.getMatchingVisibleMetas(); if (this._normalized && n.length) return this._cache.data = n[0].controller.getAllParsedValues(this); for (t = 0, e = n.length; t < e; ++t)i = i.concat(n[t].controller.getAllParsedValues(this)); return this._cache.data = this.normalize(i) } getLabelTimestamps() { const t = this._cache.labels || []; let e, i; if (t.length) return t; const n = this.getLabels(); for (e = 0, i = n.length; e < i; ++e)t.push(IT(this, n[e])); return this._cache.labels = this._normalized ? t : this.normalize(t) } normalize(t) { return xx(t.sort(MT)) } } function VT(t, e, i) { let n, s, r, o, a = 0, l = t.length - 1; i ? (e >= t[a].pos && e <= t[l].pos && ({ lo: a, hi: l } = vx(t, "pos", e)), ({ pos: n, time: r } = t[a]), ({ pos: s, time: o } = t[l])) : (e >= t[a].time && e <= t[l].time && ({ lo: a, hi: l } = vx(t, "time", e)), ({ time: n, pos: r } = t[a]), ({ time: s, pos: o } = t[l])); const c = s - n; return c ? r + (o - r) * (e - n) / c : r } sE.register(Lk, xE, mT, Object.freeze({ __proto__: null, CategoryScale: class extends PC { static id = "category"; static defaults = { ticks: { callback: _T } }; constructor(t) { super(t), this._startValue = void 0, this._valueRange = 0, this._addedLabels = [] } init(t) { const e = this._addedLabels; if (e.length) { const t = this.getLabels(); for (const { index: i, label: n } of e) t[i] === n && t.splice(i, 1); this._addedLabels = [] } super.init(t) } parse(t, e) { if (Cw(t)) return null; const i = this.getLabels(); return ((t, e) => null === t ? null : gx(Math.round(t), 0, e))(e = isFinite(e) && i[e] === t ? e : function (t, e, i, n) { const s = t.indexOf(e); return -1 === s ? ((t, e, i, n) => ("string" == typeof e ? (i = t.push(e) - 1, n.unshift({ index: i, label: e })) : isNaN(e) && (i = null), i))(t, e, i, n) : s !== t.lastIndexOf(e) ? i : s }(i, t, Aw(e, t), this._addedLabels), i.length - 1) } determineDataLimits() { const { minDefined: t, maxDefined: e } = this.getUserBounds(); let { min: i, max: n } = this.getMinMax(!0); "ticks" === this.options.bounds && (t || (i = 0), e || (n = this.getLabels().length - 1)), this.min = i, this.max = n } buildTicks() { const t = this.min, e = this.max, i = this.options.offset, n = []; let s = this.getLabels(); s = 0 === t && e === s.length - 1 ? s : s.slice(t, e + 1), this._valueRange = Math.max(s.length - (i ? 0 : 1), 1), this._startValue = this.min - (i ? .5 : 0); for (let r = t; r <= e; r++)n.push({ value: r }); return n } getLabelForValue(t) { return _T.call(this, t) } configure() { super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels) } getPixelForValue(t) { return "number" != typeof t && (t = this.parse(t)), null === t ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange) } getPixelForTick(t) { const e = this.ticks; return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value) } getValueForPixel(t) { return Math.round(this._startValue + this.getDecimalForPixel(t) * this._valueRange) } getBasePixel() { return this.bottom } }, LinearScale: class extends yT { static id = "linear"; static defaults = { ticks: { callback: Hx.formatters.numeric } }; determineDataLimits() { const { min: t, max: e } = this.getMinMax(!0); this.min = Pw(t) ? t : 0, this.max = Pw(e) ? e : 1, this.handleTickRangeOptions() } computeTickLimit() { const t = this.isHorizontal(), e = t ? this.width : this.height, i = ax(this.options.ticks.minRotation), n = (t ? Math.sin(i) : Math.cos(i)) || .001, s = this._resolveTickFontOptions(0); return Math.ceil(e / Math.min(40, s.lineHeight / n)) } getPixelForValue(t) { return null === t ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange) } getValueForPixel(t) { return this._startValue + this.getDecimalForPixel(t) * this._valueRange } }, LogarithmicScale: class extends PC { static id = "logarithmic"; static defaults = { ticks: { callback: Hx.formatters.logarithmic, major: { enabled: !0 } } }; constructor(t) { super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._valueRange = 0 } parse(t, e) { const i = yT.prototype.parse.apply(this, [t, e]); if (0 !== i) return Pw(i) && i > 0 ? i : null; this._zero = !0 } determineDataLimits() { const { min: t, max: e } = this.getMinMax(!0); this.min = Pw(t) ? Math.max(0, t) : null, this.max = Pw(e) ? Math.max(0, e) : null, this.options.beginAtZero && (this._zero = !0), this._zero && this.min !== this._suggestedMin && !Pw(this._userMin) && (this.min = t === wT(this.min, 0) ? wT(this.min, -1) : wT(this.min, 0)), this.handleTickRangeOptions() } handleTickRangeOptions() { const { minDefined: t, maxDefined: e } = this.getUserBounds(); let i = this.min, n = this.max; const s = e => i = t ? i : e, r = t => n = e ? n : t; i === n && (i <= 0 ? (s(1), r(10)) : (s(wT(i, -1)), r(wT(n, 1)))), i <= 0 && s(wT(n, -1)), n <= 0 && r(wT(i, 1)), this.min = i, this.max = n } buildTicks() { const t = this.options, e = function (t, { min: e, max: i }) { e = Dw(t.min, e); const n = [], s = bT(e); let r = function (t, e) { let i = bT(e - t); for (; ST(t, e, i) > 10;)i++; for (; ST(t, e, i) < 10;)i--; return Math.min(i, bT(t)) }(e, i), o = r < 0 ? Math.pow(10, Math.abs(r)) : 1; const a = Math.pow(10, r), l = s > r ? Math.pow(10, s) : 0, c = Math.round((e - l) * o) / o, h = Math.floor((e - l) / a / 10) * a * 10; let u = Math.floor((c - h) / Math.pow(10, r)), d = Dw(t.min, Math.round((l + h + u * Math.pow(10, r)) * o) / o); for (; d < i;)n.push({ value: d, major: xT(d), significand: u }), u >= 10 ? u = u < 15 ? 15 : 20 : u++, u >= 20 && (r++, u = 2, o = r >= 0 ? 1 : o), d = Math.round((l + h + u * Math.pow(10, r)) * o) / o; const p = Dw(t.max, d); return n.push({ value: p, major: xT(p), significand: u }), n }({ min: this._userMin, max: this._userMax }, this); return "ticks" === t.bounds && ox(e, this, "value"), t.reverse ? (e.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), e } getLabelForValue(t) { return void 0 === t ? "0" : Vx(t, this.chart.options.locale, this.options.ticks.format) } configure() { const t = this.min; super.configure(), this._startValue = ex(t), this._valueRange = ex(this.max) - ex(t) } getPixelForValue(t) { return void 0 !== t && 0 !== t || (t = this.min), null === t || isNaN(t) ? NaN : this.getPixelForDecimal(t === this.min ? 0 : (ex(t) - this._startValue) / this._valueRange) } getValueForPixel(t) { const e = this.getDecimalForPixel(t); return Math.pow(10, this._startValue + e * this._valueRange) } }, RadialLinearScale: class extends yT { static id = "radialLinear"; static defaults = { display: !0, animate: !0, position: "chartArea", angleLines: { display: !0, lineWidth: 1, borderDash: [], borderDashOffset: 0 }, grid: { circular: !1 }, startAngle: 0, ticks: { showLabelBackdrop: !0, callback: Hx.formatters.numeric }, pointLabels: { backdropColor: void 0, backdropPadding: 2, display: !0, font: { size: 10 }, callback: t => t, padding: 5, centerPointLabels: !1 } }; static defaultRoutes = { "angleLines.color": "borderColor", "pointLabels.color": "color", "ticks.color": "color" }; static descriptors = { angleLines: { _fallback: "grid" } }; constructor(t) { super(t), this.xCenter = void 0, this.yCenter = void 0, this.drawingArea = void 0, this._pointLabels = [], this._pointLabelItems = [] } setDimensions() { const t = this._padding = gS(kT(this.options) / 2), e = this.width = this.maxWidth - t.width, i = this.height = this.maxHeight - t.height; this.xCenter = Math.floor(this.left + e / 2 + t.left), this.yCenter = Math.floor(this.top + i / 2 + t.top), this.drawingArea = Math.floor(Math.min(e, i) / 2) } determineDataLimits() { const { min: t, max: e } = this.getMinMax(!1); this.min = Pw(t) && !isNaN(t) ? t : 0, this.max = Pw(e) && !isNaN(e) ? e : 0, this.handleTickRangeOptions() } computeTickLimit() { return Math.ceil(this.drawingArea / kT(this.options)) } generateTickLabels(t) { yT.prototype.generateTickLabels.call(this, t), this._pointLabels = this.getLabels().map((t, e) => { const i = Rw(this.options.pointLabels.callback, [t, e], this); return i || 0 === i ? i : "" }).filter((t, e) => this.chart.getDataVisibility(e)) } fit() { const t = this.options; t.display && t.pointLabels.display ? function (t) { const e = { l: t.left + t._padding.left, r: t.right - t._padding.right, t: t.top + t._padding.top, b: t.bottom - t._padding.bottom }, i = Object.assign({}, e), n = [], s = [], r = t._pointLabels.length, o = t.options.pointLabels, a = o.centerPointLabels ? Gw / r : 0; for (let u = 0; u < r; u++) { const r = o.setContext(t.getPointLabelContext(u)); s[u] = r.padding; const d = t.getPointPosition(u, t.drawingArea + s[u], a), p = mS(r.font), f = (l = t.ctx, c = p, h = Ew(h = t._pointLabels[u]) ? h : [h], { w: Kx(l, c.string, h), h: h.length * c.lineHeight }); n[u] = f; const g = px(t.getIndexAngle(u) + a), m = Math.round(lx(g)); ET(i, e, g, CT(m, d.x, f.w, 0, 180), CT(m, d.y, f.h, 90, 270)) } var l, c, h; t.setCenterPoint(e.l - i.l, i.r - e.r, e.t - i.t, i.b - e.b), t._pointLabelItems = function (t, e, i) { const n = [], s = t._pointLabels.length, r = t.options, { centerPointLabels: o, display: a } = r.pointLabels, l = { extra: kT(r) / 2, additionalAngle: o ? Gw / s : 0 }; let c; for (let h = 0; h < s; h++) { l.padding = i[h], l.size = e[h]; const s = TT(t, h, l); n.push(s), "auto" === a && (s.visible = PT(s, c), s.visible && (c = s)) } return n }(t, n, s) }(this) : this.setCenterPoint(0, 0, 0, 0) } setCenterPoint(t, e, i, n) { this.xCenter += Math.floor((t - e) / 2), this.yCenter += Math.floor((i - n) / 2), this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(t, e, i, n)) } getIndexAngle(t) { return px(t * (Zw / (this._pointLabels.length || 1)) + ax(this.options.startAngle || 0)) } getDistanceFromCenterForValue(t) { if (Cw(t)) return NaN; const e = this.drawingArea / (this.max - this.min); return this.options.reverse ? (this.max - t) * e : (t - this.min) * e } getValueForDistanceFromCenter(t) { if (Cw(t)) return NaN; const e = t / (this.drawingArea / (this.max - this.min)); return this.options.reverse ? this.max - e : this.min + e } getPointLabelContext(t) { const e = this._pointLabels || []; if (t >= 0 && t < e.length) { const i = e[t]; return function (t, e, i) { return vS(t, { label: i, index: e, type: "pointLabel" }) }(this.getContext(), t, i) } } getPointPosition(t, e, i = 0) { const n = this.getIndexAngle(t) - Xw + i; return { x: Math.cos(n) * e + this.xCenter, y: Math.sin(n) * e + this.yCenter, angle: n } } getPointPositionForValue(t, e) { return this.getPointPosition(t, this.getDistanceFromCenterForValue(e)) } getBasePosition(t) { return this.getPointPositionForValue(t || 0, this.getBaseValue()) } getPointLabelPosition(t) { const { left: e, top: i, right: n, bottom: s } = this._pointLabelItems[t]; return { left: e, top: i, right: n, bottom: s } } drawBackground() { const { backgroundColor: t, grid: { circular: e } } = this.options; if (t) { const i = this.ctx; i.save(), i.beginPath(), AT(this, this.getDistanceFromCenterForValue(this._endValue), e, this._pointLabels.length), i.closePath(), i.fillStyle = t, i.fill(), i.restore() } } drawGrid() { const t = this.ctx, e = this.options, { angleLines: i, grid: n, border: s } = e, r = this._pointLabels.length; let o, a, l; if (e.pointLabels.display && function (t, e) { const { ctx: i, options: { pointLabels: n } } = t; for (let s = e - 1; s >= 0; s--) { const e = t._pointLabelItems[s]; if (!e.visible) continue; const r = n.setContext(t.getPointLabelContext(s)); DT(i, r, e); const o = mS(r.font), { x: a, y: l, textAlign: c } = e; aS(i, t._pointLabels[s], a, l + o.lineHeight / 2, o, { color: r.color, textAlign: c, textBaseline: "middle" }) } }(this, r), n.display && this.ticks.forEach((t, e) => { if (0 !== e) { a = this.getDistanceFromCenterForValue(t.value); const i = this.getContext(e), o = n.setContext(i), l = s.setContext(i); !function (t, e, i, n, s) { const r = t.ctx, o = e.circular, { color: a, lineWidth: l } = e; !o && !n || !a || !l || i < 0 || (r.save(), r.strokeStyle = a, r.lineWidth = l, r.setLineDash(s.dash), r.lineDashOffset = s.dashOffset, r.beginPath(), AT(t, i, o, n), r.closePath(), r.stroke(), r.restore()) }(this, o, a, r, l) } }), i.display) { for (t.save(), o = r - 1; o >= 0; o--) { const n = i.setContext(this.getPointLabelContext(o)), { color: s, lineWidth: r } = n; r && s && (t.lineWidth = r, t.strokeStyle = s, t.setLineDash(n.borderDash), t.lineDashOffset = n.borderDashOffset, a = this.getDistanceFromCenterForValue(e.ticks.reverse ? this.min : this.max), l = this.getPointPosition(o, a), t.beginPath(), t.moveTo(this.xCenter, this.yCenter), t.lineTo(l.x, l.y), t.stroke()) } t.restore() } } drawBorder() { } drawLabels() { const t = this.ctx, e = this.options, i = e.ticks; if (!i.display) return; const n = this.getIndexAngle(0); let s, r; t.save(), t.translate(this.xCenter, this.yCenter), t.rotate(n), t.textAlign = "center", t.textBaseline = "middle", this.ticks.forEach((n, o) => { if (0 === o && !e.reverse) return; const a = i.setContext(this.getContext(o)), l = mS(a.font); if (s = this.getDistanceFromCenterForValue(this.ticks[o].value), a.showLabelBackdrop) { t.font = l.string, r = t.measureText(n.label).width, t.fillStyle = a.backdropColor; const e = gS(a.backdropPadding); t.fillRect(-r / 2 - e.left, -s - l.size / 2 - e.top, r + e.width, l.size + e.height) } aS(t, n.label, 0, -s, l, { color: a.color, strokeColor: a.textStrokeColor, strokeWidth: a.textStrokeWidth }) }), t.restore() } drawTitle() { } }, TimeScale: jT, TimeSeriesScale: class extends jT { static id = "timeseries"; static defaults = jT.defaults; constructor(t) { super(t), this._table = [], this._minPos = void 0, this._tableRange = void 0 } initOffsets() { const t = this._getTimestampsForTable(), e = this._table = this.buildLookupTable(t); this._minPos = VT(e, this.min), this._tableRange = VT(e, this.max) - this._minPos, super.initOffsets(t) } buildLookupTable(t) { const { min: e, max: i } = this, n = [], s = []; let r, o, a, l, c; for (r = 0, o = t.length; r < o; ++r)l = t[r], l >= e && l <= i && n.push(l); if (n.length < 2) return [{ time: e, pos: 0 }, { time: i, pos: 1 }]; for (r = 0, o = n.length; r < o; ++r)c = n[r + 1], a = n[r - 1], l = n[r], Math.round((c + a) / 2) !== l && s.push({ time: l, pos: r / (o - 1) }); return s } _generate() { const t = this.min, e = this.max; let i = super.getDataTimestamps(); return i.includes(t) && i.length || i.splice(0, 0, t), i.includes(e) && 1 !== i.length || i.push(e), i.sort((t, e) => t - e) } _getTimestampsForTable() { let t = this._cache.all || []; if (t.length) return t; const e = this.getDataTimestamps(), i = this.getLabelTimestamps(); return t = e.length && i.length ? this.normalize(e.concat(i)) : e.length ? e : i, t = this._cache.all = t, t } getDecimalForValue(t) { return (VT(this._table, t) - this._minPos) / this._tableRange } getValueForPixel(t) { const e = this._offsets, i = this.getDecimalForPixel(t) / e.factor - e.end; return VT(this._table, i * this._tableRange + this._minPos, !0) } } })); let BT = (() => { class t { constructor(t) { this.http = t } ngOnInit() { this.http.get("http://devazure.eastus.cloudapp.azure.com:8085/api/tasks/statistics").subscribe(t => { this.doneTasks = t.done, this.delayedTasks = t.delayed, this.allTasks = t.all, this.createPieChart() }) } createPieChart() { this.pieChart = new sE("canvas", { type: "pie", data: { labels: ["Done Tasks", "Delayed Tasks", "Remaining Tasks"], datasets: [{ data: [this.doneTasks, this.delayedTasks, this.allTasks - this.doneTasks - this.delayedTasks], backgroundColor: ["rgba(75, 192, 192, 0.5)", "rgba(255, 99, 132, 0.5)", "rgba(255, 255, 255, 0)"], borderWidth: 1 }] }, options: { responsive: !0, plugins: { legend: { position: "bottom" } } } }) } } return t.\u0275fac = function (e) { return new (e || t)(Ur(bm)) }, t.\u0275cmp = $t({ type: t, selectors: [["app-dashboard-admin"]], decls: 6, vars: 0, consts: [[1, "header-title"], [1, "container", 2, "width", "800px", "height", "800px"], ["id", "canvas", "width", "800", "height", "800"]], template: function (t, e) { 1 & t && (Gr(0, "div", 0), Gr(1, "h1"), xo(2, "Statistic"), Zr(), Zr(), Kr(3, "br"), Gr(4, "div", 1), Kr(5, "canvas", 2), Zr()) }, styles: [""] }), t })(); function HT(t, e) { 1 & t && (Gr(0, "div"), xo(1, "Please enter your task Name*"), Zr()) } function zT(t, e) { 1 & t && (Gr(0, "div"), xo(1, "The title of task must be at least 3 characters long"), Zr()) } function $T(t, e) { 1 & t && (Gr(0, "div"), xo(1, "The title of task cannot exceed 30 characters*"), Zr()) } function UT(t, e) { if (1 & t && (Gr(0, "div", 74), zr(1, HT, 2, 0, "div", 75), zr(2, zT, 2, 0, "div", 75), zr(3, $T, 2, 0, "div", 75), Zr()), 2 & t) { const t = so(3); vs(1), Wr("ngIf", t.formService.nameT.errors.required), vs(1), Wr("ngIf", t.formService.nameT.errors.minlength), vs(1), Wr("ngIf", t.formService.nameT.errors.maxlength) } } function WT(t, e) { 1 & t && (Gr(0, "div"), xo(1, "The task Name must be lettres*"), Zr()) } function qT(t, e) { if (1 & t && (Gr(0, "div", 74), zr(1, WT, 2, 0, "div", 75), Zr()), 2 & t) { const t = so(3); vs(1), Wr("ngIf", t.formService.nameT.hasError("pattern")) } } function GT(t, e) { 1 & t && (Gr(0, "div"), xo(1, "Please enter your task Description*"), Zr()) } function ZT(t, e) { if (1 & t && (Gr(0, "div", 74), zr(1, GT, 2, 0, "div", 75), Zr()), 2 & t) { const t = so(3); vs(1), Wr("ngIf", t.formService.descriptionT.errors.required) } } function KT(t, e) { 1 & t && (Gr(0, "div"), xo(1, "Please enter your task Start Date*"), Zr()) } function YT(t, e) { if (1 & t && (Gr(0, "div", 74), zr(1, KT, 2, 0, "div", 75), Zr()), 2 & t) { const t = so(3); vs(1), Wr("ngIf", t.formService.dateStartT.errors.required) } } function QT(t, e) { 1 & t && (Gr(0, "div"), xo(1, "Please enter your task Due Date*"), Zr()) } function XT(t, e) { if (1 & t && (Gr(0, "div", 74), zr(1, QT, 2, 0, "div", 75), Zr()), 2 & t) { const t = so(3); vs(1), Wr("ngIf", t.formService.dueDateT.errors.required) } } function JT(t, e) { if (1 & t && (Gr(0, "option", 76), xo(1), Zr()), 2 & t) { const t = e.$implicit; Wr("ngValue", t.id), vs(1), So(t.name) } } function tP(t, e) { 1 & t && (Gr(0, "div"), xo(1, "Please enter your task Status*"), Zr()) } function eP(t, e) { if (1 & t && (Gr(0, "div", 74), zr(1, tP, 2, 0, "div", 75), Zr()), 2 & t) { const t = so(3); vs(1), Wr("ngIf", t.formService.statusT.errors.required) } } function iP(t, e) { if (1 & t) { const t = Yr(); Gr(0, "div"), Gr(1, "div", 77), Gr(2, "input", 78), Jr("change", function () { const e = Oe(t).$implicit; return so(3).toggleMemberSelection(e) }), Zr(), Gr(3, "label", 79), xo(4), Zr(), Zr(), Zr() } if (2 & t) { const t = e.$implicit, i = so(3); vs(2), Wr("id", "member-" + t.id)("value", t)("checked", i.isMemberSelected(t)), vs(1), Wr("for", "member-" + t.id), vs(1), ko(" ", t.fullname, " ") } } const nP = function (t) { return { "is-invalid": t } }; function sP(t, e) { if (1 & t) { const t = Yr(); Gr(0, "div", 61), Gr(1, "div", 53), Gr(2, "div", 54), Gr(3, "div", 55), Gr(4, "label", 22), xo(5, "Edit Task"), Zr(), Zr(), Zr(), Gr(6, "div", 4), Gr(7, "form", 62), Gr(8, "div", 63), Gr(9, "label", 22), xo(10, "Task Name"), Zr(), Kr(11, "input", 64), zr(12, UT, 4, 3, "div", 24), zr(13, qT, 2, 1, "div", 24), Zr(), Gr(14, "div", 63), Gr(15, "label", 22), xo(16, "Task Description"), Zr(), Kr(17, "textarea", 65), zr(18, ZT, 2, 1, "div", 24), Zr(), Gr(19, "div", 2), Gr(20, "div", 26), Gr(21, "div", 21), Gr(22, "label", 22), xo(23, "Start Date*"), Zr(), Kr(24, "input", 66), zr(25, YT, 2, 1, "div", 24), Zr(), Zr(), Gr(26, "div", 26), Gr(27, "div", 21), Gr(28, "label", 22), xo(29, "Due Date*"), Zr(), Kr(30, "input", 67), zr(31, XT, 2, 1, "div", 24), Zr(), Zr(), Zr(), Gr(32, "div", 2), Gr(33, "div", 26), Gr(34, "div", 21), Gr(35, "label", 22), xo(36, "Status"), Zr(), Gr(37, "select", 68), zr(38, JT, 2, 2, "option", 35), Zr(), zr(39, eP, 2, 1, "div", 24), Zr(), Zr(), Gr(40, "div", 26), Gr(41, "div", 29), Gr(42, "label", 22), xo(43, "Priority"), Zr(), Gr(44, "select", 30), Gr(45, "option", 31), xo(46, "High"), Zr(), Gr(47, "option", 32), xo(48, "Normal"), Zr(), Gr(49, "option", 33), xo(50, "Low"), Zr(), Zr(), Zr(), Zr(), Zr(), Gr(51, "div", 26), Gr(52, "div", 69), Gr(53, "label", 22), xo(54, "Assigned Members"), Zr(), zr(55, iP, 5, 5, "div", 70), Zr(), Zr(), Gr(56, "div"), Gr(57, "div", 71), Gr(58, "div"), Gr(59, "a", 72), Jr("click", function () { return Oe(t), so(2).updateTask() }), xo(60, "Save"), Zr(), Gr(61, "a", 73), Jr("click", function () { return Oe(t), so(2).onClear() }), xo(62, "Cancel"), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr() } if (2 & t) { const t = so().$implicit, e = so(); Wr("id", "collapseEdit" + t.id), vs(7), Wr("formGroup", e.formService.formGroupAddTask), vs(4), Wr("ngClass", Ka(15, nP, e.formService.nameT && e.formService.nameT.errors && e.formService.nameT.touched))("value", e.task.title), vs(1), Wr("ngIf", e.formService.nameT && e.formService.nameT.errors && e.formService.nameT.touched), vs(1), Wr("ngIf", e.formService.nameT && e.formService.nameT.errors && e.formService.nameT.touched), vs(5), Wr("ngIf", e.formService.descriptionT && e.formService.descriptionT.errors && e.formService.descriptionT.touched), vs(6), Wr("ngClass", Ka(17, nP, e.formService.dateStartT && e.formService.dateStartT.errors && e.formService.dateStartT.touched)), vs(1), Wr("ngIf", e.formService.dateStartT && e.formService.dateStartT.errors && e.formService.dateStartT.touched), vs(5), Wr("ngClass", Ka(19, nP, e.formService.dueDateT && e.formService.dueDateT.errors && e.formService.dueDateT.touched)), vs(1), Wr("ngIf", e.formService.dueDateT && e.formService.dueDateT.errors && e.formService.dueDateT.touched), vs(6), Wr("ngClass", Ka(21, nP, e.formService.statusT && e.formService.statusT.errors && e.formService.statusT.touched)), vs(1), Wr("ngForOf", e.listStatus), vs(1), Wr("ngIf", e.formService.statusT && e.formService.statusT.errors && e.formService.statusT.touched), vs(16), Wr("ngForOf", e.listMembers) } } function rP(t, e) { if (1 & t) { const t = Yr(); Gr(0, "div", 20), Gr(1, "div", 39), Gr(2, "div", 4), Gr(3, "div", 40), Gr(4, "div"), Gr(5, "h5", 41), xo(6), Zr(), Gr(7, "div", 42), Gr(8, "p", 43), xo(9, "High "), Zr(), Zr(), Gr(10, "div", 44), Gr(11, "p", 43), xo(12, "Could "), Zr(), Zr(), Zr(), Gr(13, "div", 45), Gr(14, "a", 46), Jr("click", function () { const e = Oe(t).$implicit; return so().getTaskById(e.id) }), Kr(15, "i", 47), Zr(), Gr(16, "a", 48), Jr("click", function () { const e = Oe(t).$implicit, i = so(); return i.setCurrentOpenCollapseEdit(i.currentOpenCollapseEdit === "collapseEdit" + e.id ? null : "collapseEdit" + e.id), i.getTaskById(e.id) }), Kr(17, "i", 49), Zr(), Gr(18, "a", 50), Jr("click", function () { const e = Oe(t).$implicit; return so().MoveToTrash(e.id) }), Kr(19, "i", 51), Zr(), Zr(), Zr(), Zr(), Zr(), Gr(20, "div", 52), Gr(21, "div", 53), Gr(22, "div", 54), Gr(23, "div", 55), Gr(24, "label", 22), xo(25, "Details Task"), Zr(), Zr(), Zr(), Gr(26, "div", 4), Gr(27, "div", 2), Gr(28, "div", 56), Gr(29, "label", 22), xo(30, "Task Name"), Zr(), Kr(31, "input", 57), Zr(), Zr(), Gr(32, "div", 2), Gr(33, "div", 56), Gr(34, "label", 22), xo(35, "Task Description"), Zr(), Gr(36, "textarea", 57), xo(37, "                    "), Zr(), Zr(), Zr(), Gr(38, "div", 2), Gr(39, "div", 26), Gr(40, "div", 29), Gr(41, "label", 22), xo(42, "Memebers"), Zr(), Kr(43, "input", 58), Zr(), Zr(), Gr(44, "div", 26), Gr(45, "div", 29), Gr(46, "label", 22), xo(47, "Periority"), Zr(), Kr(48, "input", 59), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), zr(49, sP, 63, 23, "div", 60), Zr() } if (2 & t) { const t = e.$implicit, i = so(); vs(6), ko("", t.title, " "), vs(10), Hr("data-toggle", "collapse")("href", "#collapseEdit" + t.id, xn)("aria-expanded", i.currentOpenCollapseEdit === "collapseEdit" + t.id)("aria-controls", "collapseEdit" + t.id), vs(15), Wr("value", t.title), vs(5), Wr("value", t.description), vs(13), Wr("ngIf", i.currentOpenCollapseEdit === "collapseEdit" + t.id) } } function oP(t, e) { 1 & t && (Gr(0, "div"), xo(1, "Please enter your task Name*"), Zr()) } function aP(t, e) { 1 & t && (Gr(0, "div"), xo(1, "The title of task must be at least 3 characters long"), Zr()) } function lP(t, e) { 1 & t && (Gr(0, "div"), xo(1, "The title of task cannot exceed 30 characters*"), Zr()) } function cP(t, e) { if (1 & t && (Gr(0, "div", 74), zr(1, oP, 2, 0, "div", 75), zr(2, aP, 2, 0, "div", 75), zr(3, lP, 2, 0, "div", 75), Zr()), 2 & t) { const t = so(); vs(1), Wr("ngIf", t.formService.nameT.errors.required), vs(1), Wr("ngIf", t.formService.nameT.errors.minlength), vs(1), Wr("ngIf", t.formService.nameT.errors.maxlength) } } function hP(t, e) { 1 & t && (Gr(0, "div"), xo(1, "The task Name must be letters*"), Zr()) } function uP(t, e) { if (1 & t && (Gr(0, "div", 74), zr(1, hP, 2, 0, "div", 75), Zr()), 2 & t) { const t = so(); vs(1), Wr("ngIf", t.formService.nameT.hasError("pattern")) } } function dP(t, e) { 1 & t && (Gr(0, "div"), xo(1, "Please enter your task Description*"), Zr()) } function pP(t, e) { if (1 & t && (Gr(0, "div", 74), zr(1, dP, 2, 0, "div", 75), Zr()), 2 & t) { const t = so(); vs(1), Wr("ngIf", t.formService.descriptionT.errors.required) } } function fP(t, e) { 1 & t && (Gr(0, "div"), xo(1, "Please enter your task Start Date*"), Zr()) } function gP(t, e) { if (1 & t && (Gr(0, "div", 74), zr(1, fP, 2, 0, "div", 75), Zr()), 2 & t) { const t = so(); vs(1), Wr("ngIf", t.formService.dateStartT.errors.required) } } function mP(t, e) { 1 & t && (Gr(0, "div"), xo(1, "Please enter your task Due Date*"), Zr()) } function _P(t, e) { if (1 & t && (Gr(0, "div", 74), zr(1, mP, 2, 0, "div", 75), Zr()), 2 & t) { const t = so(); vs(1), Wr("ngIf", t.formService.dueDateT.errors.required) } } function vP(t, e) { if (1 & t && (Gr(0, "option", 76), xo(1), Zr()), 2 & t) { const t = e.$implicit; Wr("ngValue", t.id), vs(1), So(t.name) } } function yP(t, e) { 1 & t && (Gr(0, "div"), xo(1, "Please enter your task Status*"), Zr()) } function bP(t, e) { if (1 & t && (Gr(0, "div", 74), zr(1, yP, 2, 0, "div", 75), Zr()), 2 & t) { const t = so(); vs(1), Wr("ngIf", t.formService.statusT.errors.required) } } let wP = (() => { class t { constructor(t, e, i, n, s) { this.projectService = t, this.taskService = e, this.memberService = i, this.route = n, this.formService = s, this.project = new tm, this.listTask = new Array, this.task = new Rb, this.editTask = new Rb, this.listMembers = [], this.currentOpenCollapseEdit = null, this.listStatus = [{ id: "TODO", name: "Todo" }, { id: "DOING", name: "Doing" }, { id: "DONE", name: "Done" }, { id: "ARCHIVED", name: "Archived" }, { id: "PENDING", name: "Pending" }, { id: "IN_PROGRESS", name: "In Progress" }] } ngOnInit() { this.memberService.getAllMembers().subscribe(t => { this.listMembers = t, console.log("list members : ", this.listMembers) }), this.project = new tm, this.route.params.subscribe(t => { this.projetId = t.id, this.projectService.getProjectById(this.projetId).subscribe(t => { this.project = t, console.log("project  :", this.project), this.listTask = this.project.tasks.filter(t => "ARCHIVED" != t.status) }) }) } validateAllFormFields(t) { Object.keys(t.controls).forEach(e => { const i = t.get(e); i instanceof Cg ? i.markAsTouched({ onlySelf: !0 }) : i instanceof Eg && this.validateAllFormFields(i) }) } onSubmitTask() { var t, e, i, n, s, r; this.task.description = null === (t = this.formService.descriptionT) || void 0 === t ? void 0 : t.value, this.task.title = null === (e = this.formService.nameT) || void 0 === e ? void 0 : e.value, this.task.projectId = this.projetId, this.task.priority = null === (i = this.formService.periortyT) || void 0 === i ? void 0 : i.value, this.task.startDate = null === (n = this.formService.dateStartT) || void 0 === n ? void 0 : n.value, this.task.dueDate = null === (s = this.formService.dueDateT) || void 0 === s ? void 0 : s.value, this.task.status = null === (r = this.formService.statusT) || void 0 === r ? void 0 : r.value, alert("task : " + this.task), this.taskService.addTask(this.task).subscribe(t => { this.listTask.push(t), this.formService.formGroupAddTask.reset(), window.location.reload() }, t => { console.log(t) }) } onClear() { this.formService.formGroupAddTask.reset() } getTaskById(t) { this.taskService.taskById(t).subscribe(t => { this.task = t, console.log("task : ", this.task), this.formService.formGroupAddTask.patchValue({ nameT: this.task.title, descriptionT: this.task.description, dateStartT: this.task.startDate, periortyT: this.task.priority, dueDateT: this.task.dueDate, statusT: this.task.status }) }) } updateTask() { var t, e, i, n, s, r; this.editTask.description = null === (t = this.formService.descriptionT) || void 0 === t ? void 0 : t.value, this.editTask.title = null === (e = this.formService.nameT) || void 0 === e ? void 0 : e.value, this.editTask.projectId = this.projetId, this.editTask.id = this.task.id, this.editTask.priority = null === (i = this.formService.periortyT) || void 0 === i ? void 0 : i.value, this.editTask.startDate = null === (n = this.formService.dateStartT) || void 0 === n ? void 0 : n.value, this.editTask.dueDate = null === (s = this.formService.dueDateT) || void 0 === s ? void 0 : s.value, this.editTask.status = null === (r = this.formService.statusT) || void 0 === r ? void 0 : r.value, this.editTask.members = this.task.members, console.log("task to update : ", this.editTask), this.taskService.updateTask(this.editTask).subscribe(t => { console.log("task updated"), this.onClear(), setTimeout(() => { window.location.reload() }, 150) }) } MoveToTrash(t) { this.taskService.hideTask(t).subscribe(() => { console.log("task hide succesfully !"), setTimeout(() => { window.location.reload() }, 1e3) }, t => { console.log(t) }) } isMemberSelected(t) { var e, i; return (null === (i = null === (e = this.task) || void 0 === e ? void 0 : e.members) || void 0 === i ? void 0 : i.some(e => e.id === t.id)) || !1 } toggleMemberSelection(t) { this.isMemberSelected(t) ? this.task.members = this.task.members.filter(e => e.id !== t.id) : this.task.members.push(t) } setCurrentOpenCollapseEdit(t) { this.currentOpenCollapseEdit = t } } return t.\u0275fac = function (e) { return new (e || t)(Ur(Im), Ur(Xm), Ur(bv), Ur(Ad), Ur(em)) }, t.\u0275cmp = $t({ type: t, selectors: [["app-project-details"]], decls: 82, vars: 14, consts: [[1, "header-title", "mb-2"], [1, "d-flex", "flex-wrap", "justify-content-between", "mb-5", "mt-5"], [1, "row"], [1, "card"], [1, "card-body"], [1, "col-lg-12", "mb-1"], [1, "col-lg-12", "mb-0"], [1, "row", "mt-1"], [1, "card", "col-lg-12"], [1, "d-flex", "flex-wrap", "align-items-center", "justify-content-between", "breadcrumb-content"], [1, "d-flex", "flex-wrap", "align-items-center"], ["href", "#", "data-target", "#new-task-modal", "data-toggle", "modal", 1, "btn", "btn-primary"], ["class", "col-lg-12", 4, "ngFor", "ngForOf"], ["role", "dialog", "aria-modal", "true", "id", "new-task-modal", 1, "modal", "fade", "bd-example-modal-lg"], ["role", "document", 1, "modal-dialog", "modal-dialog-centered", "modal-lg"], [1, "modal-content"], [1, "modal-header", "d-block", "text-center", "pb-3", "border-bottom"], ["id", "exampleModalCenterTitle", 1, "modal-title"], [1, "modal-body"], [1, "mb-2", 3, "formGroup", "ngSubmit"], [1, "col-lg-12"], [1, "form-group", "mb-3"], [1, "h5"], ["type", "text", "formControlName", "nameT", "placeholder", "Enter task Name", 1, "form-control"], ["class", "invalid-feedback", 4, "ngIf"], ["formControlName", "descriptionT", "rows", "3", 1, "form-control"], [1, "col-lg-6"], ["type", "date", "formControlName", "dateStartT", "value", "", 1, "form-control"], ["type", "date", "formControlName", "dueDateT", "value", "", 1, "form-control"], [1, "form-group", "mb-0"], ["formControlName", "periortyT", "data-style", "py-0", 1, "bg-white", "selectpicker", "form-control"], ["value", "High"], ["value", "Normal"], ["value", "Low"], ["formControlName", "statusT", 1, "form-control", 3, "ngClass"], [3, "ngValue", 4, "ngFor", "ngForOf"], [1, "d-flex", "flex-wrap", "align-items-center", "justify-content-center", "mt-4"], ["type", "submit", 1, "btn", "btn-primary", "mr-3"], ["type", "button", "data-dismiss", "modal", 1, "btn", "btn-danger", 3, "click"], [1, "card", "card-widget", "task-card"], [1, "d-flex", "flex-wrap", "align-items-center", "justify-content-between"], [1, "mb-2"], [1, "taskLabels", "periortyHigh"], [1, "mb-2", 2, "color", "white"], [1, "taskLabels", "levelCould"], [1, "media", "align-items-center", "mt-md-0", "mt-3"], ["data-toggle", "collapse", "href", "#collapseSee1", "role", "button", "aria-expanded", "false", "aria-controls", "collapseSee1", 1, "btn", "bg-primary-light", "m-1", 3, "click"], [1, "ri-eye-2-line", "m-1"], ["role", "button", 1, "btn", "bg-warning-light", "m-1", 3, "click"], [1, "ri-edit-box-line", "m-1"], ["role", "button", 1, "btn", "bg-danger-light", "m-1", 3, "click"], [1, "ri-delete-bin-2-fill", "m-1"], ["id", "collapseSee1", 1, "collapse"], [1, "card", "card-list", "task-card"], [1, "card-header", "d-flex", "align-items-center", "justify-content-between", "px-0", "mx-3"], [1, "header-title"], [1, "form-group", "mb-3", "position-relative", "col-lg-12"], ["type", "text", "placeholder", "Design landing page of webkit", "readonly", "", 1, "form-control", "bg-white", 3, "value"], ["type", "text", "placeholder", "Dridi Farah", "readonly", "", 1, "form-control", "bg-white"], ["type", "text", "placeholder", "Must", "readonly", "", 1, "form-control", "bg-white"], ["class", "collapse", 3, "id", 4, "ngIf"], [1, "collapse", 3, "id"], [1, "mb-2", 3, "formGroup"], [1, "form-group", "mb-3", "position-relative"], ["type", "text", "formControlName", "nameT", "placeholder", "Design landing page of webkit", 1, "form-control", "bg-white", 3, "ngClass", "value"], ["type", "text", "formControlName", "descriptionT", "placeholder", "Design landing page of webkit", 1, "form-control", "bg-white"], ["type", "date", "formControlName", "dateStartT", 1, "form-control", 3, "ngClass"], ["type", "date", "formControlName", "dueDateT", 1, "form-control", 3, "ngClass"], ["id", "editStatus", "formControlName", "statusT", 1, "form-control", 3, "ngClass"], [1, "form-group"], [4, "ngFor", "ngForOf"], [1, "d-flex", "flex-wrap", "justify-content-end", "mt-2"], [1, "btn", "bg-success-light", "mr-1", 3, "click"], [1, "btn", "bg-danger-light", 3, "click"], [1, "invalid-feedback"], [4, "ngIf"], [3, "ngValue"], [1, "form-check"], ["type", "checkbox", 1, "form-check-input", 3, "id", "value", "checked", "change"], [1, "form-check-label", 3, "for"]], template: function (t, e) { 1 & t && (Gr(0, "div", 0), Gr(1, "div", 1), Gr(2, "h4"), xo(3), Zr(), Zr(), Zr(), Gr(4, "div", 2), Gr(5, "div", 3), Gr(6, "div", 4), Gr(7, "h5", 5), xo(8, "Description "), Zr(), Gr(9, "p", 6), xo(10), Zr(), Zr(), Zr(), Zr(), Gr(11, "div", 7), Gr(12, "div", 8), Gr(13, "div", 4), Gr(14, "div", 9), Gr(15, "h5"), xo(16, "New Task"), Zr(), Gr(17, "div", 10), Gr(18, "a", 11), xo(19, "New Task"), Zr(), Zr(), Zr(), Kr(20, "br"), Gr(21, "div", 4), Gr(22, "div", 2), zr(23, rP, 50, 8, "div", 12), Zr(), Zr(), Zr(), Zr(), Zr(), Gr(24, "div", 13), Gr(25, "div", 14), Gr(26, "div", 15), Gr(27, "div", 16), Gr(28, "h3", 17), xo(29, "New Task"), Zr(), Zr(), Gr(30, "div", 18), Gr(31, "form", 19), Jr("ngSubmit", function () { return e.onSubmitTask() }), Gr(32, "div", 2), Gr(33, "div", 20), Gr(34, "div", 21), Gr(35, "label", 22), xo(36, "Task Name"), Zr(), Kr(37, "input", 23), zr(38, cP, 4, 3, "div", 24), zr(39, uP, 2, 1, "div", 24), Zr(), Zr(), Gr(40, "div", 20), Gr(41, "div", 21), Gr(42, "label", 22), xo(43, "Description"), Zr(), Kr(44, "textarea", 25), zr(45, pP, 2, 1, "div", 24), Zr(), Zr(), Gr(46, "div", 26), Gr(47, "div", 21), Gr(48, "label", 22), xo(49, "Start Date*"), Zr(), Kr(50, "input", 27), zr(51, gP, 2, 1, "div", 24), Zr(), Zr(), Gr(52, "div", 26), Gr(53, "div", 21), Gr(54, "label", 22), xo(55, "Due Date*"), Zr(), Kr(56, "input", 28), zr(57, _P, 2, 1, "div", 24), Zr(), Zr(), Gr(58, "div", 26), Gr(59, "div", 29), Gr(60, "label", 22), xo(61, "Priority"), Zr(), Gr(62, "select", 30), Gr(63, "option", 31), xo(64, "High"), Zr(), Gr(65, "option", 32), xo(66, "Normal"), Zr(), Gr(67, "option", 33), xo(68, "Low"), Zr(), Zr(), Zr(), Zr(), Gr(69, "div", 26), Gr(70, "div", 21), Gr(71, "label", 22), xo(72, "Status"), Zr(), Gr(73, "select", 34), zr(74, vP, 2, 2, "option", 35), Zr(), zr(75, bP, 2, 1, "div", 24), Zr(), Zr(), Gr(76, "div", 20), Gr(77, "div", 36), Gr(78, "button", 37), xo(79, "Save"), Zr(), Gr(80, "button", 38), Jr("click", function () { return e.onClear() }), xo(81, "Cancel"), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr()), 2 & t && (vs(3), ko("Projet : ", e.project.name, " "), vs(7), So(e.project.description), vs(13), Wr("ngForOf", e.listTask), vs(8), Wr("formGroup", e.formService.formGroupAddTask), vs(7), Wr("ngIf", e.formService.nameT && e.formService.nameT.errors && e.formService.nameT.touched), vs(1), Wr("ngIf", e.formService.nameT && e.formService.nameT.errors && e.formService.nameT.touched), vs(6), Wr("ngIf", e.formService.descriptionT && e.formService.descriptionT.errors && e.formService.descriptionT.touched), vs(6), Wr("ngIf", e.formService.dateStartT && e.formService.dateStartT.errors && e.formService.dateStartT.touched), vs(6), Wr("ngIf", e.formService.dueDateT && e.formService.dueDateT.errors && e.formService.dueDateT.touched), vs(16), Wr("ngClass", Ka(12, nP, e.formService.statusT && e.formService.statusT.errors && e.formService.statusT.touched)), vs(1), Wr("ngForOf", e.listStatus), vs(1), Wr("ngIf", e.formService.statusT && e.formService.statusT.errors && e.formService.statusT.touched)) }, directives: [zc, Ig, ig, jg, Of, eg, Bg, Uc, $g, Ug, Zg, Bc], styles: [".card[_ngcontent-%COMP%], .row[_ngcontent-%COMP%]{width:100%}.periortyHigh[_ngcontent-%COMP%]{background-color:#bf3131;color:#fff}.periortyLow[_ngcontent-%COMP%]{background-color:#ffd93d;color:#fff}.periortyNormal[_ngcontent-%COMP%]{background-color:#7aa874;color:#fff}.levelMust[_ngcontent-%COMP%]{background-color:#b31312;color:#fff}.levelCould[_ngcontent-%COMP%]{background-color:#a3b763;color:#fff}.levelSould[_ngcontent-%COMP%]{background-color:#f2be22;color:#fff}.levelWill[_ngcontent-%COMP%]{background-color:#e57c23;color:#fff}.taskLabels[_ngcontent-%COMP%]{color:#fff;width:auto;height:auto;margin:2px;padding:5px;text-align:center;display:inline-block;vertical-align:top;box-shadow:0 0 10px #0000001a;border-radius:10px;overflow:hidden;border:1px solid #ddd}"] }), t })(); function xP(t, e, i, n, s, r, o) { try { var a = t[r](o), l = a.value } catch (c) { return void i(c) } a.done ? e(l) : Promise.resolve(l).then(n, s) } class SP { } let kP = (() => { class t { constructor(t) { this.http = t } login(t) { return this.http.post("http://devazure.eastus.cloudapp.azure.com:8085/api/auth/authenticate", t) } } return t.\u0275fac = function (e) { return new (e || t)(hn(bm)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(); function CP(t, e) { 1 & t && (Gr(0, "div", 27), xo(1, " Please enter username* "), Zr()) } function EP(t, e) { 1 & t && (Gr(0, "div", 27), xo(1, " Please enter your password* "), Zr()) } function TP(t, e) { 1 & t && (Gr(0, "div", 28), xo(1, "Login successful! Redirecting..."), Zr()) } function PP(t, e) { 1 & t && (Gr(0, "div", 29), xo(1, "Login failed. Please check your credentials and try again."), Zr()) } const DP = function (t) { return { "is-invalid": t } }; let AP = (() => { class t { constructor(t, e, i, n) { this.formService = t, this.router = e, this.authService = i, this.tokenStorage = n, this.role = this.tokenStorage.getRole(), this.login = new SP, this.showsuccessmessage = !1, this.showerrormessage = !1 } ngOnInit() { this.showsuccessmessage = !1, this.showerrormessage = !1 } validateAllFormFields(t) { Object.keys(t.controls).forEach(e => { const i = t.get(e); i instanceof Cg ? i.markAsTouched({ onlySelf: !0 }) : i instanceof Eg && this.validateAllFormFields(i) }) } onSubmit() { var t, e = this; return (t = function* () { e.formService.formGroupLogin.valid ? (e.login.userName = e.formService.formGroupLogin.value.username, e.login.password = e.formService.formGroupLogin.value.password, console.log("login :", e.login), e.authService.login(e.login).subscribe(t => { console.log("data :", t), e.showerrormessage = !1, e.showsuccessmessage = !0, e.tokenStorage.savedata(t), "user" === localStorage.getItem("role-user") ? (console.log("role user:", t.role), e.router.navigateByUrl("homeUser/DashbordUser")) : "admin" === localStorage.getItem("role-user") && (console.log("role admin:", t.role), e.router.navigateByUrl("homeAdmin/DashbordAdmin")), e.onClear() }, t => { console.log("error :", t), e.showerrormessage = !0, e.showsuccessmessage = !1, setTimeout(() => { e.showerrormessage = !1 }, 2e3) })) : e.validateAllFormFields(e.formService.formGroupLogin) }, function () { var e = this, i = arguments; return new Promise(function (n, s) { var r = t.apply(e, i); function o(t) { xP(r, n, s, o, a, "next", t) } function a(t) { xP(r, n, s, o, a, "throw", t) } o(void 0) }) })() } onClear() { this.formService.formGroupLogin.reset() } } return t.\u0275fac = function (e) { return new (e || t)(Ur(em), Ur(Xp), Ur(kP), Ur(kf)) }, t.\u0275cmp = $t({ type: t, selectors: [["app-login"]], decls: 38, vars: 11, consts: [[1, ""], [1, "wrapper"], [1, "login-content"], [1, "container"], [1, "row", "align-items-center", "justify-content-center", "height-self-center"], [1, "col-lg-8"], [1, "card", "auth-card"], [1, "card-body", "p-0"], [1, "d-flex", "align-items-center", "auth-content"], [1, "col-lg-6", "bg-primary", "content-left"], [1, "p-3"], [1, "mb-2", "text-white"], [3, "formGroup"], [1, "row"], [1, "col-lg-12"], [1, "floating-label", "form-group"], ["formControlName", "username", "type", "email", "placeholder", " ", 1, "floating-input", "form-control", 3, "ngClass"], ["class", "invalid-feedback", 4, "ngIf"], ["formControlName", "password", "type", "password", "placeholder", " ", 1, "floating-input", "form-control", 3, "ngClass"], ["type", "submit", 1, "btn", "btn-white", "col-lg-12", 3, "click"], [1, "mt-3"], ["href", "auth-sign-up.html", 1, "text-white", "text-underline"], [1, "col-lg-6", "content-right"], ["src", "assets/images/login/01.png", "alt", "", 1, "img-fluid", "image-right"], [1, "alert-container"], ["class", "alert alert-success", "role", "alert", 4, "ngIf"], ["class", "alert alert-danger", "role", "alert", 4, "ngIf"], [1, "invalid-feedback"], ["role", "alert", 1, "alert", "alert-success"], ["role", "alert", 1, "alert", "alert-danger"]], template: function (t, e) { 1 & t && (Gr(0, "body", 0), Gr(1, "div", 1), Gr(2, "section", 2), Gr(3, "div", 3), Gr(4, "div", 4), Gr(5, "div", 5), Gr(6, "div", 6), Gr(7, "div", 7), Gr(8, "div", 8), Gr(9, "div", 9), Gr(10, "div", 10), Gr(11, "h2", 11), xo(12, "Sign In"), Zr(), Gr(13, "form", 12), Gr(14, "div", 13), Gr(15, "div", 14), Gr(16, "div", 15), Kr(17, "input", 16), Gr(18, "label"), xo(19, "Username"), Zr(), zr(20, CP, 2, 0, "div", 17), Zr(), Zr(), Gr(21, "div", 14), Gr(22, "div", 15), Kr(23, "input", 18), zr(24, EP, 2, 0, "div", 17), Gr(25, "label"), xo(26, "Password"), Zr(), Zr(), Zr(), Zr(), Gr(27, "button", 19), Jr("click", function () { return e.onSubmit() }), xo(28, "Sign In"), Zr(), Gr(29, "p", 20), xo(30, " Create an Account "), Gr(31, "a", 21), xo(32, "Sign Up"), Zr(), Zr(), Zr(), Zr(), Zr(), Gr(33, "div", 22), Kr(34, "img", 23), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Gr(35, "div", 24), zr(36, TP, 2, 0, "div", 25), zr(37, PP, 2, 0, "div", 26), Zr()), 2 & t && (vs(13), Wr("formGroup", e.formService.formGroupLogin), vs(4), Wr("ngClass", Ka(7, DP, e.formService.username && e.formService.username.errors && e.formService.username.touched)), vs(3), Wr("ngIf", e.formService.username && e.formService.username.hasError("required")), vs(3), Wr("ngClass", Ka(9, DP, e.formService.password && e.formService.password.errors && e.formService.password.touched)), vs(1), Wr("ngIf", e.formService.password && e.formService.password.hasError("required")), vs(12), Wr("ngIf", e.showsuccessmessage), vs(1), Wr("ngIf", e.showerrormessage)) }, directives: [Ig, ig, jg, Of, eg, Bg, Bc, Uc], styles: [""] }), t })(); function OP(t, e) { 1 & t && (Gr(0, "tbody"), Gr(1, "tr"), Gr(2, "td", 10), xo(3, "Loading data..."), Zr(), Zr(), Zr()) } function RP(t, e) { if (1 & t) { const t = Yr(); Gr(0, "tr"), Gr(1, "td"), xo(2), Zr(), Gr(3, "td"), xo(4), Zr(), Gr(5, "td"), xo(6), Zr(), Gr(7, "td"), xo(8), Zr(), Gr(9, "td"), xo(10), Zr(), Gr(11, "td"), xo(12), Zr(), Gr(13, "td"), Gr(14, "div", 12), Gr(15, "a", 13), Jr("click", function () { const e = Oe(t).$implicit; return so(2).cancelHidden(e.id) }), Kr(16, "i", 14), xo(17, "Restore "), Zr(), Gr(18, "a", 15), Jr("click", function () { const e = Oe(t).$implicit; return so(2).deleteTask(e.id) }), Kr(19, "i", 16), xo(20, "Delete "), Zr(), Zr(), Zr(), Zr() } if (2 & t) { const t = e.$implicit; vs(2), So(t.id), vs(2), So(t.title), vs(2), So(t.description), vs(2), So(t.startDate), vs(2), So(t.dueDate), vs(2), So(t.status) } } function MP(t, e) { if (1 & t && (Gr(0, "tbody"), zr(1, RP, 21, 6, "tr", 11), Zr()), 2 & t) { const t = so(); vs(1), Wr("ngForOf", t.tasks) } } let IP = (() => { class t { constructor(t, e, i) { this.router = t, this.taskService = e, this.http = i, this.dtOptions = {}, this.dtTrigger = new S, this.loadingData = !1 } ngOnInit() { let t = 0, e = ""; this.dtOptions = { pagingType: "full_numbers", pageLength: 3, displayStart: t, search: { search: e }, serverSide: !0, processing: !0, lengthMenu: [5, 10, 25], ajax: (i, n) => { t = i.start, e = i.search.value, this.loadingData = !0, this.request = this.http.post("http://devazure.eastus.cloudapp.azure.com:8085/api/tasks/archived", i, {}).subscribe(t => { this.loadingData = !1, this.tasks = t.data, n({ recordsTotal: t.recordsTotal, recordsFiltered: t.recordsFiltered, data: [] }) }) }, columns: [{ data: "id" }, { data: "title" }, { data: "description" }, { data: "startDate" }, { data: "dueDate" }, { data: "status" }] } } deleteTask(t) { this.taskService.deleteTask(t).subscribe(t => { console.log("task deleted"), window.location.reload() }) } cancelHidden(t) { this.taskService.fromTrashToListTask(t).subscribe(t => { window.location.reload() }, t => { console.log(t) }) } } return t.\u0275fac = function (e) { return new (e || t)(Ur(Xp), Ur(Xm), Ur(bm)) }, t.\u0275cmp = $t({ type: t, selectors: [["app-hiden-tasks-admin"]], decls: 30, vars: 3, consts: [[1, "header-title"], [1, "container-fluid"], [1, "row"], [1, "col-sm-12"], [1, "card"], [1, "card-header", "d-flex", "justify-content-between"], [1, "card-body"], [1, "table-responsive"], ["id", "table", "datatable", "", 1, "display", 2, "width", "100%", 3, "dtOptions"], [4, "ngIf"], ["colspan", "8", 1, "loading-indicator-cell", 2, "text-align", "center"], [4, "ngFor", "ngForOf"], [2, "display", "flex"], ["role", "button", 1, "btn", "bg-secondary-light", "m-1", "restore-button", 3, "click"], [1, "ri-eye-close-line", "m-1"], ["role", "button", 1, "btn", "bg-danger", "m-1", "delete-button", 3, "click"], [1, "ri-delete-bin-line", "m-1"]], template: function (t, e) { 1 & t && (Gr(0, "div", 0), Gr(1, "h4"), xo(2, "Trash "), Zr(), Zr(), Kr(3, "br"), Gr(4, "div", 1), Gr(5, "div", 2), Gr(6, "div", 3), Gr(7, "div", 4), Kr(8, "div", 5), Gr(9, "div", 6), Gr(10, "div", 7), Gr(11, "table", 8), Gr(12, "thead"), Gr(13, "tr"), Gr(14, "th"), xo(15, "ID"), Zr(), Gr(16, "th"), xo(17, "Title"), Zr(), Gr(18, "th"), xo(19, "Description"), Zr(), Gr(20, "th"), xo(21, "Start Date"), Zr(), Gr(22, "th"), xo(23, "Due Date"), Zr(), Gr(24, "th"), xo(25, "Status"), Zr(), Gr(26, "th"), xo(27, "Actions"), Zr(), Zr(), Zr(), zr(28, OP, 4, 0, "tbody", 9), zr(29, MP, 2, 1, "tbody", 9), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr()), 2 & t && (vs(11), Wr("dtOptions", e.dtOptions), vs(17), Wr("ngIf", e.loadingData), vs(1), Wr("ngIf", !e.loadingData)) }, directives: [wv, Uc, zc], styles: [""] }), t })(); class LP { } function FP(t, e) { if (1 & t) { const t = Yr(); Gr(0, "div", 45), Gr(1, "div", 46), Gr(2, "div", 47), Gr(3, "div", 48), Gr(4, "div", 49), Kr(5, "img", 50), Zr(), Gr(6, "div", 51), Gr(7, "h4", 52), xo(8), Zr(), Gr(9, "p", 53), xo(10), Zr(), Gr(11, "p", 54), xo(12), Zr(), Gr(13, "ul", 55), Gr(14, "li", 56), Jr("click", function () { const e = Oe(t).$implicit; return so().getDetailsUser(e.id) }), Kr(15, "i", 57), Zr(), Gr(16, "li", 58), Jr("click", function () { const e = Oe(t).$implicit; return so().getDetailsUser(e.id) }), Kr(17, "i", 59), Zr(), Gr(18, "li", 60), Jr("click", function () { const e = Oe(t).$implicit; return so().getDetailsUser(e.id) }), Kr(19, "i", 61), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr() } if (2 & t) { const t = e.$implicit; vs(8), ko("", t.fullname, " "), vs(2), So(t.role), vs(2), So(t.email) } } function NP(t, e) { 1 & t && (Gr(0, "div"), xo(1, "Please enter the name*"), Zr()) } function jP(t, e) { 1 & t && (Gr(0, "div"), xo(1, "The Name must be at least 3 characters long*"), Zr()) } function VP(t, e) { 1 & t && (Gr(0, "div"), xo(1, "The Name cannot exceed 20 characters*"), Zr()) } function BP(t, e) { if (1 & t && (Gr(0, "div", 62), zr(1, NP, 2, 0, "div", 63), zr(2, jP, 2, 0, "div", 63), zr(3, VP, 2, 0, "div", 63), Zr()), 2 & t) { const t = so(); vs(1), Wr("ngIf", t.formService.nameEmp.errors.required), vs(1), Wr("ngIf", t.formService.nameEmp.errors.minlength), vs(1), Wr("ngIf", t.formService.nameEmp.errors.maxlength) } } function HP(t, e) { 1 & t && (Gr(0, "div", 62), xo(1, " The age must be letters* "), Zr()) } function zP(t, e) { 1 & t && (Gr(0, "div"), xo(1, "Please enter the phone number*"), Zr()) } function $P(t, e) { 1 & t && (Gr(0, "div"), xo(1, "The phone number must be at least 8 numbers*"), Zr()) } function UP(t, e) { 1 & t && (Gr(0, "div"), xo(1, "The phone number cannot exceed 8 numbers*"), Zr()) } function WP(t, e) { if (1 & t && (Gr(0, "div", 62), zr(1, zP, 2, 0, "div", 63), zr(2, $P, 2, 0, "div", 63), zr(3, UP, 2, 0, "div", 63), Zr()), 2 & t) { const t = so(); vs(1), Wr("ngIf", t.formService.phoneEmp.errors.required), vs(1), Wr("ngIf", t.formService.phoneEmp.errors.minlength), vs(1), Wr("ngIf", t.formService.phoneEmp.errors.maxlength) } } function qP(t, e) { 1 & t && (Gr(0, "div", 62), xo(1, " The phone number must be 8 digits* "), Zr()) } function GP(t, e) { 1 & t && (Gr(0, "div", 62), xo(1, " Please enter email* "), Zr()) } function ZP(t, e) { 1 & t && (Gr(0, "div", 62), xo(1, " The email must be a valid email address* "), Zr()) } function KP(t, e) { 1 & t && (Gr(0, "div"), xo(1, "Please enter the login*"), Zr()) } function YP(t, e) { 1 & t && (Gr(0, "div"), xo(1, "The login must be at least 3 characters long*"), Zr()) } function QP(t, e) { 1 & t && (Gr(0, "div"), xo(1, "the login cannot exceed 20 characters*"), Zr()) } function XP(t, e) { if (1 & t && (Gr(0, "div", 62), zr(1, KP, 2, 0, "div", 63), zr(2, YP, 2, 0, "div", 63), zr(3, QP, 2, 0, "div", 63), Zr()), 2 & t) { const t = so(); vs(1), Wr("ngIf", t.formService.usernameEmp.errors.required), vs(1), Wr("ngIf", t.formService.usernameEmp.errors.minlength), vs(1), Wr("ngIf", t.formService.usernameEmp.errors.maxlength) } } function JP(t, e) { 1 & t && (Gr(0, "div"), xo(1, "Please enter the password*"), Zr()) } function tD(t, e) { 1 & t && (Gr(0, "div"), xo(1, "The password must be at least 3 characters long*"), Zr()) } function eD(t, e) { 1 & t && (Gr(0, "div"), xo(1, "the password cannot exceed 20 characters*"), Zr()) } function iD(t, e) { if (1 & t && (Gr(0, "div", 62), zr(1, JP, 2, 0, "div", 63), zr(2, tD, 2, 0, "div", 63), zr(3, eD, 2, 0, "div", 63), Zr()), 2 & t) { const t = so(); vs(1), Wr("ngIf", t.formService.passwordEmp.errors.required), vs(1), Wr("ngIf", t.formService.passwordEmp.errors.minlength), vs(1), Wr("ngIf", t.formService.passwordEmp.errors.maxlength) } } function nD(t, e) { 1 & t && (Gr(0, "div"), xo(1, "Please enter the name*"), Zr()) } function sD(t, e) { 1 & t && (Gr(0, "div"), xo(1, "The Name must be at least 3 characters long*"), Zr()) } function rD(t, e) { 1 & t && (Gr(0, "div"), xo(1, "The Name cannot exceed 20 characters*"), Zr()) } function oD(t, e) { if (1 & t && (Gr(0, "div", 62), zr(1, nD, 2, 0, "div", 63), zr(2, sD, 2, 0, "div", 63), zr(3, rD, 2, 0, "div", 63), Zr()), 2 & t) { const t = so(); vs(1), Wr("ngIf", t.formService.nameEmp.errors.required), vs(1), Wr("ngIf", t.formService.nameEmp.errors.minlength), vs(1), Wr("ngIf", t.formService.nameEmp.errors.maxlength) } } function aD(t, e) { 1 & t && (Gr(0, "div", 62), xo(1, " The age must be letters* "), Zr()) } function lD(t, e) { 1 & t && (Gr(0, "div"), xo(1, "Please enter the phone number*"), Zr()) } function cD(t, e) { 1 & t && (Gr(0, "div"), xo(1, "The phone number must be at least 8 numbers*"), Zr()) } function hD(t, e) { 1 & t && (Gr(0, "div"), xo(1, "The phone number cannot exceed 8 numbers*"), Zr()) } function uD(t, e) { if (1 & t && (Gr(0, "div", 62), zr(1, lD, 2, 0, "div", 63), zr(2, cD, 2, 0, "div", 63), zr(3, hD, 2, 0, "div", 63), Zr()), 2 & t) { const t = so(); vs(1), Wr("ngIf", t.formService.phoneEmp.errors.required), vs(1), Wr("ngIf", t.formService.phoneEmp.errors.minlength), vs(1), Wr("ngIf", t.formService.phoneEmp.errors.maxlength) } } function dD(t, e) { 1 & t && (Gr(0, "div", 62), xo(1, " The phone number must be 8 digits* "), Zr()) } function pD(t, e) { 1 & t && (Gr(0, "div", 62), xo(1, " Please enter email* "), Zr()) } function fD(t, e) { 1 & t && (Gr(0, "div", 62), xo(1, " The email must be a valid email address* "), Zr()) } function gD(t, e) { 1 & t && (Gr(0, "div"), xo(1, "Please enter the login*"), Zr()) } function mD(t, e) { 1 & t && (Gr(0, "div"), xo(1, "The login must be at least 3 characters long*"), Zr()) } function _D(t, e) { 1 & t && (Gr(0, "div"), xo(1, "the login cannot exceed 20 characters*"), Zr()) } function vD(t, e) { if (1 & t && (Gr(0, "div", 62), zr(1, gD, 2, 0, "div", 63), zr(2, mD, 2, 0, "div", 63), zr(3, _D, 2, 0, "div", 63), Zr()), 2 & t) { const t = so(); vs(1), Wr("ngIf", t.formService.usernameEmp.errors.required), vs(1), Wr("ngIf", t.formService.usernameEmp.errors.minlength), vs(1), Wr("ngIf", t.formService.usernameEmp.errors.maxlength) } } function yD(t, e) { 1 & t && (Gr(0, "div"), xo(1, "Please enter the password*"), Zr()) } function bD(t, e) { 1 & t && (Gr(0, "div"), xo(1, "The password must be at least 3 characters long*"), Zr()) } function wD(t, e) { 1 & t && (Gr(0, "div"), xo(1, "the password cannot exceed 20 characters*"), Zr()) } function xD(t, e) { if (1 & t && (Gr(0, "div", 62), zr(1, yD, 2, 0, "div", 63), zr(2, bD, 2, 0, "div", 63), zr(3, wD, 2, 0, "div", 63), Zr()), 2 & t) { const t = so(); vs(1), Wr("ngIf", t.formService.passwordEmp.errors.required), vs(1), Wr("ngIf", t.formService.passwordEmp.errors.minlength), vs(1), Wr("ngIf", t.formService.passwordEmp.errors.maxlength) } } const SD = function (t) { return { "is-invalid": t } }, kD = [{ path: "", component: AP }, { path: "homeAdmin", component: Jg, children: [{ path: "DashbordAdmin", component: BT }, { path: "listProjet", component: Qm }, { path: "detailsProject/:id", component: wP }, { path: "listTasks", component: Ov }, { path: "listTasksHidenForAdmin", component: IP }, { path: "employees", component: (() => { class t { constructor(t, e) { this.formService = t, this.memberService = e, this.listMembers = [], this.member = new LP, this.editMember = new LP, this.roleUser = "" } ngOnInit() { this.memberService.getAllMembers().subscribe(t => { console.log("data : ", t), this.listMembers = t, console.log("list members : ", this.listMembers) }) } onClear() { this.member = new LP, this.editMember = new LP, this.roleUser = "", this.formService.formGroupAddEmp.reset() } onSubmit() { this.formService.formGroupAddEmp.valid ? (console.log("form submitted"), this.member.email = this.formService.formGroupAddEmp.value.emailEmp, this.member.fullname = this.formService.formGroupAddEmp.value.nameEmp, this.member.password = this.formService.formGroupAddEmp.value.passwordEmp, this.member.username = this.formService.formGroupAddEmp.value.usernameEmp, this.member.phone = this.formService.formGroupAddEmp.value.phoneEmp, this.member.role = this.roleUser, console.log("user to add :", this.member), this.memberService.addMember(this.member).subscribe(t => { console.log("data : ", t), this.member = new LP, setTimeout(() => { window.location.reload() }, 1e3) }, t => { console.log(t) })) : (console.log("invalid form"), this.validateAllFormFields(this.formService.formGroupAddEmp)) } validateAllFormFields(t) { Object.keys(t.controls).forEach(e => { const i = t.get(e); i instanceof Cg ? i.markAsTouched({ onlySelf: !0 }) : i instanceof Eg && this.validateAllFormFields(i) }) } getDetailsUser(t) { this.memberService.getMemberById(t).subscribe(t => { console.log("data : ", t), this.member = t, this.formService.formGroupAddEmp.patchValue({ nameEmp: this.member.fullname, emailEmp: this.member.email, usernameEmp: this.member.username, phoneEmp: this.member.phone, passwordEmp: this.member.password }) }, t => { console.log("error :", t) }) } editUser() { this.formService.formGroupAddEmp.valid ? (this.editMember.email = this.formService.formGroupAddEmp.value.emailEmp, this.editMember.fullname = this.formService.formGroupAddEmp.value.nameEmp, this.editMember.username = this.formService.formGroupAddEmp.value.usernameEmp, this.editMember.password = this.formService.formGroupAddEmp.value.passwordEmp, this.editMember.phone = this.formService.formGroupAddEmp.value.phoneEmp, console.log("edit emp :", this.editMember), this.memberService.updateMember(this.editMember).subscribe(t => { console.log("susses updating user :", this.editMember), setTimeout(() => { window.location.reload() }, 1e3) }, t => { console.log(t) })) : (console.log("error updating..."), this.validateAllFormFields(this.formService.formGroupAddEmp)) } deleteUser(t) { this.memberService.deleteMember(t).subscribe(() => { console.log("user deleted !"), setTimeout(() => { window.location.reload() }, 1e3) }) } affecterRole(t) { this.roleUser = t.target.value, console.log("R\xf4le s\xe9lectionn\xe9 :", this.roleUser) } } return t.\u0275fac = function (e) { return new (e || t)(Ur(em), Ur(bv)) }, t.\u0275cmp = $t({ type: t, selectors: [["app-employees-admin"]], decls: 205, vars: 61, consts: [[1, "container-fluid"], [1, "row"], [1, "col-lg-12"], [1, "card"], [1, "card-body"], [1, "d-flex", "flex-wrap", "align-items-center", "justify-content-between", "breadcrumb-content"], [1, "pl-3", "border-left", "btn-new"], ["href", "#", "data-target", "#new-user-modal", "data-toggle", "modal", 1, "btn", "btn-primary"], ["id", "grid", "data-toggle-extra", "tab-content", 1, "item-content", "animate__animated", "animate__fadeIn", "active"], ["class", "col-lg-4 col-md-6", 4, "ngFor", "ngForOf"], ["role", "dialog", "aria-modal", "true", "id", "new-user-modal", 1, "modal", "fade", "bd-example-modal-lg"], ["role", "document", 1, "modal-dialog", "modal-dialog-centered", "modal-lg"], [1, "modal-content"], [1, "modal-header", "d-block", "text-center", "pb-3", "border-bttom"], ["id", "exampleModalCenterTitle01", 1, "modal-title"], [1, "modal-body"], [3, "formGroup"], [1, "form-group", "mb-3"], [1, "h5"], ["formControlName", "nameEmp", "type", "text", "placeholder", "Enter the full name", 1, "form-control", 3, "ngClass"], ["class", "invalid-feedback", 4, "ngIf"], [1, "col-lg-6"], ["formControlName", "phoneEmp", "type", "text", "placeholder", "Enter phone number", 1, "form-control", 3, "ngClass"], ["formControlName", "emailEmp", "type", "text", "placeholder", "Enter your Email", 1, "form-control", 3, "ngClass"], ["formControlName", "usernameEmp", "type", "text", "placeholder", "Enter your Login", 1, "form-control", 3, "ngClass"], ["formControlName", "passwordEmp", "type", "password", "placeholder", "Enter your Password", 1, "form-control", 3, "ngClass"], ["name", "type", "data-style", "py-0", 1, "selectpicker", "form-control", 3, "change"], [1, "d-flex", "flex-wrap", "align-items-ceter", "justify-content-center", "mt-2"], ["type", "submit", "data-dismiss", "modal", 1, "btn", "btn-primary", "mr-3", 3, "click"], ["data-dismiss", "modal", 1, "btn", "btn-danger", 3, "click"], ["role", "dialog", "aria-modal", "true", "id", "edit-user-modal", 1, "modal", "fade", "bd-example-modal-lg"], [1, "modal-title"], ["formControlName", "nameEmp", "type", "text", "placeholder", "Enter the full name", 1, "form-control", 3, "value", "ngClass"], ["formControlName", "phoneEmp", "type", "text", "placeholder", "Enter phone number", 1, "form-control", 3, "value", "ngClass"], ["formControlName", "emailEmp", "type", "text", "placeholder", "Enter your Email", 1, "form-control", 3, "value", "ngClass"], ["formControlName", "usernameEmp", "type", "text", "placeholder", "Enter your Login", 1, "form-control", 3, "value", "ngClass"], ["formControlName", "passwordEmp", "type", "password", "placeholder", "Enter your Password", 1, "form-control", 3, "value", "ngClass"], ["role", "dialog", "aria-modal", "true", "id", "show-user-modal", 1, "modal", "fade", "bd-example-modal-lg"], ["readonly", "", "type", "text", 1, "form-control", 3, "value"], ["readonly", "", "type", "password", 1, "form-control", 3, "value"], ["type", "text", "readonly", "", 1, "form-control", 3, "value"], ["role", "dialog", "aria-modal", "true", "id", "deleteUser", 1, "modal", "fade", "bd-example-modal-lg"], [1, "h5", "justify-content-center"], ["data-dismiss", "modal", 1, "btn", "btn-primary", "mr-3", 3, "click"], ["data-dismiss", "modal", 1, "btn", "btn-danger"], [1, "col-lg-4", "col-md-6"], [1, "card-transparent", "card-block", "card-stretch", "card-height"], [1, "card-body", "text-center", "p-0"], [1, "item"], [1, "odr-img"], ["src", "assets/images/user/01.jpg", "alt", "image", 1, "img-fluid", "rounded-circle", "avatar-90", "m-auto"], [1, "odr-content", "rounded"], [1, "mb-2"], [1, "mb-1"], [1, "mb-3"], [1, "list-unstyled", "mb-3"], ["data-target", "#show-user-modal", "data-toggle", "modal", 1, "btn", "bg-primary-light", "rounded-circle", "iq-card-icon-small", "mr-4", 3, "click"], [1, "ri-user-search-fill", "m-0"], ["data-target", "#edit-user-modal", "data-toggle", "modal", 1, "btn", "bg-warning-light", "rounded-circle", "iq-card-icon-small", "mr-4", 3, "click"], [1, "ri-user-settings-line", "m-0"], ["data-target", "#deleteUser", "data-toggle", "modal", 1, "btn", "bg-secondary-light", "rounded-circle", "iq-card-icon-small", 3, "click"], [1, "ri-user-unfollow-line", "m-0"], [1, "invalid-feedback"], [4, "ngIf"]], template: function (t, e) { 1 & t && (Gr(0, "div", 0), Gr(1, "div", 1), Gr(2, "div", 2), Gr(3, "div", 3), Gr(4, "div", 4), Gr(5, "div", 5), Gr(6, "h5"), xo(7, "Employees"), Zr(), Gr(8, "div", 6), Gr(9, "a", 7), xo(10, "New Employee"), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Gr(11, "div", 8), Gr(12, "div", 1), zr(13, FP, 20, 3, "div", 9), Zr(), Zr(), Zr(), Gr(14, "div", 10), Gr(15, "div", 11), Gr(16, "div", 12), Gr(17, "div", 13), Gr(18, "h3", 14), xo(19, "New Employee"), Zr(), Zr(), Gr(20, "div", 15), Gr(21, "form", 16), Gr(22, "div", 1), Gr(23, "div", 2), Gr(24, "div", 17), Gr(25, "label", 18), xo(26, "Full Name"), Zr(), Kr(27, "input", 19), zr(28, BP, 4, 3, "div", 20), zr(29, HP, 2, 0, "div", 20), Zr(), Zr(), Gr(30, "div", 21), Gr(31, "div", 17), Gr(32, "label", 18), xo(33, "Phone Number"), Zr(), Kr(34, "input", 22), zr(35, WP, 4, 3, "div", 20), zr(36, qP, 2, 0, "div", 20), Zr(), Zr(), Gr(37, "div", 21), Gr(38, "div", 17), Gr(39, "label", 18), xo(40, "Email"), Zr(), Kr(41, "input", 23), zr(42, GP, 2, 0, "div", 20), zr(43, ZP, 2, 0, "div", 20), Zr(), Zr(), Gr(44, "div", 21), Gr(45, "div", 17), Gr(46, "label", 18), xo(47, "Login"), Zr(), Kr(48, "input", 24), zr(49, XP, 4, 3, "div", 20), Zr(), Zr(), Gr(50, "div", 21), Gr(51, "div", 17), Gr(52, "label", 18), xo(53, "Password"), Zr(), Kr(54, "input", 25), zr(55, iD, 4, 3, "div", 20), Zr(), Zr(), Gr(56, "div", 2), Gr(57, "div", 17), Gr(58, "label", 18), xo(59, "Role"), Zr(), Gr(60, "select", 26), Jr("change", function (t) { return e.affecterRole(t) }), Gr(61, "option"), xo(62, "Role"), Zr(), Gr(63, "option"), xo(64, "Designer"), Zr(), Gr(65, "option"), xo(66, "Developer"), Zr(), Gr(67, "option"), xo(68, "Manager"), Zr(), Gr(69, "option"), xo(70, "BDE"), Zr(), Gr(71, "option"), xo(72, "SEO"), Zr(), Zr(), Zr(), Zr(), Gr(73, "div", 2), Gr(74, "div", 27), Gr(75, "button", 28), Jr("click", function () { return e.onSubmit() }), xo(76, "Save"), Zr(), Gr(77, "button", 29), Jr("click", function () { return e.onClear() }), xo(78, "Cancel"), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Gr(79, "div", 30), Gr(80, "div", 11), Gr(81, "div", 12), Gr(82, "div", 13), Gr(83, "h3", 31), xo(84, "Edit Employee"), Zr(), Zr(), Gr(85, "div", 15), Gr(86, "form", 16), Gr(87, "div", 1), Gr(88, "div", 2), Gr(89, "div", 17), Gr(90, "label", 18), xo(91, "Full Name"), Zr(), Kr(92, "input", 32), zr(93, oD, 4, 3, "div", 20), zr(94, aD, 2, 0, "div", 20), Zr(), Zr(), Gr(95, "div", 21), Gr(96, "div", 17), Gr(97, "label", 18), xo(98, "Phone Number"), Zr(), Kr(99, "input", 33), zr(100, uD, 4, 3, "div", 20), zr(101, dD, 2, 0, "div", 20), Zr(), Zr(), Gr(102, "div", 21), Gr(103, "div", 17), Gr(104, "label", 18), xo(105, "Email"), Zr(), Kr(106, "input", 34), zr(107, pD, 2, 0, "div", 20), zr(108, fD, 2, 0, "div", 20), Zr(), Zr(), Gr(109, "div", 21), Gr(110, "div", 17), Gr(111, "label", 18), xo(112, "Login"), Zr(), Kr(113, "input", 35), zr(114, vD, 4, 3, "div", 20), Zr(), Zr(), Gr(115, "div", 21), Gr(116, "div", 17), Gr(117, "label", 18), xo(118, "Password"), Zr(), Kr(119, "input", 36), zr(120, xD, 4, 3, "div", 20), Zr(), Zr(), Gr(121, "div", 2), Gr(122, "div", 17), Gr(123, "label", 18), xo(124, "Role"), Zr(), Gr(125, "select", 26), Jr("change", function (t) { return e.affecterRole(t) }), Gr(126, "option"), xo(127, "Role"), Zr(), Gr(128, "option"), xo(129, "Designer"), Zr(), Gr(130, "option"), xo(131, "Developer"), Zr(), Gr(132, "option"), xo(133, "Manager"), Zr(), Gr(134, "option"), xo(135, "BDE"), Zr(), Gr(136, "option"), xo(137, "SEO"), Zr(), Zr(), Zr(), Zr(), Gr(138, "div", 2), Gr(139, "div", 27), Gr(140, "button", 28), Jr("click", function () { return e.editUser(), e.onClear() }), xo(141, "Save"), Zr(), Gr(142, "button", 29), Jr("click", function () { return e.onClear() }), xo(143, "Cancel"), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Gr(144, "div", 37), Gr(145, "div", 11), Gr(146, "div", 12), Gr(147, "div", 13), Gr(148, "h3", 31), xo(149, "Details Employee"), Zr(), Zr(), Gr(150, "div", 15), Gr(151, "form", 16), Gr(152, "div", 1), Gr(153, "div", 2), Gr(154, "div", 17), Gr(155, "label", 18), xo(156, "Full Name"), Zr(), Kr(157, "input", 38), Zr(), Zr(), Gr(158, "div", 21), Gr(159, "div", 17), Gr(160, "label", 18), xo(161, "Phone Number"), Zr(), Kr(162, "input", 38), Zr(), Zr(), Gr(163, "div", 21), Gr(164, "div", 17), Gr(165, "label", 18), xo(166, "Email"), Zr(), Kr(167, "input", 38), Zr(), Zr(), Gr(168, "div", 21), Gr(169, "div", 17), Gr(170, "label", 18), xo(171, "Login"), Zr(), Kr(172, "input", 38), Zr(), Zr(), Gr(173, "div", 21), Gr(174, "div", 17), Gr(175, "label", 18), xo(176, "Password"), Zr(), Kr(177, "input", 39), Zr(), Zr(), Gr(178, "div", 2), Gr(179, "div", 17), Gr(180, "label", 18), xo(181, "Role"), Zr(), Kr(182, "input", 40), Zr(), Zr(), Gr(183, "div", 2), Gr(184, "div", 27), Gr(185, "button", 29), Jr("click", function () { return e.onClear() }), xo(186, "Close"), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Gr(187, "div", 41), Gr(188, "div", 11), Gr(189, "div", 12), Gr(190, "div", 13), Gr(191, "h3", 31), xo(192, "Delete Employee"), Zr(), Zr(), Gr(193, "div", 15), Gr(194, "div", 1), Gr(195, "div", 2), Gr(196, "div", 17), Gr(197, "label", 42), xo(198, "Are you sure you want to delete this member ?"), Zr(), Zr(), Zr(), Gr(199, "div", 2), Gr(200, "div", 27), Gr(201, "div", 43), Jr("click", function () { return e.deleteUser(e.member.id), e.onClear() }), xo(202, "Yes"), Zr(), Gr(203, "div", 44), xo(204, "No"), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr(), Zr()), 2 & t && (vs(13), Wr("ngForOf", e.listMembers), vs(8), Wr("formGroup", e.formService.formGroupAddEmp), vs(6), Wr("ngClass", Ka(41, SD, e.formService.nameEmp && e.formService.nameEmp.errors && e.formService.nameEmp.touched)), vs(1), Wr("ngIf", e.formService.nameEmp && e.formService.nameEmp.errors), vs(1), Wr("ngIf", e.formService.nameEmp && e.formService.nameEmp.hasError("pattern")), vs(5), Wr("ngClass", Ka(43, SD, e.formService.phoneEmp && e.formService.phoneEmp.errors && e.formService.phoneEmp.touched)), vs(1), Wr("ngIf", e.formService.phoneEmp && e.formService.phoneEmp.errors), vs(1), Wr("ngIf", e.formService.phoneEmp && e.formService.phoneEmp.hasError("pattern")), vs(5), Wr("ngClass", Ka(45, SD, e.formService.emailEmp && e.formService.emailEmp.errors && e.formService.emailEmp.touched)), vs(1), Wr("ngIf", e.formService.emailEmp && e.formService.emailEmp.hasError("required")), vs(1), Wr("ngIf", e.formService.emailEmp && e.formService.emailEmp.hasError("email")), vs(5), Wr("ngClass", Ka(47, SD, e.formService.usernameEmp && e.formService.usernameEmp.errors && e.formService.usernameEmp.touched)), vs(1), Wr("ngIf", e.formService.usernameEmp && e.formService.usernameEmp.errors), vs(5), Wr("ngClass", Ka(49, SD, e.formService.passwordEmp && e.formService.passwordEmp.errors && e.formService.passwordEmp.touched)), vs(1), Wr("ngIf", e.formService.passwordEmp && e.formService.passwordEmp.errors), vs(31), Wr("formGroup", e.formService.formGroupAddEmp), vs(6), Wr("value", e.member.fullname)("ngClass", Ka(51, SD, e.formService.nameEmp && e.formService.nameEmp.errors && e.formService.nameEmp.touched)), vs(1), Wr("ngIf", e.formService.nameEmp && e.formService.nameEmp.errors), vs(1), Wr("ngIf", e.formService.nameEmp && e.formService.nameEmp.hasError("pattern")), vs(5), Wr("value", e.member.phone)("ngClass", Ka(53, SD, e.formService.phoneEmp && e.formService.phoneEmp.errors && e.formService.phoneEmp.touched)), vs(1), Wr("ngIf", e.formService.phoneEmp && e.formService.phoneEmp.errors), vs(1), Wr("ngIf", e.formService.phoneEmp && e.formService.phoneEmp.hasError("pattern")), vs(5), Wr("value", e.member.email)("ngClass", Ka(55, SD, e.formService.emailEmp && e.formService.emailEmp.errors && e.formService.emailEmp.touched)), vs(1), Wr("ngIf", e.formService.emailEmp && e.formService.emailEmp.hasError("required")), vs(1), Wr("ngIf", e.formService.emailEmp && e.formService.emailEmp.hasError("email")), vs(5), Wr("value", e.member.username)("ngClass", Ka(57, SD, e.formService.usernameEmp && e.formService.usernameEmp.errors && e.formService.usernameEmp.touched)), vs(1), Wr("ngIf", e.formService.usernameEmp && e.formService.usernameEmp.errors), vs(5), Wr("value", e.member.password)("ngClass", Ka(59, SD, e.formService.passwordEmp && e.formService.passwordEmp.errors && e.formService.passwordEmp.touched)), vs(1), Wr("ngIf", e.formService.passwordEmp && e.formService.passwordEmp.errors), vs(31), Wr("formGroup", e.formService.formGroupAddEmp), vs(6), Wr("value", e.member.fullname), vs(5), Wr("value", e.member.phone), vs(5), Wr("value", e.member.email), vs(5), Wr("value", e.member.username), vs(5), Wr("value", e.member.password), vs(5), Wr("value", e.member.role)) }, directives: [zc, Ig, ig, jg, Of, eg, Bg, Bc, Uc, Ug, Zg], styles: [""] }), t })() }] }, { path: "homeUser", component: Rv, children: [{ path: "DashbordUser", component: Gb }, { path: "listProjetUser", component: Mv }, { path: "listTasksParProject/:id", component: Nb }, { path: "listAllTasks", component: qb }] }], CD = { onSameUrlNavigation: "reload", useHash: !0 }; let ED = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Gt({ type: t }), t.\u0275inj = pt({ imports: [[df.forRoot(kD, CD)], df] }), t })(), TD = (() => { class t { constructor() { this.title = "GestionDeTaches" } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = $t({ type: t, selectors: [["app-root"]], decls: 1, vars: 0, template: function (t, e) { 1 & t && Kr(0, "router-outlet") }, directives: [ef], styles: [""] }), t })(); class PD { } const DD = "*"; function AD(t, e) { return { type: 7, name: t, definitions: e, options: {} } } function OD(t, e = null) { return { type: 4, styles: e, timings: t } } function RD(t, e = null) { return { type: 2, steps: t, options: e } } function MD(t) { return { type: 6, styles: t, offset: null } } function ID(t, e, i) { return { type: 0, name: t, styles: e, options: i } } function LD(t, e, i = null) { return { type: 1, expr: t, animation: e, options: i } } function FD(t) { Promise.resolve(null).then(t) } class ND { constructor(t = 0, e = 0) { this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._started = !1, this._destroyed = !1, this._finished = !1, this._position = 0, this.parentPlayer = null, this.totalTime = t + e } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(t => t()), this._onDoneFns = []) } onStart(t) { this._onStartFns.push(t) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } hasStarted() { return this._started } init() { } play() { this.hasStarted() || (this._onStart(), this.triggerMicrotask()), this._started = !0 } triggerMicrotask() { FD(() => this._onFinish()) } _onStart() { this._onStartFns.forEach(t => t()), this._onStartFns = [] } pause() { } restart() { } finish() { this._onFinish() } destroy() { this._destroyed || (this._destroyed = !0, this.hasStarted() || this._onStart(), this.finish(), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } reset() { this._started = !1 } setPosition(t) { this._position = this.totalTime ? t * this.totalTime : 1 } getPosition() { return this.totalTime ? this._position / this.totalTime : 1 } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns; e.forEach(t => t()), e.length = 0 } } class jD { constructor(t) { this._onDoneFns = [], this._onStartFns = [], this._finished = !1, this._started = !1, this._destroyed = !1, this._onDestroyFns = [], this.parentPlayer = null, this.totalTime = 0, this.players = t; let e = 0, i = 0, n = 0; const s = this.players.length; 0 == s ? FD(() => this._onFinish()) : this.players.forEach(t => { t.onDone(() => { ++e == s && this._onFinish() }), t.onDestroy(() => { ++i == s && this._onDestroy() }), t.onStart(() => { ++n == s && this._onStart() }) }), this.totalTime = this.players.reduce((t, e) => Math.max(t, e.totalTime), 0) } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(t => t()), this._onDoneFns = []) } init() { this.players.forEach(t => t.init()) } onStart(t) { this._onStartFns.push(t) } _onStart() { this.hasStarted() || (this._started = !0, this._onStartFns.forEach(t => t()), this._onStartFns = []) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } hasStarted() { return this._started } play() { this.parentPlayer || this.init(), this._onStart(), this.players.forEach(t => t.play()) } pause() { this.players.forEach(t => t.pause()) } restart() { this.players.forEach(t => t.restart()) } finish() { this._onFinish(), this.players.forEach(t => t.finish()) } destroy() { this._onDestroy() } _onDestroy() { this._destroyed || (this._destroyed = !0, this._onFinish(), this.players.forEach(t => t.destroy()), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } reset() { this.players.forEach(t => t.reset()), this._destroyed = !1, this._finished = !1, this._started = !1 } setPosition(t) { const e = t * this.totalTime; this.players.forEach(t => { const i = t.totalTime ? Math.min(1, e / t.totalTime) : 1; t.setPosition(i) }) } getPosition() { const t = this.players.reduce((t, e) => null === t || e.totalTime > t.totalTime ? e : t, null); return null != t ? t.getPosition() : 0 } beforeDestroy() { this.players.forEach(t => { t.beforeDestroy && t.beforeDestroy() }) } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns; e.forEach(t => t()), e.length = 0 } } function VD() { return "undefined" != typeof window && void 0 !== window.document } function BD() { return "undefined" != typeof process && "[object process]" === {}.toString.call(process) } function HD(t) { switch (t.length) { case 0: return new ND; case 1: return t[0]; default: return new jD(t) } } function zD(t, e, i, n, s = {}, r = {}) { const o = [], a = []; let l = -1, c = null; if (n.forEach(t => { const i = t.offset, n = i == l, h = n && c || {}; Object.keys(t).forEach(i => { let n = i, a = t[i]; if ("offset" !== i) switch (n = e.normalizePropertyName(n, o), a) { case "!": a = s[i]; break; case DD: a = r[i]; break; default: a = e.normalizeStyleValue(i, n, a, o) }h[n] = a }), n || a.push(h), c = h, l = i }), o.length) { const t = "\n - "; throw new Error(`Unable to animate due to the following errors:${t}${o.join(t)}`) } return a } function $D(t, e, i, n) { switch (e) { case "start": t.onStart(() => n(i && UD(i, "start", t))); break; case "done": t.onDone(() => n(i && UD(i, "done", t))); break; case "destroy": t.onDestroy(() => n(i && UD(i, "destroy", t))) } } function UD(t, e, i) { const n = i.totalTime, s = WD(t.element, t.triggerName, t.fromState, t.toState, e || t.phaseName, null == n ? t.totalTime : n, !!i.disabled), r = t._data; return null != r && (s._data = r), s } function WD(t, e, i, n, s = "", r = 0, o) { return { element: t, triggerName: e, fromState: i, toState: n, phaseName: s, totalTime: r, disabled: !!o } } function qD(t, e, i) { let n; return t instanceof Map ? (n = t.get(e), n || t.set(e, n = i)) : (n = t[e], n || (n = t[e] = i)), n } function GD(t) { const e = t.indexOf(":"); return [t.substring(1, e), t.substr(e + 1)] } let ZD = (t, e) => !1, KD = (t, e) => !1, YD = (t, e, i) => []; const QD = BD(); (QD || "undefined" != typeof Element) && (ZD = VD() ? (t, e) => { for (; e && e !== document.documentElement;) { if (e === t) return !0; e = e.parentNode || e.host } return !1 } : (t, e) => t.contains(e), KD = (() => { if (QD || Element.prototype.matches) return (t, e) => t.matches(e); { const t = Element.prototype, e = t.matchesSelector || t.mozMatchesSelector || t.msMatchesSelector || t.oMatchesSelector || t.webkitMatchesSelector; return e ? (t, i) => e.apply(t, [i]) : KD } })(), YD = (t, e, i) => { let n = []; if (i) { const i = t.querySelectorAll(e); for (let t = 0; t < i.length; t++)n.push(i[t]) } else { const i = t.querySelector(e); i && n.push(i) } return n }); let XD = null, JD = !1; function tA(t) { XD || (XD = ("undefined" != typeof document ? document.body : null) || {}, JD = !!XD.style && "WebkitAppearance" in XD.style); let e = !0; return XD.style && !function (t) { return "ebkit" == t.substring(1, 6) }(t) && (e = t in XD.style, !e && JD) && (e = "Webkit" + t.charAt(0).toUpperCase() + t.substr(1) in XD.style), e } const eA = KD, iA = ZD, nA = YD; function sA(t) { const e = {}; return Object.keys(t).forEach(i => { const n = i.replace(/([a-z])([A-Z])/g, "$1-$2"); e[n] = t[i] }), e } let rA = (() => { class t { validateStyleProperty(t) { return tA(t) } matchesElement(t, e) { return eA(t, e) } containsElement(t, e) { return iA(t, e) } query(t, e, i) { return nA(t, e, i) } computeStyle(t, e, i) { return i || "" } animate(t, e, i, n, s, r = [], o) { return new ND(i, n) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), oA = (() => { class t { } return t.NOOP = new rA, t })(); const aA = "ng-enter", lA = "ng-leave", cA = "ng-trigger", hA = ".ng-trigger", uA = "ng-animating", dA = ".ng-animating"; function pA(t) { if ("number" == typeof t) return t; const e = t.match(/^(-?[\.\d]+)(m?s)/); return !e || e.length < 2 ? 0 : fA(parseFloat(e[1]), e[2]) } function fA(t, e) { switch (e) { case "s": return 1e3 * t; default: return t } } function gA(t, e, i) { return t.hasOwnProperty("duration") ? t : function (t, e, i) { let n, s = 0, r = ""; if ("string" == typeof t) { const i = t.match(/^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i); if (null === i) return e.push(`The provided timing value "${t}" is invalid.`), { duration: 0, delay: 0, easing: "" }; n = fA(parseFloat(i[1]), i[2]); const o = i[3]; null != o && (s = fA(parseFloat(o), i[4])); const a = i[5]; a && (r = a) } else n = t; if (!i) { let i = !1, r = e.length; n < 0 && (e.push("Duration values below 0 are not allowed for this animation step."), i = !0), s < 0 && (e.push("Delay values below 0 are not allowed for this animation step."), i = !0), i && e.splice(r, 0, `The provided timing value "${t}" is invalid.`) } return { duration: n, delay: s, easing: r } }(t, e, i) } function mA(t, e = {}) { return Object.keys(t).forEach(i => { e[i] = t[i] }), e } function _A(t, e, i = {}) { if (e) for (let n in t) i[n] = t[n]; else mA(t, i); return i } function vA(t, e, i) { return i ? e + ":" + i + ";" : "" } function yA(t) { let e = ""; for (let i = 0; i < t.style.length; i++) { const n = t.style.item(i); e += vA(0, n, t.style.getPropertyValue(n)) } for (const i in t.style) t.style.hasOwnProperty(i) && !i.startsWith("_") && (e += vA(0, i.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(), t.style[i])); t.setAttribute("style", e) } function bA(t, e, i) { t.style && (Object.keys(e).forEach(n => { const s = PA(n); i && !i.hasOwnProperty(n) && (i[n] = t.style[s]), t.style[s] = e[n] }), BD() && yA(t)) } function wA(t, e) { t.style && (Object.keys(e).forEach(e => { const i = PA(e); t.style[i] = "" }), BD() && yA(t)) } function xA(t) { return Array.isArray(t) ? 1 == t.length ? t[0] : RD(t) : t } const SA = new RegExp("{{\\s*(.+?)\\s*}}", "g"); function kA(t) { let e = []; if ("string" == typeof t) { let i; for (; i = SA.exec(t);)e.push(i[1]); SA.lastIndex = 0 } return e } function CA(t, e, i) { const n = t.toString(), s = n.replace(SA, (t, n) => { let s = e[n]; return e.hasOwnProperty(n) || (i.push(`Please provide a value for the animation param ${n}`), s = ""), s.toString() }); return s == n ? t : s } function EA(t) { const e = []; let i = t.next(); for (; !i.done;)e.push(i.value), i = t.next(); return e } const TA = /-+([a-z0-9])/g; function PA(t) { return t.replace(TA, (...t) => t[1].toUpperCase()) } function DA(t, e) { return 0 === t || 0 === e } function AA(t, e, i) { const n = Object.keys(i); if (n.length && e.length) { let r = e[0], o = []; if (n.forEach(t => { r.hasOwnProperty(t) || o.push(t), r[t] = i[t] }), o.length) for (var s = 1; s < e.length; s++) { let i = e[s]; o.forEach(function (e) { i[e] = RA(t, e) }) } } return e } function OA(t, e, i) { switch (e.type) { case 7: return t.visitTrigger(e, i); case 0: return t.visitState(e, i); case 1: return t.visitTransition(e, i); case 2: return t.visitSequence(e, i); case 3: return t.visitGroup(e, i); case 4: return t.visitAnimate(e, i); case 5: return t.visitKeyframes(e, i); case 6: return t.visitStyle(e, i); case 8: return t.visitReference(e, i); case 9: return t.visitAnimateChild(e, i); case 10: return t.visitAnimateRef(e, i); case 11: return t.visitQuery(e, i); case 12: return t.visitStagger(e, i); default: throw new Error(`Unable to resolve animation metadata node #${e.type}`) } } function RA(t, e) { return window.getComputedStyle(t)[e] } const MA = "*"; function IA(t, e) { const i = []; return "string" == typeof t ? t.split(/\s*,\s*/).forEach(t => function (t, e, i) { if (":" == t[0]) { const n = function (t, e) { switch (t) { case ":enter": return "void => *"; case ":leave": return "* => void"; case ":increment": return (t, e) => parseFloat(e) > parseFloat(t); case ":decrement": return (t, e) => parseFloat(e) < parseFloat(t); default: return e.push(`The transition alias value "${t}" is not supported`), "* => *" } }(t, i); if ("function" == typeof n) return void e.push(n); t = n } const n = t.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/); if (null == n || n.length < 4) return i.push(`The provided transition expression "${t}" is not supported`), e; const s = n[1], r = n[2], o = n[3]; e.push(NA(s, o)), "<" != r[0] || s == MA && o == MA || e.push(NA(o, s)) }(t, i, e)) : i.push(t), i } const LA = new Set(["true", "1"]), FA = new Set(["false", "0"]); function NA(t, e) { const i = LA.has(t) || FA.has(t), n = LA.has(e) || FA.has(e); return (s, r) => { let o = t == MA || t == s, a = e == MA || e == r; return !o && i && "boolean" == typeof s && (o = s ? LA.has(t) : FA.has(t)), !a && n && "boolean" == typeof r && (a = r ? LA.has(e) : FA.has(e)), o && a } } const jA = new RegExp("s*:selfs*,?", "g"); function VA(t, e, i) { return new BA(t).build(e, i) } class BA { constructor(t) { this._driver = t } build(t, e) { const i = new HA(e); return this._resetContextStyleTimingState(i), OA(this, xA(t), i) } _resetContextStyleTimingState(t) { t.currentQuerySelector = "", t.collectedStyles = {}, t.collectedStyles[""] = {}, t.currentTime = 0 } visitTrigger(t, e) { let i = e.queryCount = 0, n = e.depCount = 0; const s = [], r = []; return "@" == t.name.charAt(0) && e.errors.push("animation triggers cannot be prefixed with an `@` sign (e.g. trigger('@foo', [...]))"), t.definitions.forEach(t => { if (this._resetContextStyleTimingState(e), 0 == t.type) { const i = t, n = i.name; n.toString().split(/\s*,\s*/).forEach(t => { i.name = t, s.push(this.visitState(i, e)) }), i.name = n } else if (1 == t.type) { const s = this.visitTransition(t, e); i += s.queryCount, n += s.depCount, r.push(s) } else e.errors.push("only state() and transition() definitions can sit inside of a trigger()") }), { type: 7, name: t.name, states: s, transitions: r, queryCount: i, depCount: n, options: null } } visitState(t, e) { const i = this.visitStyle(t.styles, e), n = t.options && t.options.params || null; if (i.containsDynamicStyles) { const s = new Set, r = n || {}; if (i.styles.forEach(t => { if (zA(t)) { const e = t; Object.keys(e).forEach(t => { kA(e[t]).forEach(t => { r.hasOwnProperty(t) || s.add(t) }) }) } }), s.size) { const i = EA(s.values()); e.errors.push(`state("${t.name}", ...) must define default values for all the following style substitutions: ${i.join(", ")}`) } } return { type: 0, name: t.name, style: i, options: n ? { params: n } : null } } visitTransition(t, e) { e.queryCount = 0, e.depCount = 0; const i = OA(this, xA(t.animation), e); return { type: 1, matchers: IA(t.expr, e.errors), animation: i, queryCount: e.queryCount, depCount: e.depCount, options: $A(t.options) } } visitSequence(t, e) { return { type: 2, steps: t.steps.map(t => OA(this, t, e)), options: $A(t.options) } } visitGroup(t, e) { const i = e.currentTime; let n = 0; const s = t.steps.map(t => { e.currentTime = i; const s = OA(this, t, e); return n = Math.max(n, e.currentTime), s }); return e.currentTime = n, { type: 3, steps: s, options: $A(t.options) } } visitAnimate(t, e) { const i = function (t, e) { let i = null; if (t.hasOwnProperty("duration")) i = t; else if ("number" == typeof t) return UA(gA(t, e).duration, 0, ""); const n = t; if (n.split(/\s+/).some(t => "{" == t.charAt(0) && "{" == t.charAt(1))) { const t = UA(0, 0, ""); return t.dynamic = !0, t.strValue = n, t } return i = i || gA(n, e), UA(i.duration, i.delay, i.easing) }(t.timings, e.errors); let n; e.currentAnimateTimings = i; let s = t.styles ? t.styles : MD({}); if (5 == s.type) n = this.visitKeyframes(s, e); else { let s = t.styles, r = !1; if (!s) { r = !0; const t = {}; i.easing && (t.easing = i.easing), s = MD(t) } e.currentTime += i.duration + i.delay; const o = this.visitStyle(s, e); o.isEmptyStep = r, n = o } return e.currentAnimateTimings = null, { type: 4, timings: i, style: n, options: null } } visitStyle(t, e) { const i = this._makeStyleAst(t, e); return this._validateStyleAst(i, e), i } _makeStyleAst(t, e) { const i = []; Array.isArray(t.styles) ? t.styles.forEach(t => { "string" == typeof t ? t == DD ? i.push(t) : e.errors.push(`The provided style string value ${t} is not allowed.`) : i.push(t) }) : i.push(t.styles); let n = !1, s = null; return i.forEach(t => { if (zA(t)) { const e = t, i = e.easing; if (i && (s = i, delete e.easing), !n) for (let t in e) if (e[t].toString().indexOf("{{") >= 0) { n = !0; break } } }), { type: 6, styles: i, easing: s, offset: t.offset, containsDynamicStyles: n, options: null } } _validateStyleAst(t, e) { const i = e.currentAnimateTimings; let n = e.currentTime, s = e.currentTime; i && s > 0 && (s -= i.duration + i.delay), t.styles.forEach(t => { "string" != typeof t && Object.keys(t).forEach(i => { if (!this._driver.validateStyleProperty(i)) return void e.errors.push(`The provided animation property "${i}" is not a supported CSS property for animations`); const r = e.collectedStyles[e.currentQuerySelector], o = r[i]; let a = !0; o && (s != n && s >= o.startTime && n <= o.endTime && (e.errors.push(`The CSS property "${i}" that exists between the times of "${o.startTime}ms" and "${o.endTime}ms" is also being animated in a parallel animation between the times of "${s}ms" and "${n}ms"`), a = !1), s = o.startTime), a && (r[i] = { startTime: s, endTime: n }), e.options && function (t, e, i) { const n = e.params || {}, s = kA(t); s.length && s.forEach(t => { n.hasOwnProperty(t) || i.push(`Unable to resolve the local animation param ${t} in the given list of values`) }) }(t[i], e.options, e.errors) }) }) } visitKeyframes(t, e) { const i = { type: 5, styles: [], options: null }; if (!e.currentAnimateTimings) return e.errors.push("keyframes() must be placed inside of a call to animate()"), i; let n = 0; const s = []; let r = !1, o = !1, a = 0; const l = t.steps.map(t => { const i = this._makeStyleAst(t, e); let l = null != i.offset ? i.offset : function (t) { if ("string" == typeof t) return null; let e = null; if (Array.isArray(t)) t.forEach(t => { if (zA(t) && t.hasOwnProperty("offset")) { const i = t; e = parseFloat(i.offset), delete i.offset } }); else if (zA(t) && t.hasOwnProperty("offset")) { const i = t; e = parseFloat(i.offset), delete i.offset } return e }(i.styles), c = 0; return null != l && (n++, c = i.offset = l), o = o || c < 0 || c > 1, r = r || c < a, a = c, s.push(c), i }); o && e.errors.push("Please ensure that all keyframe offsets are between 0 and 1"), r && e.errors.push("Please ensure that all keyframe offsets are in order"); const c = t.steps.length; let h = 0; n > 0 && n < c ? e.errors.push("Not all style() steps within the declared keyframes() contain offsets") : 0 == n && (h = 1 / (c - 1)); const u = c - 1, d = e.currentTime, p = e.currentAnimateTimings, f = p.duration; return l.forEach((t, n) => { const r = h > 0 ? n == u ? 1 : h * n : s[n], o = r * f; e.currentTime = d + p.delay + o, p.duration = o, this._validateStyleAst(t, e), t.offset = r, i.styles.push(t) }), i } visitReference(t, e) { return { type: 8, animation: OA(this, xA(t.animation), e), options: $A(t.options) } } visitAnimateChild(t, e) { return e.depCount++, { type: 9, options: $A(t.options) } } visitAnimateRef(t, e) { return { type: 10, animation: this.visitReference(t.animation, e), options: $A(t.options) } } visitQuery(t, e) { const i = e.currentQuerySelector, n = t.options || {}; e.queryCount++, e.currentQuery = t; const [s, r] = function (t) { const e = !!t.split(/\s*,\s*/).find(t => ":self" == t); return e && (t = t.replace(jA, "")), [t = t.replace(/@\*/g, hA).replace(/@\w+/g, t => ".ng-trigger-" + t.substr(1)).replace(/:animating/g, dA), e] }(t.selector); e.currentQuerySelector = i.length ? i + " " + s : s, qD(e.collectedStyles, e.currentQuerySelector, {}); const o = OA(this, xA(t.animation), e); return e.currentQuery = null, e.currentQuerySelector = i, { type: 11, selector: s, limit: n.limit || 0, optional: !!n.optional, includeSelf: r, animation: o, originalSelector: t.selector, options: $A(t.options) } } visitStagger(t, e) { e.currentQuery || e.errors.push("stagger() can only be used inside of query()"); const i = "full" === t.timings ? { duration: 0, delay: 0, easing: "full" } : gA(t.timings, e.errors, !0); return { type: 12, animation: OA(this, xA(t.animation), e), timings: i, options: null } } } class HA { constructor(t) { this.errors = t, this.queryCount = 0, this.depCount = 0, this.currentTransition = null, this.currentQuery = null, this.currentQuerySelector = null, this.currentAnimateTimings = null, this.currentTime = 0, this.collectedStyles = {}, this.options = null } } function zA(t) { return !Array.isArray(t) && "object" == typeof t } function $A(t) { var e; return t ? (t = mA(t)).params && (t.params = (e = t.params) ? mA(e) : null) : t = {}, t } function UA(t, e, i) { return { duration: t, delay: e, easing: i } } function WA(t, e, i, n, s, r, o = null, a = !1) { return { type: 1, element: t, keyframes: e, preStyleProps: i, postStyleProps: n, duration: s, delay: r, totalTime: s + r, easing: o, subTimeline: a } } class qA { constructor() { this._map = new Map } consume(t) { let e = this._map.get(t); return e ? this._map.delete(t) : e = [], e } append(t, e) { let i = this._map.get(t); i || this._map.set(t, i = []), i.push(...e) } has(t) { return this._map.has(t) } clear() { this._map.clear() } } const GA = new RegExp(":enter", "g"), ZA = new RegExp(":leave", "g"); function KA(t, e, i, n, s, r = {}, o = {}, a, l, c = []) { return (new YA).buildKeyframes(t, e, i, n, s, r, o, a, l, c) } class YA { buildKeyframes(t, e, i, n, s, r, o, a, l, c = []) { l = l || new qA; const h = new XA(t, e, l, n, s, c, []); h.options = a, h.currentTimeline.setStyles([r], null, h.errors, a), OA(this, i, h); const u = h.timelines.filter(t => t.containsAnimation()); if (u.length && Object.keys(o).length) { const t = u[u.length - 1]; t.allowOnlyTimelineStyles() || t.setStyles([o], null, h.errors, a) } return u.length ? u.map(t => t.buildKeyframes()) : [WA(e, [], [], [], 0, 0, "", !1)] } visitTrigger(t, e) { } visitState(t, e) { } visitTransition(t, e) { } visitAnimateChild(t, e) { const i = e.subInstructions.consume(e.element); if (i) { const n = e.createSubContext(t.options), s = e.currentTimeline.currentTime, r = this._visitSubInstructions(i, n, n.options); s != r && e.transformIntoNewTimeline(r) } e.previousNode = t } visitAnimateRef(t, e) { const i = e.createSubContext(t.options); i.transformIntoNewTimeline(), this.visitReference(t.animation, i), e.transformIntoNewTimeline(i.currentTimeline.currentTime), e.previousNode = t } _visitSubInstructions(t, e, i) { let n = e.currentTimeline.currentTime; const s = null != i.duration ? pA(i.duration) : null, r = null != i.delay ? pA(i.delay) : null; return 0 !== s && t.forEach(t => { const i = e.appendInstructionToTimeline(t, s, r); n = Math.max(n, i.duration + i.delay) }), n } visitReference(t, e) { e.updateOptions(t.options, !0), OA(this, t.animation, e), e.previousNode = t } visitSequence(t, e) { const i = e.subContextCount; let n = e; const s = t.options; if (s && (s.params || s.delay) && (n = e.createSubContext(s), n.transformIntoNewTimeline(), null != s.delay)) { 6 == n.previousNode.type && (n.currentTimeline.snapshotCurrentStyles(), n.previousNode = QA); const t = pA(s.delay); n.delayNextStep(t) } t.steps.length && (t.steps.forEach(t => OA(this, t, n)), n.currentTimeline.applyStylesToKeyframe(), n.subContextCount > i && n.transformIntoNewTimeline()), e.previousNode = t } visitGroup(t, e) { const i = []; let n = e.currentTimeline.currentTime; const s = t.options && t.options.delay ? pA(t.options.delay) : 0; t.steps.forEach(r => { const o = e.createSubContext(t.options); s && o.delayNextStep(s), OA(this, r, o), n = Math.max(n, o.currentTimeline.currentTime), i.push(o.currentTimeline) }), i.forEach(t => e.currentTimeline.mergeTimelineCollectedStyles(t)), e.transformIntoNewTimeline(n), e.previousNode = t } _visitTiming(t, e) { if (t.dynamic) { const i = t.strValue; return gA(e.params ? CA(i, e.params, e.errors) : i, e.errors) } return { duration: t.duration, delay: t.delay, easing: t.easing } } visitAnimate(t, e) { const i = e.currentAnimateTimings = this._visitTiming(t.timings, e), n = e.currentTimeline; i.delay && (e.incrementTime(i.delay), n.snapshotCurrentStyles()); const s = t.style; 5 == s.type ? this.visitKeyframes(s, e) : (e.incrementTime(i.duration), this.visitStyle(s, e), n.applyStylesToKeyframe()), e.currentAnimateTimings = null, e.previousNode = t } visitStyle(t, e) { const i = e.currentTimeline, n = e.currentAnimateTimings; !n && i.getCurrentStyleProperties().length && i.forwardFrame(); const s = n && n.easing || t.easing; t.isEmptyStep ? i.applyEmptyStep(s) : i.setStyles(t.styles, s, e.errors, e.options), e.previousNode = t } visitKeyframes(t, e) { const i = e.currentAnimateTimings, n = e.currentTimeline.duration, s = i.duration, r = e.createSubContext().currentTimeline; r.easing = i.easing, t.styles.forEach(t => { r.forwardTime((t.offset || 0) * s), r.setStyles(t.styles, t.easing, e.errors, e.options), r.applyStylesToKeyframe() }), e.currentTimeline.mergeTimelineCollectedStyles(r), e.transformIntoNewTimeline(n + s), e.previousNode = t } visitQuery(t, e) { const i = e.currentTimeline.currentTime, n = t.options || {}, s = n.delay ? pA(n.delay) : 0; s && (6 === e.previousNode.type || 0 == i && e.currentTimeline.getCurrentStyleProperties().length) && (e.currentTimeline.snapshotCurrentStyles(), e.previousNode = QA); let r = i; const o = e.invokeQuery(t.selector, t.originalSelector, t.limit, t.includeSelf, !!n.optional, e.errors); e.currentQueryTotal = o.length; let a = null; o.forEach((i, n) => { e.currentQueryIndex = n; const o = e.createSubContext(t.options, i); s && o.delayNextStep(s), i === e.element && (a = o.currentTimeline), OA(this, t.animation, o), o.currentTimeline.applyStylesToKeyframe(), r = Math.max(r, o.currentTimeline.currentTime) }), e.currentQueryIndex = 0, e.currentQueryTotal = 0, e.transformIntoNewTimeline(r), a && (e.currentTimeline.mergeTimelineCollectedStyles(a), e.currentTimeline.snapshotCurrentStyles()), e.previousNode = t } visitStagger(t, e) { const i = e.parentContext, n = e.currentTimeline, s = t.timings, r = Math.abs(s.duration), o = r * (e.currentQueryTotal - 1); let a = r * e.currentQueryIndex; switch (s.duration < 0 ? "reverse" : s.easing) { case "reverse": a = o - a; break; case "full": a = i.currentStaggerTime }const l = e.currentTimeline; a && l.delayNextStep(a); const c = l.currentTime; OA(this, t.animation, e), e.previousNode = t, i.currentStaggerTime = n.currentTime - c + (n.startTime - i.currentTimeline.startTime) } } const QA = {}; class XA { constructor(t, e, i, n, s, r, o, a) { this._driver = t, this.element = e, this.subInstructions = i, this._enterClassName = n, this._leaveClassName = s, this.errors = r, this.timelines = o, this.parentContext = null, this.currentAnimateTimings = null, this.previousNode = QA, this.subContextCount = 0, this.options = {}, this.currentQueryIndex = 0, this.currentQueryTotal = 0, this.currentStaggerTime = 0, this.currentTimeline = a || new JA(this._driver, e, 0), o.push(this.currentTimeline) } get params() { return this.options.params } updateOptions(t, e) { if (!t) return; const i = t; let n = this.options; null != i.duration && (n.duration = pA(i.duration)), null != i.delay && (n.delay = pA(i.delay)); const s = i.params; if (s) { let t = n.params; t || (t = this.options.params = {}), Object.keys(s).forEach(i => { e && t.hasOwnProperty(i) || (t[i] = CA(s[i], t, this.errors)) }) } } _copyOptions() { const t = {}; if (this.options) { const e = this.options.params; if (e) { const i = t.params = {}; Object.keys(e).forEach(t => { i[t] = e[t] }) } } return t } createSubContext(t = null, e, i) { const n = e || this.element, s = new XA(this._driver, n, this.subInstructions, this._enterClassName, this._leaveClassName, this.errors, this.timelines, this.currentTimeline.fork(n, i || 0)); return s.previousNode = this.previousNode, s.currentAnimateTimings = this.currentAnimateTimings, s.options = this._copyOptions(), s.updateOptions(t), s.currentQueryIndex = this.currentQueryIndex, s.currentQueryTotal = this.currentQueryTotal, s.parentContext = this, this.subContextCount++, s } transformIntoNewTimeline(t) { return this.previousNode = QA, this.currentTimeline = this.currentTimeline.fork(this.element, t), this.timelines.push(this.currentTimeline), this.currentTimeline } appendInstructionToTimeline(t, e, i) { const n = { duration: null != e ? e : t.duration, delay: this.currentTimeline.currentTime + (null != i ? i : 0) + t.delay, easing: "" }, s = new tO(this._driver, t.element, t.keyframes, t.preStyleProps, t.postStyleProps, n, t.stretchStartingKeyframe); return this.timelines.push(s), n } incrementTime(t) { this.currentTimeline.forwardTime(this.currentTimeline.duration + t) } delayNextStep(t) { t > 0 && this.currentTimeline.delayNextStep(t) } invokeQuery(t, e, i, n, s, r) { let o = []; if (n && o.push(this.element), t.length > 0) { t = (t = t.replace(GA, "." + this._enterClassName)).replace(ZA, "." + this._leaveClassName); let e = this._driver.query(this.element, t, 1 != i); 0 !== i && (e = i < 0 ? e.slice(e.length + i, e.length) : e.slice(0, i)), o.push(...e) } return s || 0 != o.length || r.push(`\`query("${e}")\` returned zero elements. (Use \`query("${e}", { optional: true })\` if you wish to allow this.)`), o } } class JA { constructor(t, e, i, n) { this._driver = t, this.element = e, this.startTime = i, this._elementTimelineStylesLookup = n, this.duration = 0, this._previousKeyframe = {}, this._currentKeyframe = {}, this._keyframes = new Map, this._styleSummary = {}, this._pendingStyles = {}, this._backFill = {}, this._currentEmptyStepKeyframe = null, this._elementTimelineStylesLookup || (this._elementTimelineStylesLookup = new Map), this._localTimelineStyles = Object.create(this._backFill, {}), this._globalTimelineStyles = this._elementTimelineStylesLookup.get(e), this._globalTimelineStyles || (this._globalTimelineStyles = this._localTimelineStyles, this._elementTimelineStylesLookup.set(e, this._localTimelineStyles)), this._loadKeyframe() } containsAnimation() { switch (this._keyframes.size) { case 0: return !1; case 1: return this.getCurrentStyleProperties().length > 0; default: return !0 } } getCurrentStyleProperties() { return Object.keys(this._currentKeyframe) } get currentTime() { return this.startTime + this.duration } delayNextStep(t) { const e = 1 == this._keyframes.size && Object.keys(this._pendingStyles).length; this.duration || e ? (this.forwardTime(this.currentTime + t), e && this.snapshotCurrentStyles()) : this.startTime += t } fork(t, e) { return this.applyStylesToKeyframe(), new JA(this._driver, t, e || this.currentTime, this._elementTimelineStylesLookup) } _loadKeyframe() { this._currentKeyframe && (this._previousKeyframe = this._currentKeyframe), this._currentKeyframe = this._keyframes.get(this.duration), this._currentKeyframe || (this._currentKeyframe = Object.create(this._backFill, {}), this._keyframes.set(this.duration, this._currentKeyframe)) } forwardFrame() { this.duration += 1, this._loadKeyframe() } forwardTime(t) { this.applyStylesToKeyframe(), this.duration = t, this._loadKeyframe() } _updateStyle(t, e) { this._localTimelineStyles[t] = e, this._globalTimelineStyles[t] = e, this._styleSummary[t] = { time: this.currentTime, value: e } } allowOnlyTimelineStyles() { return this._currentEmptyStepKeyframe !== this._currentKeyframe } applyEmptyStep(t) { t && (this._previousKeyframe.easing = t), Object.keys(this._globalTimelineStyles).forEach(t => { this._backFill[t] = this._globalTimelineStyles[t] || DD, this._currentKeyframe[t] = DD }), this._currentEmptyStepKeyframe = this._currentKeyframe } setStyles(t, e, i, n) { e && (this._previousKeyframe.easing = e); const s = n && n.params || {}, r = function (t, e) { const i = {}; let n; return t.forEach(t => { "*" === t ? (n = n || Object.keys(e), n.forEach(t => { i[t] = DD })) : _A(t, !1, i) }), i }(t, this._globalTimelineStyles); Object.keys(r).forEach(t => { const e = CA(r[t], s, i); this._pendingStyles[t] = e, this._localTimelineStyles.hasOwnProperty(t) || (this._backFill[t] = this._globalTimelineStyles.hasOwnProperty(t) ? this._globalTimelineStyles[t] : DD), this._updateStyle(t, e) }) } applyStylesToKeyframe() { const t = this._pendingStyles, e = Object.keys(t); 0 != e.length && (this._pendingStyles = {}, e.forEach(e => { this._currentKeyframe[e] = t[e] }), Object.keys(this._localTimelineStyles).forEach(t => { this._currentKeyframe.hasOwnProperty(t) || (this._currentKeyframe[t] = this._localTimelineStyles[t]) })) } snapshotCurrentStyles() { Object.keys(this._localTimelineStyles).forEach(t => { const e = this._localTimelineStyles[t]; this._pendingStyles[t] = e, this._updateStyle(t, e) }) } getFinalKeyframe() { return this._keyframes.get(this.duration) } get properties() { const t = []; for (let e in this._currentKeyframe) t.push(e); return t } mergeTimelineCollectedStyles(t) { Object.keys(t._styleSummary).forEach(e => { const i = this._styleSummary[e], n = t._styleSummary[e]; (!i || n.time > i.time) && this._updateStyle(e, n.value) }) } buildKeyframes() { this.applyStylesToKeyframe(); const t = new Set, e = new Set, i = 1 === this._keyframes.size && 0 === this.duration; let n = []; this._keyframes.forEach((s, r) => { const o = _A(s, !0); Object.keys(o).forEach(i => { const n = o[i]; "!" == n ? t.add(i) : n == DD && e.add(i) }), i || (o.offset = r / this.duration), n.push(o) }); const s = t.size ? EA(t.values()) : [], r = e.size ? EA(e.values()) : []; if (i) { const t = n[0], e = mA(t); t.offset = 0, e.offset = 1, n = [t, e] } return WA(this.element, n, s, r, this.duration, this.startTime, this.easing, !1) } } class tO extends JA { constructor(t, e, i, n, s, r, o = !1) { super(t, e, r.delay), this.element = e, this.keyframes = i, this.preStyleProps = n, this.postStyleProps = s, this._stretchStartingKeyframe = o, this.timings = { duration: r.duration, delay: r.delay, easing: r.easing } } containsAnimation() { return this.keyframes.length > 1 } buildKeyframes() { let t = this.keyframes, { delay: e, duration: i, easing: n } = this.timings; if (this._stretchStartingKeyframe && e) { const s = [], r = i + e, o = e / r, a = _A(t[0], !1); a.offset = 0, s.push(a); const l = _A(t[0], !1); l.offset = eO(o), s.push(l); const c = t.length - 1; for (let n = 1; n <= c; n++) { let o = _A(t[n], !1); o.offset = eO((e + o.offset * i) / r), s.push(o) } i = r, e = 0, n = "", t = s } return WA(this.element, t, this.preStyleProps, this.postStyleProps, i, e, n, !0) } } function eO(t, e = 3) { const i = Math.pow(10, e - 1); return Math.round(t * i) / i } class iO { } class nO extends iO { normalizePropertyName(t, e) { return PA(t) } normalizeStyleValue(t, e, i, n) { let s = ""; const r = i.toString().trim(); if (sO[e] && 0 !== i && "0" !== i) if ("number" == typeof i) s = "px"; else { const e = i.match(/^[+-]?[\d\.]+([a-z]*)$/); e && 0 == e[1].length && n.push(`Please provide a CSS unit value for ${t}:${i}`) } return r + s } } const sO = (() => function (t) { const e = {}; return t.forEach(t => e[t] = !0), e }("width,height,minWidth,minHeight,maxWidth,maxHeight,left,top,bottom,right,fontSize,outlineWidth,outlineOffset,paddingTop,paddingLeft,paddingBottom,paddingRight,marginTop,marginLeft,marginBottom,marginRight,borderRadius,borderWidth,borderTopWidth,borderLeftWidth,borderRightWidth,borderBottomWidth,textIndent,perspective".split(",")))(); function rO(t, e, i, n, s, r, o, a, l, c, h, u, d) { return { type: 0, element: t, triggerName: e, isRemovalTransition: s, fromState: i, fromStyles: r, toState: n, toStyles: o, timelines: a, queriedElements: l, preStyleProps: c, postStyleProps: h, totalTime: u, errors: d } } const oO = {}; class aO { constructor(t, e, i) { this._triggerName = t, this.ast = e, this._stateStyles = i } match(t, e, i, n) { return function (t, e, i, n, s) { return t.some(t => t(e, i, n, s)) }(this.ast.matchers, t, e, i, n) } buildStyles(t, e, i) { const n = this._stateStyles["*"], s = this._stateStyles[t], r = n ? n.buildStyles(e, i) : {}; return s ? s.buildStyles(e, i) : r } build(t, e, i, n, s, r, o, a, l, c) { const h = [], u = this.ast.options && this.ast.options.params || oO, d = this.buildStyles(i, o && o.params || oO, h), p = a && a.params || oO, f = this.buildStyles(n, p, h), g = new Set, m = new Map, _ = new Map, v = "void" === n, y = { params: Object.assign(Object.assign({}, u), p) }, b = c ? [] : KA(t, e, this.ast.animation, s, r, d, f, y, l, h); let w = 0; if (b.forEach(t => { w = Math.max(t.duration + t.delay, w) }), h.length) return rO(e, this._triggerName, i, n, v, d, f, [], [], m, _, w, h); b.forEach(t => { const i = t.element, n = qD(m, i, {}); t.preStyleProps.forEach(t => n[t] = !0); const s = qD(_, i, {}); t.postStyleProps.forEach(t => s[t] = !0), i !== e && g.add(i) }); const x = EA(g.values()); return rO(e, this._triggerName, i, n, v, d, f, b, x, m, _, w) } } class lO { constructor(t, e) { this.styles = t, this.defaultParams = e } buildStyles(t, e) { const i = {}, n = mA(this.defaultParams); return Object.keys(t).forEach(e => { const i = t[e]; null != i && (n[e] = i) }), this.styles.styles.forEach(t => { if ("string" != typeof t) { const s = t; Object.keys(s).forEach(t => { let r = s[t]; r.length > 1 && (r = CA(r, n, e)), i[t] = r }) } }), i } } class cO { constructor(t, e) { this.name = t, this.ast = e, this.transitionFactories = [], this.states = {}, e.states.forEach(t => { this.states[t.name] = new lO(t.style, t.options && t.options.params || {}) }), hO(this.states, "true", "1"), hO(this.states, "false", "0"), e.transitions.forEach(e => { this.transitionFactories.push(new aO(t, e, this.states)) }), this.fallbackTransition = new aO(t, { type: 1, animation: { type: 2, steps: [], options: null }, matchers: [(t, e) => !0], options: null, queryCount: 0, depCount: 0 }, this.states) } get containsQueries() { return this.ast.queryCount > 0 } matchTransition(t, e, i, n) { return this.transitionFactories.find(s => s.match(t, e, i, n)) || null } matchStyles(t, e, i) { return this.fallbackTransition.buildStyles(t, e, i) } } function hO(t, e, i) { t.hasOwnProperty(e) ? t.hasOwnProperty(i) || (t[i] = t[e]) : t.hasOwnProperty(i) && (t[e] = t[i]) } const uO = new qA; class dO { constructor(t, e, i) { this.bodyNode = t, this._driver = e, this._normalizer = i, this._animations = {}, this._playersById = {}, this.players = [] } register(t, e) { const i = [], n = VA(this._driver, e, i); if (i.length) throw new Error(`Unable to build the animation due to the following errors: ${i.join("\n")}`); this._animations[t] = n } _buildPlayer(t, e, i) { const n = t.element, s = zD(0, this._normalizer, 0, t.keyframes, e, i); return this._driver.animate(n, s, t.duration, t.delay, t.easing, [], !0) } create(t, e, i = {}) { const n = [], s = this._animations[t]; let r; const o = new Map; if (s ? (r = KA(this._driver, e, s, aA, lA, {}, {}, i, uO, n), r.forEach(t => { const e = qD(o, t.element, {}); t.postStyleProps.forEach(t => e[t] = null) })) : (n.push("The requested animation doesn't exist or has already been destroyed"), r = []), n.length) throw new Error(`Unable to create the animation due to the following errors: ${n.join("\n")}`); o.forEach((t, e) => { Object.keys(t).forEach(i => { t[i] = this._driver.computeStyle(e, i, DD) }) }); const a = HD(r.map(t => { const e = o.get(t.element); return this._buildPlayer(t, {}, e) })); return this._playersById[t] = a, a.onDestroy(() => this.destroy(t)), this.players.push(a), a } destroy(t) { const e = this._getPlayer(t); e.destroy(), delete this._playersById[t]; const i = this.players.indexOf(e); i >= 0 && this.players.splice(i, 1) } _getPlayer(t) { const e = this._playersById[t]; if (!e) throw new Error(`Unable to find the timeline player referenced by ${t}`); return e } listen(t, e, i, n) { const s = WD(e, "", "", ""); return $D(this._getPlayer(t), i, s, n), () => { } } command(t, e, i, n) { if ("register" == i) return void this.register(t, n[0]); if ("create" == i) return void this.create(t, e, n[0] || {}); const s = this._getPlayer(t); switch (i) { case "play": s.play(); break; case "pause": s.pause(); break; case "reset": s.reset(); break; case "restart": s.restart(); break; case "finish": s.finish(); break; case "init": s.init(); break; case "setPosition": s.setPosition(parseFloat(n[0])); break; case "destroy": this.destroy(t) } } } const pO = "ng-animate-queued", fO = "ng-animate-disabled", gO = ".ng-animate-disabled", mO = [], _O = { namespaceId: "", setForRemoval: !1, setForMove: !1, hasAnimation: !1, removedBeforeQueried: !1 }, vO = { namespaceId: "", setForMove: !1, setForRemoval: !1, hasAnimation: !1, removedBeforeQueried: !0 }; class yO { constructor(t, e = "") { this.namespaceId = e; const i = t && t.hasOwnProperty("value"); if (this.value = null != (n = i ? t.value : t) ? n : null, i) { const e = mA(t); delete e.value, this.options = e } else this.options = {}; var n; this.options.params || (this.options.params = {}) } get params() { return this.options.params } absorbOptions(t) { const e = t.params; if (e) { const t = this.options.params; Object.keys(e).forEach(i => { null == t[i] && (t[i] = e[i]) }) } } } const bO = "void", wO = new yO(bO); class xO { constructor(t, e, i) { this.id = t, this.hostElement = e, this._engine = i, this.players = [], this._triggers = {}, this._queue = [], this._elementListeners = new Map, this._hostClassName = "ng-tns-" + t, DO(e, this._hostClassName) } listen(t, e, i, n) { if (!this._triggers.hasOwnProperty(e)) throw new Error(`Unable to listen on the animation trigger event "${i}" because the animation trigger "${e}" doesn't exist!`); if (null == i || 0 == i.length) throw new Error(`Unable to listen on the animation trigger "${e}" because the provided event is undefined!`); if ("start" != (s = i) && "done" != s) throw new Error(`The provided animation trigger event "${i}" for the animation trigger "${e}" is not supported!`); var s; const r = qD(this._elementListeners, t, []), o = { name: e, phase: i, callback: n }; r.push(o); const a = qD(this._engine.statesByElement, t, {}); return a.hasOwnProperty(e) || (DO(t, cA), DO(t, "ng-trigger-" + e), a[e] = wO), () => { this._engine.afterFlush(() => { const t = r.indexOf(o); t >= 0 && r.splice(t, 1), this._triggers[e] || delete a[e] }) } } register(t, e) { return !this._triggers[t] && (this._triggers[t] = e, !0) } _getTrigger(t) { const e = this._triggers[t]; if (!e) throw new Error(`The provided animation trigger "${t}" has not been registered!`); return e } trigger(t, e, i, n = !0) { const s = this._getTrigger(e), r = new kO(this.id, e, t); let o = this._engine.statesByElement.get(t); o || (DO(t, cA), DO(t, "ng-trigger-" + e), this._engine.statesByElement.set(t, o = {})); let a = o[e]; const l = new yO(i, this.id); if (!(i && i.hasOwnProperty("value")) && a && l.absorbOptions(a.options), o[e] = l, a || (a = wO), l.value !== bO && a.value === l.value) { if (!function (t, e) { const i = Object.keys(t), n = Object.keys(e); if (i.length != n.length) return !1; for (let s = 0; s < i.length; s++) { const n = i[s]; if (!e.hasOwnProperty(n) || t[n] !== e[n]) return !1 } return !0 }(a.params, l.params)) { const e = [], i = s.matchStyles(a.value, a.params, e), n = s.matchStyles(l.value, l.params, e); e.length ? this._engine.reportError(e) : this._engine.afterFlush(() => { wA(t, i), bA(t, n) }) } return } const c = qD(this._engine.playersByElement, t, []); c.forEach(t => { t.namespaceId == this.id && t.triggerName == e && t.queued && t.destroy() }); let h = s.matchTransition(a.value, l.value, t, l.params), u = !1; if (!h) { if (!n) return; h = s.fallbackTransition, u = !0 } return this._engine.totalQueuedPlayers++, this._queue.push({ element: t, triggerName: e, transition: h, fromState: a, toState: l, player: r, isFallbackTransition: u }), u || (DO(t, pO), r.onStart(() => { AO(t, pO) })), r.onDone(() => { let e = this.players.indexOf(r); e >= 0 && this.players.splice(e, 1); const i = this._engine.playersByElement.get(t); if (i) { let t = i.indexOf(r); t >= 0 && i.splice(t, 1) } }), this.players.push(r), c.push(r), r } deregister(t) { delete this._triggers[t], this._engine.statesByElement.forEach((e, i) => { delete e[t] }), this._elementListeners.forEach((e, i) => { this._elementListeners.set(i, e.filter(e => e.name != t)) }) } clearElementCache(t) { this._engine.statesByElement.delete(t), this._elementListeners.delete(t); const e = this._engine.playersByElement.get(t); e && (e.forEach(t => t.destroy()), this._engine.playersByElement.delete(t)) } _signalRemovalForInnerTriggers(t, e) { const i = this._engine.driver.query(t, hA, !0); i.forEach(t => { if (t.__ng_removed) return; const i = this._engine.fetchNamespacesByElement(t); i.size ? i.forEach(i => i.triggerLeaveAnimation(t, e, !1, !0)) : this.clearElementCache(t) }), this._engine.afterFlushAnimationsDone(() => i.forEach(t => this.clearElementCache(t))) } triggerLeaveAnimation(t, e, i, n) { const s = this._engine.statesByElement.get(t); if (s) { const r = []; if (Object.keys(s).forEach(e => { if (this._triggers[e]) { const i = this.trigger(t, e, bO, n); i && r.push(i) } }), r.length) return this._engine.markElementAsRemoved(this.id, t, !0, e), i && HD(r).onDone(() => this._engine.processLeaveNode(t)), !0 } return !1 } prepareLeaveAnimationListeners(t) { const e = this._elementListeners.get(t), i = this._engine.statesByElement.get(t); if (e && i) { const n = new Set; e.forEach(e => { const s = e.name; if (n.has(s)) return; n.add(s); const r = this._triggers[s].fallbackTransition, o = i[s] || wO, a = new yO(bO), l = new kO(this.id, s, t); this._engine.totalQueuedPlayers++, this._queue.push({ element: t, triggerName: s, transition: r, fromState: o, toState: a, player: l, isFallbackTransition: !0 }) }) } } removeNode(t, e) { const i = this._engine; if (t.childElementCount && this._signalRemovalForInnerTriggers(t, e), this.triggerLeaveAnimation(t, e, !0)) return; let n = !1; if (i.totalAnimations) { const e = i.players.length ? i.playersByQueriedElement.get(t) : []; if (e && e.length) n = !0; else { let e = t; for (; e = e.parentNode;)if (i.statesByElement.get(e)) { n = !0; break } } } if (this.prepareLeaveAnimationListeners(t), n) i.markElementAsRemoved(this.id, t, !1, e); else { const n = t.__ng_removed; n && n !== _O || (i.afterFlush(() => this.clearElementCache(t)), i.destroyInnerAnimations(t), i._onRemovalComplete(t, e)) } } insertNode(t, e) { DO(t, this._hostClassName) } drainQueuedTransitions(t) { const e = []; return this._queue.forEach(i => { const n = i.player; if (n.destroyed) return; const s = i.element, r = this._elementListeners.get(s); r && r.forEach(e => { if (e.name == i.triggerName) { const n = WD(s, i.triggerName, i.fromState.value, i.toState.value); n._data = t, $D(i.player, e.phase, n, e.callback) } }), n.markedForDestroy ? this._engine.afterFlush(() => { n.destroy() }) : e.push(i) }), this._queue = [], e.sort((t, e) => { const i = t.transition.ast.depCount, n = e.transition.ast.depCount; return 0 == i || 0 == n ? i - n : this._engine.driver.containsElement(t.element, e.element) ? 1 : -1 }) } destroy(t) { this.players.forEach(t => t.destroy()), this._signalRemovalForInnerTriggers(this.hostElement, t) } elementContainsData(t) { let e = !1; return this._elementListeners.has(t) && (e = !0), e = !!this._queue.find(e => e.element === t) || e, e } } class SO { constructor(t, e, i) { this.bodyNode = t, this.driver = e, this._normalizer = i, this.players = [], this.newHostElements = new Map, this.playersByElement = new Map, this.playersByQueriedElement = new Map, this.statesByElement = new Map, this.disabledNodes = new Set, this.totalAnimations = 0, this.totalQueuedPlayers = 0, this._namespaceLookup = {}, this._namespaceList = [], this._flushFns = [], this._whenQuietFns = [], this.namespacesByHostElement = new Map, this.collectedEnterElements = [], this.collectedLeaveElements = [], this.onRemovalComplete = (t, e) => { } } _onRemovalComplete(t, e) { this.onRemovalComplete(t, e) } get queuedPlayers() { const t = []; return this._namespaceList.forEach(e => { e.players.forEach(e => { e.queued && t.push(e) }) }), t } createNamespace(t, e) { const i = new xO(t, e, this); return this.bodyNode && this.driver.containsElement(this.bodyNode, e) ? this._balanceNamespaceList(i, e) : (this.newHostElements.set(e, i), this.collectEnterElement(e)), this._namespaceLookup[t] = i } _balanceNamespaceList(t, e) { const i = this._namespaceList.length - 1; if (i >= 0) { let n = !1; for (let s = i; s >= 0; s--)if (this.driver.containsElement(this._namespaceList[s].hostElement, e)) { this._namespaceList.splice(s + 1, 0, t), n = !0; break } n || this._namespaceList.splice(0, 0, t) } else this._namespaceList.push(t); return this.namespacesByHostElement.set(e, t), t } register(t, e) { let i = this._namespaceLookup[t]; return i || (i = this.createNamespace(t, e)), i } registerTrigger(t, e, i) { let n = this._namespaceLookup[t]; n && n.register(e, i) && this.totalAnimations++ } destroy(t, e) { if (!t) return; const i = this._fetchNamespace(t); this.afterFlush(() => { this.namespacesByHostElement.delete(i.hostElement), delete this._namespaceLookup[t]; const e = this._namespaceList.indexOf(i); e >= 0 && this._namespaceList.splice(e, 1) }), this.afterFlushAnimationsDone(() => i.destroy(e)) } _fetchNamespace(t) { return this._namespaceLookup[t] } fetchNamespacesByElement(t) { const e = new Set, i = this.statesByElement.get(t); if (i) { const t = Object.keys(i); for (let n = 0; n < t.length; n++) { const s = i[t[n]].namespaceId; if (s) { const t = this._fetchNamespace(s); t && e.add(t) } } } return e } trigger(t, e, i, n) { if (CO(e)) { const s = this._fetchNamespace(t); if (s) return s.trigger(e, i, n), !0 } return !1 } insertNode(t, e, i, n) { if (!CO(e)) return; const s = e.__ng_removed; if (s && s.setForRemoval) { s.setForRemoval = !1, s.setForMove = !0; const t = this.collectedLeaveElements.indexOf(e); t >= 0 && this.collectedLeaveElements.splice(t, 1) } if (t) { const n = this._fetchNamespace(t); n && n.insertNode(e, i) } n && this.collectEnterElement(e) } collectEnterElement(t) { this.collectedEnterElements.push(t) } markElementAsDisabled(t, e) { e ? this.disabledNodes.has(t) || (this.disabledNodes.add(t), DO(t, fO)) : this.disabledNodes.has(t) && (this.disabledNodes.delete(t), AO(t, fO)) } removeNode(t, e, i, n) { if (CO(e)) { const s = t ? this._fetchNamespace(t) : null; if (s ? s.removeNode(e, n) : this.markElementAsRemoved(t, e, !1, n), i) { const i = this.namespacesByHostElement.get(e); i && i.id !== t && i.removeNode(e, n) } } else this._onRemovalComplete(e, n) } markElementAsRemoved(t, e, i, n) { this.collectedLeaveElements.push(e), e.__ng_removed = { namespaceId: t, setForRemoval: n, hasAnimation: i, removedBeforeQueried: !1 } } listen(t, e, i, n, s) { return CO(e) ? this._fetchNamespace(t).listen(e, i, n, s) : () => { } } _buildInstruction(t, e, i, n, s) { return t.transition.build(this.driver, t.element, t.fromState.value, t.toState.value, i, n, t.fromState.options, t.toState.options, e, s) } destroyInnerAnimations(t) { let e = this.driver.query(t, hA, !0); e.forEach(t => this.destroyActiveAnimationsForElement(t)), 0 != this.playersByQueriedElement.size && (e = this.driver.query(t, dA, !0), e.forEach(t => this.finishActiveQueriedAnimationOnElement(t))) } destroyActiveAnimationsForElement(t) { const e = this.playersByElement.get(t); e && e.forEach(t => { t.queued ? t.markedForDestroy = !0 : t.destroy() }) } finishActiveQueriedAnimationOnElement(t) { const e = this.playersByQueriedElement.get(t); e && e.forEach(t => t.finish()) } whenRenderingDone() { return new Promise(t => { if (this.players.length) return HD(this.players).onDone(() => t()); t() }) } processLeaveNode(t) { const e = t.__ng_removed; if (e && e.setForRemoval) { if (t.__ng_removed = _O, e.namespaceId) { this.destroyInnerAnimations(t); const i = this._fetchNamespace(e.namespaceId); i && i.clearElementCache(t) } this._onRemovalComplete(t, e.setForRemoval) } this.driver.matchesElement(t, gO) && this.markElementAsDisabled(t, !1), this.driver.query(t, gO, !0).forEach(t => { this.markElementAsDisabled(t, !1) }) } flush(t = -1) { let e = []; if (this.newHostElements.size && (this.newHostElements.forEach((t, e) => this._balanceNamespaceList(t, e)), this.newHostElements.clear()), this.totalAnimations && this.collectedEnterElements.length) for (let i = 0; i < this.collectedEnterElements.length; i++)DO(this.collectedEnterElements[i], "ng-star-inserted"); if (this._namespaceList.length && (this.totalQueuedPlayers || this.collectedLeaveElements.length)) { const i = []; try { e = this._flushAnimations(i, t) } finally { for (let t = 0; t < i.length; t++)i[t]() } } else for (let i = 0; i < this.collectedLeaveElements.length; i++)this.processLeaveNode(this.collectedLeaveElements[i]); if (this.totalQueuedPlayers = 0, this.collectedEnterElements.length = 0, this.collectedLeaveElements.length = 0, this._flushFns.forEach(t => t()), this._flushFns = [], this._whenQuietFns.length) { const t = this._whenQuietFns; this._whenQuietFns = [], e.length ? HD(e).onDone(() => { t.forEach(t => t()) }) : t.forEach(t => t()) } } reportError(t) { throw new Error(`Unable to process animations due to the following failed trigger transitions\n ${t.join("\n")}`) } _flushAnimations(t, e) { const i = new qA, n = [], s = new Map, r = [], o = new Map, a = new Map, l = new Map, c = new Set; this.disabledNodes.forEach(t => { c.add(t); const e = this.driver.query(t, ".ng-animate-queued", !0); for (let i = 0; i < e.length; i++)c.add(e[i]) }); const h = this.bodyNode, u = Array.from(this.statesByElement.keys()), d = PO(u, this.collectedEnterElements), p = new Map; let f = 0; d.forEach((t, e) => { const i = aA + f++; p.set(e, i), t.forEach(t => DO(t, i)) }); const g = [], m = new Set, _ = new Set; for (let A = 0; A < this.collectedLeaveElements.length; A++) { const t = this.collectedLeaveElements[A], e = t.__ng_removed; e && e.setForRemoval && (g.push(t), m.add(t), e.hasAnimation ? this.driver.query(t, ".ng-star-inserted", !0).forEach(t => m.add(t)) : _.add(t)) } const v = new Map, y = PO(u, Array.from(m)); y.forEach((t, e) => { const i = lA + f++; v.set(e, i), t.forEach(t => DO(t, i)) }), t.push(() => { d.forEach((t, e) => { const i = p.get(e); t.forEach(t => AO(t, i)) }), y.forEach((t, e) => { const i = v.get(e); t.forEach(t => AO(t, i)) }), g.forEach(t => { this.processLeaveNode(t) }) }); const b = [], w = []; for (let A = this._namespaceList.length - 1; A >= 0; A--)this._namespaceList[A].drainQueuedTransitions(e).forEach(t => { const e = t.player, s = t.element; if (b.push(e), this.collectedEnterElements.length) { const t = s.__ng_removed; if (t && t.setForMove) return void e.destroy() } const c = !h || !this.driver.containsElement(h, s), u = v.get(s), d = p.get(s), f = this._buildInstruction(t, i, d, u, c); if (f.errors && f.errors.length) w.push(f); else { if (c) return e.onStart(() => wA(s, f.fromStyles)), e.onDestroy(() => bA(s, f.toStyles)), void n.push(e); if (t.isFallbackTransition) return e.onStart(() => wA(s, f.fromStyles)), e.onDestroy(() => bA(s, f.toStyles)), void n.push(e); f.timelines.forEach(t => t.stretchStartingKeyframe = !0), i.append(s, f.timelines), r.push({ instruction: f, player: e, element: s }), f.queriedElements.forEach(t => qD(o, t, []).push(e)), f.preStyleProps.forEach((t, e) => { const i = Object.keys(t); if (i.length) { let t = a.get(e); t || a.set(e, t = new Set), i.forEach(e => t.add(e)) } }), f.postStyleProps.forEach((t, e) => { const i = Object.keys(t); let n = l.get(e); n || l.set(e, n = new Set), i.forEach(t => n.add(t)) }) } }); if (w.length) { const t = []; w.forEach(e => { t.push(`@${e.triggerName} has failed due to:\n`), e.errors.forEach(e => t.push(`- ${e}\n`)) }), b.forEach(t => t.destroy()), this.reportError(t) } const x = new Map, S = new Map; r.forEach(t => { const e = t.element; i.has(e) && (S.set(e, e), this._beforeAnimationBuild(t.player.namespaceId, t.instruction, x)) }), n.forEach(t => { const e = t.element; this._getPreviousPlayers(e, !1, t.namespaceId, t.triggerName, null).forEach(t => { qD(x, e, []).push(t), t.destroy() }) }); const k = g.filter(t => MO(t, a, l)), C = new Map; TO(C, this.driver, _, l, DD).forEach(t => { MO(t, a, l) && k.push(t) }); const E = new Map; d.forEach((t, e) => { TO(E, this.driver, new Set(t), a, "!") }), k.forEach(t => { const e = C.get(t), i = E.get(t); C.set(t, Object.assign(Object.assign({}, e), i)) }); const T = [], P = [], D = {}; r.forEach(t => { const { element: e, player: r, instruction: o } = t; if (i.has(e)) { if (c.has(e)) return r.onDestroy(() => bA(e, o.toStyles)), r.disabled = !0, r.overrideTotalTime(o.totalTime), void n.push(r); let t = D; if (S.size > 1) { let i = e; const n = []; for (; i = i.parentNode;) { const e = S.get(i); if (e) { t = e; break } n.push(i) } n.forEach(e => S.set(e, t)) } const i = this._buildAnimation(r.namespaceId, o, x, s, E, C); if (r.setRealPlayer(i), t === D) T.push(r); else { const e = this.playersByElement.get(t); e && e.length && (r.parentPlayer = HD(e)), n.push(r) } } else wA(e, o.fromStyles), r.onDestroy(() => bA(e, o.toStyles)), P.push(r), c.has(e) && n.push(r) }), P.forEach(t => { const e = s.get(t.element); if (e && e.length) { const i = HD(e); t.setRealPlayer(i) } }), n.forEach(t => { t.parentPlayer ? t.syncPlayerEvents(t.parentPlayer) : t.destroy() }); for (let A = 0; A < g.length; A++) { const t = g[A], e = t.__ng_removed; if (AO(t, lA), e && e.hasAnimation) continue; let i = []; if (o.size) { let e = o.get(t); e && e.length && i.push(...e); let n = this.driver.query(t, dA, !0); for (let t = 0; t < n.length; t++) { let e = o.get(n[t]); e && e.length && i.push(...e) } } const n = i.filter(t => !t.destroyed); n.length ? OO(this, t, n) : this.processLeaveNode(t) } return g.length = 0, T.forEach(t => { this.players.push(t), t.onDone(() => { t.destroy(); const e = this.players.indexOf(t); this.players.splice(e, 1) }), t.play() }), T } elementContainsData(t, e) { let i = !1; const n = e.__ng_removed; return n && n.setForRemoval && (i = !0), this.playersByElement.has(e) && (i = !0), this.playersByQueriedElement.has(e) && (i = !0), this.statesByElement.has(e) && (i = !0), this._fetchNamespace(t).elementContainsData(e) || i } afterFlush(t) { this._flushFns.push(t) } afterFlushAnimationsDone(t) { this._whenQuietFns.push(t) } _getPreviousPlayers(t, e, i, n, s) { let r = []; if (e) { const e = this.playersByQueriedElement.get(t); e && (r = e) } else { const e = this.playersByElement.get(t); if (e) { const t = !s || s == bO; e.forEach(e => { e.queued || (t || e.triggerName == n) && r.push(e) }) } } return (i || n) && (r = r.filter(t => !(i && i != t.namespaceId || n && n != t.triggerName))), r } _beforeAnimationBuild(t, e, i) { const n = e.element, s = e.isRemovalTransition ? void 0 : t, r = e.isRemovalTransition ? void 0 : e.triggerName; for (const o of e.timelines) { const t = o.element, a = t !== n, l = qD(i, t, []); this._getPreviousPlayers(t, a, s, r, e.toState).forEach(t => { const e = t.getRealPlayer(); e.beforeDestroy && e.beforeDestroy(), t.destroy(), l.push(t) }) } wA(n, e.fromStyles) } _buildAnimation(t, e, i, n, s, r) { const o = e.triggerName, a = e.element, l = [], c = new Set, h = new Set, u = e.timelines.map(e => { const u = e.element; c.add(u); const d = u.__ng_removed; if (d && d.removedBeforeQueried) return new ND(e.duration, e.delay); const p = u !== a, f = function (t) { const e = []; return RO(t, e), e }((i.get(u) || mO).map(t => t.getRealPlayer())).filter(t => !!t.element && t.element === u), g = s.get(u), m = r.get(u), _ = zD(0, this._normalizer, 0, e.keyframes, g, m), v = this._buildPlayer(e, _, f); if (e.subTimeline && n && h.add(u), p) { const e = new kO(t, o, u); e.setRealPlayer(v), l.push(e) } return v }); l.forEach(t => { qD(this.playersByQueriedElement, t.element, []).push(t), t.onDone(() => function (t, e, i) { let n; if (t instanceof Map) { if (n = t.get(e), n) { if (n.length) { const t = n.indexOf(i); n.splice(t, 1) } 0 == n.length && t.delete(e) } } else if (n = t[e], n) { if (n.length) { const t = n.indexOf(i); n.splice(t, 1) } 0 == n.length && delete t[e] } return n }(this.playersByQueriedElement, t.element, t)) }), c.forEach(t => DO(t, uA)); const d = HD(u); return d.onDestroy(() => { c.forEach(t => AO(t, uA)), bA(a, e.toStyles) }), h.forEach(t => { qD(n, t, []).push(d) }), d } _buildPlayer(t, e, i) { return e.length > 0 ? this.driver.animate(t.element, e, t.duration, t.delay, t.easing, i) : new ND(t.duration, t.delay) } } class kO { constructor(t, e, i) { this.namespaceId = t, this.triggerName = e, this.element = i, this._player = new ND, this._containsRealPlayer = !1, this._queuedCallbacks = {}, this.destroyed = !1, this.markedForDestroy = !1, this.disabled = !1, this.queued = !0, this.totalTime = 0 } setRealPlayer(t) { this._containsRealPlayer || (this._player = t, Object.keys(this._queuedCallbacks).forEach(e => { this._queuedCallbacks[e].forEach(i => $D(t, e, void 0, i)) }), this._queuedCallbacks = {}, this._containsRealPlayer = !0, this.overrideTotalTime(t.totalTime), this.queued = !1) } getRealPlayer() { return this._player } overrideTotalTime(t) { this.totalTime = t } syncPlayerEvents(t) { const e = this._player; e.triggerCallback && t.onStart(() => e.triggerCallback("start")), t.onDone(() => this.finish()), t.onDestroy(() => this.destroy()) } _queueEvent(t, e) { qD(this._queuedCallbacks, t, []).push(e) } onDone(t) { this.queued && this._queueEvent("done", t), this._player.onDone(t) } onStart(t) { this.queued && this._queueEvent("start", t), this._player.onStart(t) } onDestroy(t) { this.queued && this._queueEvent("destroy", t), this._player.onDestroy(t) } init() { this._player.init() } hasStarted() { return !this.queued && this._player.hasStarted() } play() { !this.queued && this._player.play() } pause() { !this.queued && this._player.pause() } restart() { !this.queued && this._player.restart() } finish() { this._player.finish() } destroy() { this.destroyed = !0, this._player.destroy() } reset() { !this.queued && this._player.reset() } setPosition(t) { this.queued || this._player.setPosition(t) } getPosition() { return this.queued ? 0 : this._player.getPosition() } triggerCallback(t) { const e = this._player; e.triggerCallback && e.triggerCallback(t) } } function CO(t) { return t && 1 === t.nodeType } function EO(t, e) { const i = t.style.display; return t.style.display = null != e ? e : "none", i } function TO(t, e, i, n, s) { const r = []; i.forEach(t => r.push(EO(t))); const o = []; n.forEach((i, n) => { const r = {}; i.forEach(t => { const i = r[t] = e.computeStyle(n, t, s); i && 0 != i.length || (n.__ng_removed = vO, o.push(n)) }), t.set(n, r) }); let a = 0; return i.forEach(t => EO(t, r[a++])), o } function PO(t, e) { const i = new Map; if (t.forEach(t => i.set(t, [])), 0 == e.length) return i; const n = new Set(e), s = new Map; function r(t) { if (!t) return 1; let e = s.get(t); if (e) return e; const o = t.parentNode; return e = i.has(o) ? o : n.has(o) ? 1 : r(o), s.set(t, e), e } return e.forEach(t => { const e = r(t); 1 !== e && i.get(e).push(t) }), i } function DO(t, e) { if (t.classList) t.classList.add(e); else { let i = t.$$classes; i || (i = t.$$classes = {}), i[e] = !0 } } function AO(t, e) { if (t.classList) t.classList.remove(e); else { let i = t.$$classes; i && delete i[e] } } function OO(t, e, i) { HD(i).onDone(() => t.processLeaveNode(e)) } function RO(t, e) { for (let i = 0; i < t.length; i++) { const n = t[i]; n instanceof jD ? RO(n.players, e) : e.push(n) } } function MO(t, e, i) { const n = i.get(t); if (!n) return !1; let s = e.get(t); return s ? n.forEach(t => s.add(t)) : e.set(t, n), i.delete(t), !0 } class IO { constructor(t, e, i) { this.bodyNode = t, this._driver = e, this._triggerCache = {}, this.onRemovalComplete = (t, e) => { }, this._transitionEngine = new SO(t, e, i), this._timelineEngine = new dO(t, e, i), this._transitionEngine.onRemovalComplete = (t, e) => this.onRemovalComplete(t, e) } registerTrigger(t, e, i, n, s) { const r = t + "-" + n; let o = this._triggerCache[r]; if (!o) { const t = [], e = VA(this._driver, s, t); if (t.length) throw new Error(`The animation trigger "${n}" has failed to build due to the following errors:\n - ${t.join("\n - ")}`); o = function (t, e) { return new cO(t, e) }(n, e), this._triggerCache[r] = o } this._transitionEngine.registerTrigger(e, n, o) } register(t, e) { this._transitionEngine.register(t, e) } destroy(t, e) { this._transitionEngine.destroy(t, e) } onInsert(t, e, i, n) { this._transitionEngine.insertNode(t, e, i, n) } onRemove(t, e, i, n) { this._transitionEngine.removeNode(t, e, n || !1, i) } disableAnimations(t, e) { this._transitionEngine.markElementAsDisabled(t, e) } process(t, e, i, n) { if ("@" == i.charAt(0)) { const [t, s] = GD(i); this._timelineEngine.command(t, e, s, n) } else this._transitionEngine.trigger(t, e, i, n) } listen(t, e, i, n, s) { if ("@" == i.charAt(0)) { const [t, n] = GD(i); return this._timelineEngine.listen(t, e, n, s) } return this._transitionEngine.listen(t, e, i, n, s) } flush(t = -1) { this._transitionEngine.flush(t) } get players() { return this._transitionEngine.players.concat(this._timelineEngine.players) } whenRenderingDone() { return this._transitionEngine.whenRenderingDone() } } function LO(t, e) { let i = null, n = null; return Array.isArray(e) && e.length ? (i = NO(e[0]), e.length > 1 && (n = NO(e[e.length - 1]))) : e && (i = NO(e)), i || n ? new FO(t, i, n) : null } let FO = (() => { class t { constructor(e, i, n) { this._element = e, this._startStyles = i, this._endStyles = n, this._state = 0; let s = t.initialStylesByElement.get(e); s || t.initialStylesByElement.set(e, s = {}), this._initialStyles = s } start() { this._state < 1 && (this._startStyles && bA(this._element, this._startStyles, this._initialStyles), this._state = 1) } finish() { this.start(), this._state < 2 && (bA(this._element, this._initialStyles), this._endStyles && (bA(this._element, this._endStyles), this._endStyles = null), this._state = 1) } destroy() { this.finish(), this._state < 3 && (t.initialStylesByElement.delete(this._element), this._startStyles && (wA(this._element, this._startStyles), this._endStyles = null), this._endStyles && (wA(this._element, this._endStyles), this._endStyles = null), bA(this._element, this._initialStyles), this._state = 3) } } return t.initialStylesByElement = new WeakMap, t })(); function NO(t) { let e = null; const i = Object.keys(t); for (let n = 0; n < i.length; n++) { const s = i[n]; jO(s) && (e = e || {}, e[s] = t[s]) } return e } function jO(t) { return "display" === t || "position" === t } const VO = "animation", BO = "animationend"; class HO { constructor(t, e, i, n, s, r, o) { this._element = t, this._name = e, this._duration = i, this._delay = n, this._easing = s, this._fillMode = r, this._onDoneFn = o, this._finished = !1, this._destroyed = !1, this._startTime = 0, this._position = 0, this._eventFn = t => this._handleCallback(t) } apply() { !function (t, e) { const i = GO(t, "").trim(); i.length && (function (t, e) { let i = 0; for (let n = 0; n < t.length; n++)"," === t.charAt(n) && i++ }(i), e = `${i}, ${e}`), qO(t, "", e) }(this._element, `${this._duration}ms ${this._easing} ${this._delay}ms 1 normal ${this._fillMode} ${this._name}`), WO(this._element, this._eventFn, !1), this._startTime = Date.now() } pause() { zO(this._element, this._name, "paused") } resume() { zO(this._element, this._name, "running") } setPosition(t) { const e = $O(this._element, this._name); this._position = t * this._duration, qO(this._element, "Delay", `-${this._position}ms`, e) } getPosition() { return this._position } _handleCallback(t) { const e = t._ngTestManualTimestamp || Date.now(), i = 1e3 * parseFloat(t.elapsedTime.toFixed(3)); t.animationName == this._name && Math.max(e - this._startTime, 0) >= this._delay && i >= this._duration && this.finish() } finish() { this._finished || (this._finished = !0, this._onDoneFn(), WO(this._element, this._eventFn, !0)) } destroy() { this._destroyed || (this._destroyed = !0, this.finish(), function (t, e) { const i = GO(t, "").split(","), n = UO(i, e); n >= 0 && (i.splice(n, 1), qO(t, "", i.join(","))) }(this._element, this._name)) } } function zO(t, e, i) { qO(t, "PlayState", i, $O(t, e)) } function $O(t, e) { const i = GO(t, ""); return i.indexOf(",") > 0 ? UO(i.split(","), e) : UO([i], e) } function UO(t, e) { for (let i = 0; i < t.length; i++)if (t[i].indexOf(e) >= 0) return i; return -1 } function WO(t, e, i) { i ? t.removeEventListener(BO, e) : t.addEventListener(BO, e) } function qO(t, e, i, n) { const s = VO + e; if (null != n) { const e = t.style[s]; if (e.length) { const t = e.split(","); t[n] = i, i = t.join(",") } } t.style[s] = i } function GO(t, e) { return t.style[VO + e] || "" } class ZO { constructor(t, e, i, n, s, r, o, a) { this.element = t, this.keyframes = e, this.animationName = i, this._duration = n, this._delay = s, this._finalStyles = o, this._specialStyles = a, this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this.currentSnapshot = {}, this._state = 0, this.easing = r || "linear", this.totalTime = n + s, this._buildStyler() } onStart(t) { this._onStartFns.push(t) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } destroy() { this.init(), this._state >= 4 || (this._state = 4, this._styler.destroy(), this._flushStartFns(), this._flushDoneFns(), this._specialStyles && this._specialStyles.destroy(), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } _flushDoneFns() { this._onDoneFns.forEach(t => t()), this._onDoneFns = [] } _flushStartFns() { this._onStartFns.forEach(t => t()), this._onStartFns = [] } finish() { this.init(), this._state >= 3 || (this._state = 3, this._styler.finish(), this._flushStartFns(), this._specialStyles && this._specialStyles.finish(), this._flushDoneFns()) } setPosition(t) { this._styler.setPosition(t) } getPosition() { return this._styler.getPosition() } hasStarted() { return this._state >= 2 } init() { this._state >= 1 || (this._state = 1, this._styler.apply(), this._delay && this._styler.pause()) } play() { this.init(), this.hasStarted() || (this._flushStartFns(), this._state = 2, this._specialStyles && this._specialStyles.start()), this._styler.resume() } pause() { this.init(), this._styler.pause() } restart() { this.reset(), this.play() } reset() { this._state = 0, this._styler.destroy(), this._buildStyler(), this._styler.apply() } _buildStyler() { this._styler = new HO(this.element, this.animationName, this._duration, this._delay, this.easing, "forwards", () => this.finish()) } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns; e.forEach(t => t()), e.length = 0 } beforeDestroy() { this.init(); const t = {}; if (this.hasStarted()) { const e = this._state >= 3; Object.keys(this._finalStyles).forEach(i => { "offset" != i && (t[i] = e ? this._finalStyles[i] : RA(this.element, i)) }) } this.currentSnapshot = t } } class KO extends ND { constructor(t, e) { super(), this.element = t, this._startingStyles = {}, this.__initialized = !1, this._styles = sA(e) } init() { !this.__initialized && this._startingStyles && (this.__initialized = !0, Object.keys(this._styles).forEach(t => { this._startingStyles[t] = this.element.style[t] }), super.init()) } play() { this._startingStyles && (this.init(), Object.keys(this._styles).forEach(t => this.element.style.setProperty(t, this._styles[t])), super.play()) } destroy() { this._startingStyles && (Object.keys(this._startingStyles).forEach(t => { const e = this._startingStyles[t]; e ? this.element.style.setProperty(t, e) : this.element.style.removeProperty(t) }), this._startingStyles = null, super.destroy()) } } class YO { constructor() { this._count = 0 } validateStyleProperty(t) { return tA(t) } matchesElement(t, e) { return eA(t, e) } containsElement(t, e) { return iA(t, e) } query(t, e, i) { return nA(t, e, i) } computeStyle(t, e, i) { return window.getComputedStyle(t)[e] } buildKeyframeElement(t, e, i) { i = i.map(t => sA(t)); let n = `@keyframes ${e} {\n`, s = ""; i.forEach(t => { s = " "; const e = parseFloat(t.offset); n += `${s}${100 * e}% {\n`, s += " ", Object.keys(t).forEach(e => { const i = t[e]; switch (e) { case "offset": return; case "easing": return void (i && (n += `${s}animation-timing-function: ${i};\n`)); default: return void (n += `${s}${e}: ${i};\n`) } }), n += `${s}}\n` }), n += "}\n"; const r = document.createElement("style"); return r.textContent = n, r } animate(t, e, i, n, s, r = [], o) { const a = r.filter(t => t instanceof ZO), l = {}; DA(i, n) && a.forEach(t => { let e = t.currentSnapshot; Object.keys(e).forEach(t => l[t] = e[t]) }); const c = function (t) { let e = {}; return t && (Array.isArray(t) ? t : [t]).forEach(t => { Object.keys(t).forEach(i => { "offset" != i && "easing" != i && (e[i] = t[i]) }) }), e }(e = AA(t, e, l)); if (0 == i) return new KO(t, c); const h = "gen_css_kf_" + this._count++, u = this.buildKeyframeElement(t, h, e); (function (t) { var e; const i = null === (e = t.getRootNode) || void 0 === e ? void 0 : e.call(t); return "undefined" != typeof ShadowRoot && i instanceof ShadowRoot ? i : document.head })(t).appendChild(u); const d = LO(t, e), p = new ZO(t, e, h, i, n, s, c, d); return p.onDestroy(() => { var t; (t = u).parentNode.removeChild(t) }), p } } class QO { constructor(t, e, i, n) { this.element = t, this.keyframes = e, this.options = i, this._specialStyles = n, this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._initialized = !1, this._finished = !1, this._started = !1, this._destroyed = !1, this.time = 0, this.parentPlayer = null, this.currentSnapshot = {}, this._duration = i.duration, this._delay = i.delay || 0, this.time = this._duration + this._delay } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(t => t()), this._onDoneFns = []) } init() { this._buildPlayer(), this._preparePlayerBeforeStart() } _buildPlayer() { if (this._initialized) return; this._initialized = !0; const t = this.keyframes; this.domPlayer = this._triggerWebAnimation(this.element, t, this.options), this._finalKeyframe = t.length ? t[t.length - 1] : {}, this.domPlayer.addEventListener("finish", () => this._onFinish()) } _preparePlayerBeforeStart() { this._delay ? this._resetDomPlayerState() : this.domPlayer.pause() } _triggerWebAnimation(t, e, i) { return t.animate(e, i) } onStart(t) { this._onStartFns.push(t) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } play() { this._buildPlayer(), this.hasStarted() || (this._onStartFns.forEach(t => t()), this._onStartFns = [], this._started = !0, this._specialStyles && this._specialStyles.start()), this.domPlayer.play() } pause() { this.init(), this.domPlayer.pause() } finish() { this.init(), this._specialStyles && this._specialStyles.finish(), this._onFinish(), this.domPlayer.finish() } reset() { this._resetDomPlayerState(), this._destroyed = !1, this._finished = !1, this._started = !1 } _resetDomPlayerState() { this.domPlayer && this.domPlayer.cancel() } restart() { this.reset(), this.play() } hasStarted() { return this._started } destroy() { this._destroyed || (this._destroyed = !0, this._resetDomPlayerState(), this._onFinish(), this._specialStyles && this._specialStyles.destroy(), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } setPosition(t) { void 0 === this.domPlayer && this.init(), this.domPlayer.currentTime = t * this.time } getPosition() { return this.domPlayer.currentTime / this.time } get totalTime() { return this._delay + this._duration } beforeDestroy() { const t = {}; this.hasStarted() && Object.keys(this._finalKeyframe).forEach(e => { "offset" != e && (t[e] = this._finished ? this._finalKeyframe[e] : RA(this.element, e)) }), this.currentSnapshot = t } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns; e.forEach(t => t()), e.length = 0 } } class XO { constructor() { this._isNativeImpl = /\{\s*\[native\s+code\]\s*\}/.test(JO().toString()), this._cssKeyframesDriver = new YO } validateStyleProperty(t) { return tA(t) } matchesElement(t, e) { return eA(t, e) } containsElement(t, e) { return iA(t, e) } query(t, e, i) { return nA(t, e, i) } computeStyle(t, e, i) { return window.getComputedStyle(t)[e] } overrideWebAnimationsSupport(t) { this._isNativeImpl = t } animate(t, e, i, n, s, r = [], o) { if (!o && !this._isNativeImpl) return this._cssKeyframesDriver.animate(t, e, i, n, s, r); const a = { duration: i, delay: n, fill: 0 == n ? "both" : "forwards" }; s && (a.easing = s); const l = {}, c = r.filter(t => t instanceof QO); DA(i, n) && c.forEach(t => { let e = t.currentSnapshot; Object.keys(e).forEach(t => l[t] = e[t]) }); const h = LO(t, e = AA(t, e = e.map(t => _A(t, !1)), l)); return new QO(t, e, a, h) } } function JO() { return VD() && Element.prototype.animate || {} } let tR = (() => { class t extends PD { constructor(t, e) { super(), this._nextAnimationId = 0, this._renderer = t.createRenderer(e.body, { id: "0", encapsulation: Tt.None, styles: [], data: { animation: [] } }) } build(t) { const e = this._nextAnimationId.toString(); this._nextAnimationId++; const i = Array.isArray(t) ? RD(t) : t; return nR(this._renderer, null, e, "register", [i]), new eR(e, this._renderer) } } return t.\u0275fac = function (e) { return new (e || t)(hn(Qo), hn(vc)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); class eR extends class { }{ constructor(t, e) { super(), this._id = t, this._renderer = e } create(t, e) { return new iR(this._id, t, e || {}, this._renderer) } } class iR { constructor(t, e, i, n) { this.id = t, this.element = e, this._renderer = n, this.parentPlayer = null, this._started = !1, this.totalTime = 0, this._command("create", i) } _listen(t, e) { return this._renderer.listen(this.element, `@@${this.id}:${t}`, e) } _command(t, ...e) { return nR(this._renderer, this.element, this.id, t, e) } onDone(t) { this._listen("done", t) } onStart(t) { this._listen("start", t) } onDestroy(t) { this._listen("destroy", t) } init() { this._command("init") } hasStarted() { return this._started } play() { this._command("play"), this._started = !0 } pause() { this._command("pause") } restart() { this._command("restart") } finish() { this._command("finish") } destroy() { this._command("destroy") } reset() { this._command("reset"), this._started = !1 } setPosition(t) { this._command("setPosition", t) } getPosition() { var t, e; return null !== (e = null === (t = this._renderer.engine.players[+this.id]) || void 0 === t ? void 0 : t.getPosition()) && void 0 !== e ? e : 0 } } function nR(t, e, i, n, s) { return t.setProperty(e, `@@${i}:${n}`, s) } const sR = "@", rR = "@.disabled"; let oR = (() => { class t { constructor(t, e, i) { this.delegate = t, this.engine = e, this._zone = i, this._currentId = 0, this._microtaskId = 1, this._animationCallbacksBuffer = [], this._rendererCache = new Map, this._cdRecurDepth = 0, this.promise = Promise.resolve(0), e.onRemovalComplete = (t, e) => { e && e.parentNode(t) && e.removeChild(t.parentNode, t) } } createRenderer(t, e) { const i = this.delegate.createRenderer(t, e); if (!(t && e && e.data && e.data.animation)) { let t = this._rendererCache.get(i); return t || (t = new aR("", i, this.engine), this._rendererCache.set(i, t)), t } const n = e.id, s = e.id + "-" + this._currentId; this._currentId++, this.engine.register(s, t); const r = e => { Array.isArray(e) ? e.forEach(r) : this.engine.registerTrigger(n, s, t, e.name, e) }; return e.data.animation.forEach(r), new lR(this, s, i, this.engine) } begin() { this._cdRecurDepth++, this.delegate.begin && this.delegate.begin() } _scheduleCountTask() { this.promise.then(() => { this._microtaskId++ }) } scheduleListenerCallback(t, e, i) { t >= 0 && t < this._microtaskId ? this._zone.run(() => e(i)) : (0 == this._animationCallbacksBuffer.length && Promise.resolve(null).then(() => { this._zone.run(() => { this._animationCallbacksBuffer.forEach(t => { const [e, i] = t; e(i) }), this._animationCallbacksBuffer = [] }) }), this._animationCallbacksBuffer.push([e, i])) } end() { this._cdRecurDepth--, 0 == this._cdRecurDepth && this._zone.runOutsideAngular(() => { this._scheduleCountTask(), this.engine.flush(this._microtaskId) }), this.delegate.end && this.delegate.end() } whenRenderingDone() { return this.engine.whenRenderingDone() } } return t.\u0275fac = function (e) { return new (e || t)(hn(Qo), hn(IO), hn(Vl)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); class aR { constructor(t, e, i) { this.namespaceId = t, this.delegate = e, this.engine = i, this.destroyNode = this.delegate.destroyNode ? t => e.destroyNode(t) : null } get data() { return this.delegate.data } destroy() { this.engine.destroy(this.namespaceId, this.delegate), this.delegate.destroy() } createElement(t, e) { return this.delegate.createElement(t, e) } createComment(t) { return this.delegate.createComment(t) } createText(t) { return this.delegate.createText(t) } appendChild(t, e) { this.delegate.appendChild(t, e), this.engine.onInsert(this.namespaceId, e, t, !1) } insertBefore(t, e, i, n = !0) { this.delegate.insertBefore(t, e, i), this.engine.onInsert(this.namespaceId, e, t, n) } removeChild(t, e, i) { this.engine.onRemove(this.namespaceId, e, this.delegate, i) } selectRootElement(t, e) { return this.delegate.selectRootElement(t, e) } parentNode(t) { return this.delegate.parentNode(t) } nextSibling(t) { return this.delegate.nextSibling(t) } setAttribute(t, e, i, n) { this.delegate.setAttribute(t, e, i, n) } removeAttribute(t, e, i) { this.delegate.removeAttribute(t, e, i) } addClass(t, e) { this.delegate.addClass(t, e) } removeClass(t, e) { this.delegate.removeClass(t, e) } setStyle(t, e, i, n) { this.delegate.setStyle(t, e, i, n) } removeStyle(t, e, i) { this.delegate.removeStyle(t, e, i) } setProperty(t, e, i) { e.charAt(0) == sR && e == rR ? this.disableAnimations(t, !!i) : this.delegate.setProperty(t, e, i) } setValue(t, e) { this.delegate.setValue(t, e) } listen(t, e, i) { return this.delegate.listen(t, e, i) } disableAnimations(t, e) { this.engine.disableAnimations(t, e) } } class lR extends aR { constructor(t, e, i, n) { super(e, i, n), this.factory = t, this.namespaceId = e } setProperty(t, e, i) { e.charAt(0) == sR ? "." == e.charAt(1) && e == rR ? this.disableAnimations(t, i = void 0 === i || !!i) : this.engine.process(this.namespaceId, t, e.substr(1), i) : this.delegate.setProperty(t, e, i) } listen(t, e, i) { if (e.charAt(0) == sR) { const n = function (t) { switch (t) { case "body": return document.body; case "document": return document; case "window": return window; default: return t } }(t); let s = e.substr(1), r = ""; return s.charAt(0) != sR && ([s, r] = function (t) { const e = t.indexOf("."); return [t.substring(0, e), t.substr(e + 1)] }(s)), this.engine.listen(this.namespaceId, n, s, r, t => { this.factory.scheduleListenerCallback(t._data || -1, i, t) }) } return this.delegate.listen(t, e, i) } } let cR = (() => { class t extends IO { constructor(t, e, i) { super(t.body, e, i) } ngOnDestroy() { this.flush() } } return t.\u0275fac = function (e) { return new (e || t)(hn(vc), hn(oA), hn(iO)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); const hR = new Wi("AnimationModuleType"), uR = [{ provide: PD, useClass: tR }, { provide: iO, useFactory: function () { return new nO } }, { provide: IO, useClass: cR }, { provide: Qo, useFactory: function (t, e, i) { return new oR(t, e, i) }, deps: [mh, IO, Vl] }], dR = [{ provide: oA, useFactory: function () { return "function" == typeof JO() ? new XO : new YO } }, { provide: hR, useValue: "BrowserAnimations" }, ...uR], pR = [{ provide: oA, useClass: rA }, { provide: hR, useValue: "NoopAnimations" }, ...uR]; let fR = (() => { class t { static withConfig(e) { return { ngModule: t, providers: e.disableAnimations ? pR : dR } } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Gt({ type: t }), t.\u0275inj = pt({ providers: dR, imports: [Ph] }), t })(); const gR = "Authorization"; let mR = (() => { class t { constructor(t) { this.token = t } intercept(t, e) { let i = t; const n = this.token.getToken(); return null != n ? (i = t.clone({ headers: t.headers.set(gR, "Bearer " + n) }), e.handle(i)) : null == n ? (t.headers.delete("Authorization"), e.handle(t)) : (i = t.clone({ headers: t.headers.set(gR, "Bearer " + n) }), e.handle(i)) } } return t.\u0275fac = function (e) { return new (e || t)(hn(kf)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(); class _R { attach(t) { return this._attachedHost = t, t.attach(this) } detach() { let t = this._attachedHost; null != t && (this._attachedHost = null, t.detach()) } get isAttached() { return null != this._attachedHost } setAttachedHost(t) { this._attachedHost = t } } class vR extends _R { constructor(t, e, i, n) { super(), this.component = t, this.viewContainerRef = e, this.injector = i, this.componentFactoryResolver = n } } class yR extends _R { constructor(t, e, i) { super(), this.templateRef = t, this.viewContainerRef = e, this.context = i } get origin() { return this.templateRef.elementRef } attach(t, e = this.context) { return this.context = e, super.attach(t) } detach() { return this.context = void 0, super.detach() } } class bR extends _R { constructor(t) { super(), this.element = t instanceof Ko ? t.nativeElement : t } } class wR { constructor() { this._isDisposed = !1, this.attachDomPortal = null } hasAttached() { return !!this._attachedPortal } attach(t) { return t instanceof vR ? (this._attachedPortal = t, this.attachComponentPortal(t)) : t instanceof yR ? (this._attachedPortal = t, this.attachTemplatePortal(t)) : this.attachDomPortal && t instanceof bR ? (this._attachedPortal = t, this.attachDomPortal(t)) : void 0 } detach() { this._attachedPortal && (this._attachedPortal.setAttachedHost(null), this._attachedPortal = null), this._invokeDisposeFn() } dispose() { this.hasAttached() && this.detach(), this._invokeDisposeFn(), this._isDisposed = !0 } setDisposeFn(t) { this._disposeFn = t } _invokeDisposeFn() { this._disposeFn && (this._disposeFn(), this._disposeFn = null) } } class xR extends wR { constructor(t, e, i, n, s) { super(), this.outletElement = t, this._componentFactoryResolver = e, this._appRef = i, this._defaultInjector = n, this.attachDomPortal = t => { const e = t.element, i = this._document.createComment("dom-portal"); e.parentNode.insertBefore(i, e), this.outletElement.appendChild(e), this._attachedPortal = t, super.setDisposeFn(() => { i.parentNode && i.parentNode.replaceChild(e, i) }) }, this._document = s } attachComponentPortal(t) { const e = (t.componentFactoryResolver || this._componentFactoryResolver).resolveComponentFactory(t.component); let i; return t.viewContainerRef ? (i = t.viewContainerRef.createComponent(e, t.viewContainerRef.length, t.injector || t.viewContainerRef.injector), this.setDisposeFn(() => i.destroy())) : (i = e.create(t.injector || this._defaultInjector), this._appRef.attachView(i.hostView), this.setDisposeFn(() => { this._appRef.detachView(i.hostView), i.destroy() })), this.outletElement.appendChild(this._getComponentRootNode(i)), this._attachedPortal = t, i } attachTemplatePortal(t) { let e = t.viewContainerRef, i = e.createEmbeddedView(t.templateRef, t.context); return i.rootNodes.forEach(t => this.outletElement.appendChild(t)), i.detectChanges(), this.setDisposeFn(() => { let t = e.indexOf(i); -1 !== t && e.remove(t) }), this._attachedPortal = t, i } dispose() { super.dispose(), null != this.outletElement.parentNode && this.outletElement.parentNode.removeChild(this.outletElement) } _getComponentRootNode(t) { return t.hostView.rootNodes[0] } } let SR = (() => { class t extends wR { constructor(t, e, i) { super(), this._componentFactoryResolver = t, this._viewContainerRef = e, this._isInitialized = !1, this.attached = new Ja, this.attachDomPortal = t => { const e = t.element, i = this._document.createComment("dom-portal"); t.setAttachedHost(this), e.parentNode.insertBefore(i, e), this._getRootNode().appendChild(e), this._attachedPortal = t, super.setDisposeFn(() => { i.parentNode && i.parentNode.replaceChild(e, i) }) }, this._document = i } get portal() { return this._attachedPortal } set portal(t) { (!this.hasAttached() || t || this._isInitialized) && (this.hasAttached() && super.detach(), t && super.attach(t), this._attachedPortal = t) } get attachedRef() { return this._attachedRef } ngOnInit() { this._isInitialized = !0 } ngOnDestroy() { super.dispose(), this._attachedPortal = null, this._attachedRef = null } attachComponentPortal(t) { t.setAttachedHost(this); const e = null != t.viewContainerRef ? t.viewContainerRef : this._viewContainerRef, i = (t.componentFactoryResolver || this._componentFactoryResolver).resolveComponentFactory(t.component), n = e.createComponent(i, e.length, t.injector || e.injector); return e !== this._viewContainerRef && this._getRootNode().appendChild(n.hostView.rootNodes[0]), super.setDisposeFn(() => n.destroy()), this._attachedPortal = t, this._attachedRef = n, this.attached.emit(n), n } attachTemplatePortal(t) { t.setAttachedHost(this); const e = this._viewContainerRef.createEmbeddedView(t.templateRef, t.context); return super.setDisposeFn(() => this._viewContainerRef.clear()), this._attachedPortal = t, this._attachedRef = e, this.attached.emit(e), e } _getRootNode() { const t = this._viewContainerRef.element.nativeElement; return t.nodeType === t.ELEMENT_NODE ? t : t.parentNode } } return t.\u0275fac = function (e) { return new (e || t)(Ur(Wo), Ur(Ma), Ur(vc)) }, t.\u0275dir = Kt({ type: t, selectors: [["", "cdkPortalOutlet", ""]], inputs: { portal: ["cdkPortalOutlet", "portal"] }, outputs: { attached: "attached" }, exportAs: ["cdkPortalOutlet"], features: [Ar] }), t })(), kR = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Gt({ type: t }), t.\u0275inj = pt({}), t })(); const CR = ny(); class ER { constructor(t, e) { this._viewportRuler = t, this._previousHTMLStyles = { top: "", left: "" }, this._isEnabled = !1, this._document = e } attach() { } enable() { if (this._canBeEnabled()) { const t = this._document.documentElement; this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition(), this._previousHTMLStyles.left = t.style.left || "", this._previousHTMLStyles.top = t.style.top || "", t.style.left = Nv(-this._previousScrollPosition.left), t.style.top = Nv(-this._previousScrollPosition.top), t.classList.add("cdk-global-scrollblock"), this._isEnabled = !0 } } disable() { if (this._isEnabled) { const t = this._document.documentElement, e = t.style, i = this._document.body.style, n = e.scrollBehavior || "", s = i.scrollBehavior || ""; this._isEnabled = !1, e.left = this._previousHTMLStyles.left, e.top = this._previousHTMLStyles.top, t.classList.remove("cdk-global-scrollblock"), CR && (e.scrollBehavior = i.scrollBehavior = "auto"), window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top), CR && (e.scrollBehavior = n, i.scrollBehavior = s) } } _canBeEnabled() { if (this._document.documentElement.classList.contains("cdk-global-scrollblock") || this._isEnabled) return !1; const t = this._document.body, e = this._viewportRuler.getViewportSize(); return t.scrollHeight > e.height || t.scrollWidth > e.width } } class TR { constructor(t, e, i, n) { this._scrollDispatcher = t, this._ngZone = e, this._viewportRuler = i, this._config = n, this._scrollSubscription = null, this._detach = () => { this.disable(), this._overlayRef.hasAttached() && this._ngZone.run(() => this._overlayRef.detach()) } } attach(t) { this._overlayRef = t } enable() { if (this._scrollSubscription) return; const t = this._scrollDispatcher.scrolled(0); this._config && this._config.threshold && this._config.threshold > 1 ? (this._initialScrollPosition = this._viewportRuler.getViewportScrollPosition().top, this._scrollSubscription = t.subscribe(() => { const t = this._viewportRuler.getViewportScrollPosition().top; Math.abs(t - this._initialScrollPosition) > this._config.threshold ? this._detach() : this._overlayRef.updatePosition() })) : this._scrollSubscription = t.subscribe(this._detach) } disable() { this._scrollSubscription && (this._scrollSubscription.unsubscribe(), this._scrollSubscription = null) } detach() { this.disable(), this._overlayRef = null } } class PR { enable() { } disable() { } attach() { } } function DR(t, e) { return e.some(e => t.bottom < e.top || t.top > e.bottom || t.right < e.left || t.left > e.right) } function AR(t, e) { return e.some(e => t.top < e.top || t.bottom > e.bottom || t.left < e.left || t.right > e.right) } class OR { constructor(t, e, i, n) { this._scrollDispatcher = t, this._viewportRuler = e, this._ngZone = i, this._config = n, this._scrollSubscription = null } attach(t) { this._overlayRef = t } enable() { this._scrollSubscription || (this._scrollSubscription = this._scrollDispatcher.scrolled(this._config ? this._config.scrollThrottle : 0).subscribe(() => { if (this._overlayRef.updatePosition(), this._config && this._config.autoClose) { const t = this._overlayRef.overlayElement.getBoundingClientRect(), { width: e, height: i } = this._viewportRuler.getViewportSize(); DR(t, [{ width: e, height: i, bottom: i, right: e, top: 0, left: 0 }]) && (this.disable(), this._ngZone.run(() => this._overlayRef.detach())) } })) } disable() { this._scrollSubscription && (this._scrollSubscription.unsubscribe(), this._scrollSubscription = null) } detach() { this.disable(), this._overlayRef = null } } let RR = (() => { class t { constructor(t, e, i, n) { this._scrollDispatcher = t, this._viewportRuler = e, this._ngZone = i, this.noop = () => new PR, this.close = t => new TR(this._scrollDispatcher, this._ngZone, this._viewportRuler, t), this.block = () => new ER(this._viewportRuler, this._document), this.reposition = t => new OR(this._scrollDispatcher, this._viewportRuler, this._ngZone, t), this._document = n } } return t.\u0275fac = function (e) { return new (e || t)(hn(uy), hn(dy), hn(Vl), hn(vc)) }, t.\u0275prov = dt({ factory: function () { return new t(hn(uy), hn(dy), hn(Vl), hn(vc)) }, token: t, providedIn: "root" }), t })(); class MR { constructor(t) { if (this.scrollStrategy = new PR, this.panelClass = "", this.hasBackdrop = !1, this.backdropClass = "cdk-overlay-dark-backdrop", this.disposeOnNavigation = !1, t) { const e = Object.keys(t); for (const i of e) void 0 !== t[i] && (this[i] = t[i]) } } } class IR { constructor(t, e, i, n, s) { this.offsetX = i, this.offsetY = n, this.panelClass = s, this.originX = t.originX, this.originY = t.originY, this.overlayX = e.overlayX, this.overlayY = e.overlayY } } class LR { constructor(t, e) { this.connectionPair = t, this.scrollableViewProperties = e } } let FR = (() => { class t { constructor(t) { this._attachedOverlays = [], this._document = t } ngOnDestroy() { this.detach() } add(t) { this.remove(t), this._attachedOverlays.push(t) } remove(t) { const e = this._attachedOverlays.indexOf(t); e > -1 && this._attachedOverlays.splice(e, 1), 0 === this._attachedOverlays.length && this.detach() } } return t.\u0275fac = function (e) { return new (e || t)(hn(vc)) }, t.\u0275prov = dt({ factory: function () { return new t(hn(vc)) }, token: t, providedIn: "root" }), t })(), NR = (() => { class t extends FR { constructor(t) { super(t), this._keydownListener = t => { const e = this._attachedOverlays; for (let i = e.length - 1; i > -1; i--)if (e[i]._keydownEvents.observers.length > 0) { e[i]._keydownEvents.next(t); break } } } add(t) { super.add(t), this._isAttached || (this._document.body.addEventListener("keydown", this._keydownListener), this._isAttached = !0) } detach() { this._isAttached && (this._document.body.removeEventListener("keydown", this._keydownListener), this._isAttached = !1) } } return t.\u0275fac = function (e) { return new (e || t)(hn(vc)) }, t.\u0275prov = dt({ factory: function () { return new t(hn(vc)) }, token: t, providedIn: "root" }), t })(), jR = (() => { class t extends FR { constructor(t, e) { super(t), this._platform = e, this._cursorStyleIsSet = !1, this._pointerDownListener = t => { this._pointerDownEventTarget = oy(t) }, this._clickListener = t => { const e = oy(t), i = "click" === t.type && this._pointerDownEventTarget ? this._pointerDownEventTarget : e; this._pointerDownEventTarget = null; const n = this._attachedOverlays.slice(); for (let s = n.length - 1; s > -1; s--) { const r = n[s]; if (!(r._outsidePointerEvents.observers.length < 1) && r.hasAttached()) { if (r.overlayElement.contains(e) || r.overlayElement.contains(i)) break; r._outsidePointerEvents.next(t) } } } } add(t) { if (super.add(t), !this._isAttached) { const t = this._document.body; t.addEventListener("pointerdown", this._pointerDownListener, !0), t.addEventListener("click", this._clickListener, !0), t.addEventListener("auxclick", this._clickListener, !0), t.addEventListener("contextmenu", this._clickListener, !0), this._platform.IOS && !this._cursorStyleIsSet && (this._cursorOriginalValue = t.style.cursor, t.style.cursor = "pointer", this._cursorStyleIsSet = !0), this._isAttached = !0 } } detach() { if (this._isAttached) { const t = this._document.body; t.removeEventListener("pointerdown", this._pointerDownListener, !0), t.removeEventListener("click", this._clickListener, !0), t.removeEventListener("auxclick", this._clickListener, !0), t.removeEventListener("contextmenu", this._clickListener, !0), this._platform.IOS && this._cursorStyleIsSet && (t.style.cursor = this._cursorOriginalValue, this._cursorStyleIsSet = !1), this._isAttached = !1 } } } return t.\u0275fac = function (e) { return new (e || t)(hn(vc), hn(ty)) }, t.\u0275prov = dt({ factory: function () { return new t(hn(vc), hn(ty)) }, token: t, providedIn: "root" }), t })(), VR = (() => { class t { constructor(t, e) { this._platform = e, this._document = t } ngOnDestroy() { const t = this._containerElement; t && t.parentNode && t.parentNode.removeChild(t) } getContainerElement() { return this._containerElement || this._createContainer(), this._containerElement } _createContainer() { const t = "cdk-overlay-container"; if (this._platform.isBrowser || ay()) { const e = this._document.querySelectorAll(`.${t}[platform="server"], .${t}[platform="test"]`); for (let t = 0; t < e.length; t++)e[t].parentNode.removeChild(e[t]) } const e = this._document.createElement("div"); e.classList.add(t), ay() ? e.setAttribute("platform", "test") : this._platform.isBrowser || e.setAttribute("platform", "server"), this._document.body.appendChild(e), this._containerElement = e } } return t.\u0275fac = function (e) { return new (e || t)(hn(vc), hn(ty)) }, t.\u0275prov = dt({ factory: function () { return new t(hn(vc), hn(ty)) }, token: t, providedIn: "root" }), t })(); class BR { constructor(t, e, i, n, s, r, o, a, l) { this._portalOutlet = t, this._host = e, this._pane = i, this._config = n, this._ngZone = s, this._keyboardDispatcher = r, this._document = o, this._location = a, this._outsideClickDispatcher = l, this._backdropElement = null, this._backdropClick = new S, this._attachments = new S, this._detachments = new S, this._locationChanges = u.EMPTY, this._backdropClickHandler = t => this._backdropClick.next(t), this._keydownEvents = new S, this._outsidePointerEvents = new S, n.scrollStrategy && (this._scrollStrategy = n.scrollStrategy, this._scrollStrategy.attach(this)), this._positionStrategy = n.positionStrategy } get overlayElement() { return this._pane } get backdropElement() { return this._backdropElement } get hostElement() { return this._host } attach(t) { let e = this._portalOutlet.attach(t); return !this._host.parentElement && this._previousHostParent && this._previousHostParent.appendChild(this._host), this._positionStrategy && this._positionStrategy.attach(this), this._updateStackingOrder(), this._updateElementSize(), this._updateElementDirection(), this._scrollStrategy && this._scrollStrategy.enable(), this._ngZone.onStable.pipe(qh(1)).subscribe(() => { this.hasAttached() && this.updatePosition() }), this._togglePointerEvents(!0), this._config.hasBackdrop && this._attachBackdrop(), this._config.panelClass && this._toggleClasses(this._pane, this._config.panelClass, !0), this._attachments.next(), this._keyboardDispatcher.add(this), this._config.disposeOnNavigation && (this._locationChanges = this._location.subscribe(() => this.dispose())), this._outsideClickDispatcher.add(this), e } detach() { if (!this.hasAttached()) return; this.detachBackdrop(), this._togglePointerEvents(!1), this._positionStrategy && this._positionStrategy.detach && this._positionStrategy.detach(), this._scrollStrategy && this._scrollStrategy.disable(); const t = this._portalOutlet.detach(); return this._detachments.next(), this._keyboardDispatcher.remove(this), this._detachContentWhenStable(), this._locationChanges.unsubscribe(), this._outsideClickDispatcher.remove(this), t } dispose() { const t = this.hasAttached(); this._positionStrategy && this._positionStrategy.dispose(), this._disposeScrollStrategy(), this._disposeBackdrop(this._backdropElement), this._locationChanges.unsubscribe(), this._keyboardDispatcher.remove(this), this._portalOutlet.dispose(), this._attachments.complete(), this._backdropClick.complete(), this._keydownEvents.complete(), this._outsidePointerEvents.complete(), this._outsideClickDispatcher.remove(this), this._host && this._host.parentNode && (this._host.parentNode.removeChild(this._host), this._host = null), this._previousHostParent = this._pane = null, t && this._detachments.next(), this._detachments.complete() } hasAttached() { return this._portalOutlet.hasAttached() } backdropClick() { return this._backdropClick } attachments() { return this._attachments } detachments() { return this._detachments } keydownEvents() { return this._keydownEvents } outsidePointerEvents() { return this._outsidePointerEvents } getConfig() { return this._config } updatePosition() { this._positionStrategy && this._positionStrategy.apply() } updatePositionStrategy(t) { t !== this._positionStrategy && (this._positionStrategy && this._positionStrategy.dispose(), this._positionStrategy = t, this.hasAttached() && (t.attach(this), this.updatePosition())) } updateSize(t) { this._config = Object.assign(Object.assign({}, this._config), t), this._updateElementSize() } setDirection(t) { this._config = Object.assign(Object.assign({}, this._config), { direction: t }), this._updateElementDirection() } addPanelClass(t) { this._pane && this._toggleClasses(this._pane, t, !0) } removePanelClass(t) { this._pane && this._toggleClasses(this._pane, t, !1) } getDirection() { const t = this._config.direction; return t ? "string" == typeof t ? t : t.value : "ltr" } updateScrollStrategy(t) { t !== this._scrollStrategy && (this._disposeScrollStrategy(), this._scrollStrategy = t, this.hasAttached() && (t.attach(this), t.enable())) } _updateElementDirection() { this._host.setAttribute("dir", this.getDirection()) } _updateElementSize() { if (!this._pane) return; const t = this._pane.style; t.width = Nv(this._config.width), t.height = Nv(this._config.height), t.minWidth = Nv(this._config.minWidth), t.minHeight = Nv(this._config.minHeight), t.maxWidth = Nv(this._config.maxWidth), t.maxHeight = Nv(this._config.maxHeight) } _togglePointerEvents(t) { this._pane.style.pointerEvents = t ? "" : "none" } _attachBackdrop() { const t = "cdk-overlay-backdrop-showing"; this._backdropElement = this._document.createElement("div"), this._backdropElement.classList.add("cdk-overlay-backdrop"), this._config.backdropClass && this._toggleClasses(this._backdropElement, this._config.backdropClass, !0), this._host.parentElement.insertBefore(this._backdropElement, this._host), this._backdropElement.addEventListener("click", this._backdropClickHandler), "undefined" != typeof requestAnimationFrame ? this._ngZone.runOutsideAngular(() => { requestAnimationFrame(() => { this._backdropElement && this._backdropElement.classList.add(t) }) }) : this._backdropElement.classList.add(t) } _updateStackingOrder() { this._host.nextSibling && this._host.parentNode.appendChild(this._host) } detachBackdrop() { const t = this._backdropElement; if (!t) return; let e; const i = () => { t && (t.removeEventListener("click", this._backdropClickHandler), t.removeEventListener("transitionend", i), this._disposeBackdrop(t)), this._config.backdropClass && this._toggleClasses(t, this._config.backdropClass, !1), clearTimeout(e) }; t.classList.remove("cdk-overlay-backdrop-showing"), this._ngZone.runOutsideAngular(() => { t.addEventListener("transitionend", i) }), t.style.pointerEvents = "none", e = this._ngZone.runOutsideAngular(() => setTimeout(i, 500)) } _toggleClasses(t, e, i) { const n = t.classList; Fv(e).forEach(t => { t && (i ? n.add(t) : n.remove(t)) }) } _detachContentWhenStable() { this._ngZone.runOutsideAngular(() => { const t = this._ngZone.onStable.pipe(Gv(q(this._attachments, this._detachments))).subscribe(() => { this._pane && this._host && 0 !== this._pane.children.length || (this._pane && this._config.panelClass && this._toggleClasses(this._pane, this._config.panelClass, !1), this._host && this._host.parentElement && (this._previousHostParent = this._host.parentElement, this._previousHostParent.removeChild(this._host)), t.unsubscribe()) }) }) } _disposeScrollStrategy() { const t = this._scrollStrategy; t && (t.disable(), t.detach && t.detach()) } _disposeBackdrop(t) { t && (t.parentNode && t.parentNode.removeChild(t), this._backdropElement === t && (this._backdropElement = null)) } } const HR = "cdk-overlay-connected-position-bounding-box", zR = /([A-Za-z%]+)$/; class $R { constructor(t, e, i, n, s) { this._viewportRuler = e, this._document = i, this._platform = n, this._overlayContainer = s, this._lastBoundingBoxSize = { width: 0, height: 0 }, this._isPushed = !1, this._canPush = !0, this._growAfterOpen = !1, this._hasFlexibleDimensions = !0, this._positionLocked = !1, this._viewportMargin = 0, this._scrollables = [], this._preferredPositions = [], this._positionChanges = new S, this._resizeSubscription = u.EMPTY, this._offsetX = 0, this._offsetY = 0, this._appliedPanelClasses = [], this.positionChanges = this._positionChanges, this.setOrigin(t) } get positions() { return this._preferredPositions } attach(t) { this._validatePositions(), t.hostElement.classList.add(HR), this._overlayRef = t, this._boundingBox = t.hostElement, this._pane = t.overlayElement, this._isDisposed = !1, this._isInitialRender = !0, this._lastPosition = null, this._resizeSubscription.unsubscribe(), this._resizeSubscription = this._viewportRuler.change().subscribe(() => { this._isInitialRender = !0, this.apply() }) } apply() { if (this._isDisposed || !this._platform.isBrowser) return; if (!this._isInitialRender && this._positionLocked && this._lastPosition) return void this.reapplyLastPosition(); this._clearPanelClasses(), this._resetOverlayElementStyles(), this._resetBoundingBoxStyles(), this._viewportRect = this._getNarrowedViewportRect(), this._originRect = this._getOriginRect(), this._overlayRect = this._pane.getBoundingClientRect(); const t = this._originRect, e = this._overlayRect, i = this._viewportRect, n = []; let s; for (let r of this._preferredPositions) { let o = this._getOriginPoint(t, r), a = this._getOverlayPoint(o, e, r), l = this._getOverlayFit(a, e, i, r); if (l.isCompletelyWithinViewport) return this._isPushed = !1, void this._applyPosition(r, o); this._canFitWithFlexibleDimensions(l, a, i) ? n.push({ position: r, origin: o, overlayRect: e, boundingBoxRect: this._calculateBoundingBoxRect(o, r) }) : (!s || s.overlayFit.visibleArea < l.visibleArea) && (s = { overlayFit: l, overlayPoint: a, originPoint: o, position: r, overlayRect: e }) } if (n.length) { let t = null, e = -1; for (const i of n) { const n = i.boundingBoxRect.width * i.boundingBoxRect.height * (i.position.weight || 1); n > e && (e = n, t = i) } return this._isPushed = !1, void this._applyPosition(t.position, t.origin) } if (this._canPush) return this._isPushed = !0, void this._applyPosition(s.position, s.originPoint); this._applyPosition(s.position, s.originPoint) } detach() { this._clearPanelClasses(), this._lastPosition = null, this._previousPushAmount = null, this._resizeSubscription.unsubscribe() } dispose() { this._isDisposed || (this._boundingBox && UR(this._boundingBox.style, { top: "", left: "", right: "", bottom: "", height: "", width: "", alignItems: "", justifyContent: "" }), this._pane && this._resetOverlayElementStyles(), this._overlayRef && this._overlayRef.hostElement.classList.remove(HR), this.detach(), this._positionChanges.complete(), this._overlayRef = this._boundingBox = null, this._isDisposed = !0) } reapplyLastPosition() { if (!this._isDisposed && (!this._platform || this._platform.isBrowser)) { this._originRect = this._getOriginRect(), this._overlayRect = this._pane.getBoundingClientRect(), this._viewportRect = this._getNarrowedViewportRect(); const t = this._lastPosition || this._preferredPositions[0], e = this._getOriginPoint(this._originRect, t); this._applyPosition(t, e) } } withScrollableContainers(t) { return this._scrollables = t, this } withPositions(t) { return this._preferredPositions = t, -1 === t.indexOf(this._lastPosition) && (this._lastPosition = null), this._validatePositions(), this } withViewportMargin(t) { return this._viewportMargin = t, this } withFlexibleDimensions(t = !0) { return this._hasFlexibleDimensions = t, this } withGrowAfterOpen(t = !0) { return this._growAfterOpen = t, this } withPush(t = !0) { return this._canPush = t, this } withLockedPosition(t = !0) { return this._positionLocked = t, this } setOrigin(t) { return this._origin = t, this } withDefaultOffsetX(t) { return this._offsetX = t, this } withDefaultOffsetY(t) { return this._offsetY = t, this } withTransformOriginOn(t) { return this._transformOriginSelector = t, this } _getOriginPoint(t, e) { let i, n; if ("center" == e.originX) i = t.left + t.width / 2; else { const n = this._isRtl() ? t.right : t.left, s = this._isRtl() ? t.left : t.right; i = "start" == e.originX ? n : s } return n = "center" == e.originY ? t.top + t.height / 2 : "top" == e.originY ? t.top : t.bottom, { x: i, y: n } } _getOverlayPoint(t, e, i) { let n, s; return n = "center" == i.overlayX ? -e.width / 2 : "start" === i.overlayX ? this._isRtl() ? -e.width : 0 : this._isRtl() ? 0 : -e.width, s = "center" == i.overlayY ? -e.height / 2 : "top" == i.overlayY ? 0 : -e.height, { x: t.x + n, y: t.y + s } } _getOverlayFit(t, e, i, n) { const s = qR(e); let { x: r, y: o } = t, a = this._getOffset(n, "x"), l = this._getOffset(n, "y"); a && (r += a), l && (o += l); let c = 0 - o, h = o + s.height - i.height, u = this._subtractOverflows(s.width, 0 - r, r + s.width - i.width), d = this._subtractOverflows(s.height, c, h), p = u * d; return { visibleArea: p, isCompletelyWithinViewport: s.width * s.height === p, fitsInViewportVertically: d === s.height, fitsInViewportHorizontally: u == s.width } } _canFitWithFlexibleDimensions(t, e, i) { if (this._hasFlexibleDimensions) { const n = i.bottom - e.y, s = i.right - e.x, r = WR(this._overlayRef.getConfig().minHeight), o = WR(this._overlayRef.getConfig().minWidth), a = t.fitsInViewportHorizontally || null != o && o <= s; return (t.fitsInViewportVertically || null != r && r <= n) && a } return !1 } _pushOverlayOnScreen(t, e, i) { if (this._previousPushAmount && this._positionLocked) return { x: t.x + this._previousPushAmount.x, y: t.y + this._previousPushAmount.y }; const n = qR(e), s = this._viewportRect, r = Math.max(t.x + n.width - s.width, 0), o = Math.max(t.y + n.height - s.height, 0), a = Math.max(s.top - i.top - t.y, 0), l = Math.max(s.left - i.left - t.x, 0); let c = 0, h = 0; return c = n.width <= s.width ? l || -r : t.x < this._viewportMargin ? s.left - i.left - t.x : 0, h = n.height <= s.height ? a || -o : t.y < this._viewportMargin ? s.top - i.top - t.y : 0, this._previousPushAmount = { x: c, y: h }, { x: t.x + c, y: t.y + h } } _applyPosition(t, e) { if (this._setTransformOrigin(t), this._setOverlayElementStyles(e, t), this._setBoundingBoxStyles(e, t), t.panelClass && this._addPanelClasses(t.panelClass), this._lastPosition = t, this._positionChanges.observers.length) { const e = this._getScrollVisibility(), i = new LR(t, e); this._positionChanges.next(i) } this._isInitialRender = !1 } _setTransformOrigin(t) { if (!this._transformOriginSelector) return; const e = this._boundingBox.querySelectorAll(this._transformOriginSelector); let i, n = t.overlayY; i = "center" === t.overlayX ? "center" : this._isRtl() ? "start" === t.overlayX ? "right" : "left" : "start" === t.overlayX ? "left" : "right"; for (let s = 0; s < e.length; s++)e[s].style.transformOrigin = `${i} ${n}` } _calculateBoundingBoxRect(t, e) { const i = this._viewportRect, n = this._isRtl(); let s, r, o, a, l, c; if ("top" === e.overlayY) r = t.y, s = i.height - r + this._viewportMargin; else if ("bottom" === e.overlayY) o = i.height - t.y + 2 * this._viewportMargin, s = i.height - o + this._viewportMargin; else { const e = Math.min(i.bottom - t.y + i.top, t.y), n = this._lastBoundingBoxSize.height; s = 2 * e, r = t.y - e, s > n && !this._isInitialRender && !this._growAfterOpen && (r = t.y - n / 2) } if ("end" === e.overlayX && !n || "start" === e.overlayX && n) c = i.width - t.x + this._viewportMargin, a = t.x - this._viewportMargin; else if ("start" === e.overlayX && !n || "end" === e.overlayX && n) l = t.x, a = i.right - t.x; else { const e = Math.min(i.right - t.x + i.left, t.x), n = this._lastBoundingBoxSize.width; a = 2 * e, l = t.x - e, a > n && !this._isInitialRender && !this._growAfterOpen && (l = t.x - n / 2) } return { top: r, left: l, bottom: o, right: c, width: a, height: s } } _setBoundingBoxStyles(t, e) { const i = this._calculateBoundingBoxRect(t, e); this._isInitialRender || this._growAfterOpen || (i.height = Math.min(i.height, this._lastBoundingBoxSize.height), i.width = Math.min(i.width, this._lastBoundingBoxSize.width)); const n = {}; if (this._hasExactPosition()) n.top = n.left = "0", n.bottom = n.right = n.maxHeight = n.maxWidth = "", n.width = n.height = "100%"; else { const t = this._overlayRef.getConfig().maxHeight, s = this._overlayRef.getConfig().maxWidth; n.height = Nv(i.height), n.top = Nv(i.top), n.bottom = Nv(i.bottom), n.width = Nv(i.width), n.left = Nv(i.left), n.right = Nv(i.right), n.alignItems = "center" === e.overlayX ? "center" : "end" === e.overlayX ? "flex-end" : "flex-start", n.justifyContent = "center" === e.overlayY ? "center" : "bottom" === e.overlayY ? "flex-end" : "flex-start", t && (n.maxHeight = Nv(t)), s && (n.maxWidth = Nv(s)) } this._lastBoundingBoxSize = i, UR(this._boundingBox.style, n) } _resetBoundingBoxStyles() { UR(this._boundingBox.style, { top: "0", left: "0", right: "0", bottom: "0", height: "", width: "", alignItems: "", justifyContent: "" }) } _resetOverlayElementStyles() { UR(this._pane.style, { top: "", left: "", bottom: "", right: "", position: "", transform: "" }) } _setOverlayElementStyles(t, e) { const i = {}, n = this._hasExactPosition(), s = this._hasFlexibleDimensions, r = this._overlayRef.getConfig(); if (n) { const n = this._viewportRuler.getViewportScrollPosition(); UR(i, this._getExactOverlayY(e, t, n)), UR(i, this._getExactOverlayX(e, t, n)) } else i.position = "static"; let o = "", a = this._getOffset(e, "x"), l = this._getOffset(e, "y"); a && (o += `translateX(${a}px) `), l && (o += `translateY(${l}px)`), i.transform = o.trim(), r.maxHeight && (n ? i.maxHeight = Nv(r.maxHeight) : s && (i.maxHeight = "")), r.maxWidth && (n ? i.maxWidth = Nv(r.maxWidth) : s && (i.maxWidth = "")), UR(this._pane.style, i) } _getExactOverlayY(t, e, i) { let n = { top: "", bottom: "" }, s = this._getOverlayPoint(e, this._overlayRect, t); this._isPushed && (s = this._pushOverlayOnScreen(s, this._overlayRect, i)); let r = this._overlayContainer.getContainerElement().getBoundingClientRect().top; return s.y -= r, "bottom" === t.overlayY ? n.bottom = this._document.documentElement.clientHeight - (s.y + this._overlayRect.height) + "px" : n.top = Nv(s.y), n } _getExactOverlayX(t, e, i) { let n, s = { left: "", right: "" }, r = this._getOverlayPoint(e, this._overlayRect, t); return this._isPushed && (r = this._pushOverlayOnScreen(r, this._overlayRect, i)), n = this._isRtl() ? "end" === t.overlayX ? "left" : "right" : "end" === t.overlayX ? "right" : "left", "right" === n ? s.right = this._document.documentElement.clientWidth - (r.x + this._overlayRect.width) + "px" : s.left = Nv(r.x), s } _getScrollVisibility() { const t = this._getOriginRect(), e = this._pane.getBoundingClientRect(), i = this._scrollables.map(t => t.getElementRef().nativeElement.getBoundingClientRect()); return { isOriginClipped: AR(t, i), isOriginOutsideView: DR(t, i), isOverlayClipped: AR(e, i), isOverlayOutsideView: DR(e, i) } } _subtractOverflows(t, ...e) { return e.reduce((t, e) => t - Math.max(e, 0), t) } _getNarrowedViewportRect() { const t = this._document.documentElement.clientWidth, e = this._document.documentElement.clientHeight, i = this._viewportRuler.getViewportScrollPosition(); return { top: i.top + this._viewportMargin, left: i.left + this._viewportMargin, right: i.left + t - this._viewportMargin, bottom: i.top + e - this._viewportMargin, width: t - 2 * this._viewportMargin, height: e - 2 * this._viewportMargin } } _isRtl() { return "rtl" === this._overlayRef.getDirection() } _hasExactPosition() { return !this._hasFlexibleDimensions || this._isPushed } _getOffset(t, e) { return "x" === e ? null == t.offsetX ? this._offsetX : t.offsetX : null == t.offsetY ? this._offsetY : t.offsetY } _validatePositions() { } _addPanelClasses(t) { this._pane && Fv(t).forEach(t => { "" !== t && -1 === this._appliedPanelClasses.indexOf(t) && (this._appliedPanelClasses.push(t), this._pane.classList.add(t)) }) } _clearPanelClasses() { this._pane && (this._appliedPanelClasses.forEach(t => { this._pane.classList.remove(t) }), this._appliedPanelClasses = []) } _getOriginRect() { const t = this._origin; if (t instanceof Ko) return t.nativeElement.getBoundingClientRect(); if (t instanceof Element) return t.getBoundingClientRect(); const e = t.width || 0, i = t.height || 0; return { top: t.y, bottom: t.y + i, left: t.x, right: t.x + e, height: i, width: e } } } function UR(t, e) { for (let i in e) e.hasOwnProperty(i) && (t[i] = e[i]); return t } function WR(t) { if ("number" != typeof t && null != t) { const [e, i] = t.split(zR); return i && "px" !== i ? null : parseFloat(e) } return t || null } function qR(t) { return { top: Math.floor(t.top), right: Math.floor(t.right), bottom: Math.floor(t.bottom), left: Math.floor(t.left), width: Math.floor(t.width), height: Math.floor(t.height) } } class GR { constructor(t, e, i, n, s, r, o) { this._preferredPositions = [], this._positionStrategy = new $R(i, n, s, r, o).withFlexibleDimensions(!1).withPush(!1).withViewportMargin(0), this.withFallbackPosition(t, e), this.onPositionChange = this._positionStrategy.positionChanges } get positions() { return this._preferredPositions } attach(t) { this._overlayRef = t, this._positionStrategy.attach(t), this._direction && (t.setDirection(this._direction), this._direction = null) } dispose() { this._positionStrategy.dispose() } detach() { this._positionStrategy.detach() } apply() { this._positionStrategy.apply() } recalculateLastPosition() { this._positionStrategy.reapplyLastPosition() } withScrollableContainers(t) { this._positionStrategy.withScrollableContainers(t) } withFallbackPosition(t, e, i, n) { const s = new IR(t, e, i, n); return this._preferredPositions.push(s), this._positionStrategy.withPositions(this._preferredPositions), this } withDirection(t) { return this._overlayRef ? this._overlayRef.setDirection(t) : this._direction = t, this } withOffsetX(t) { return this._positionStrategy.withDefaultOffsetX(t), this } withOffsetY(t) { return this._positionStrategy.withDefaultOffsetY(t), this } withLockedPosition(t) { return this._positionStrategy.withLockedPosition(t), this } withPositions(t) { return this._preferredPositions = t.slice(), this._positionStrategy.withPositions(this._preferredPositions), this } setOrigin(t) { return this._positionStrategy.setOrigin(t), this } } const ZR = "cdk-global-overlay-wrapper"; class KR { constructor() { this._cssPosition = "static", this._topOffset = "", this._bottomOffset = "", this._leftOffset = "", this._rightOffset = "", this._alignItems = "", this._justifyContent = "", this._width = "", this._height = "" } attach(t) { const e = t.getConfig(); this._overlayRef = t, this._width && !e.width && t.updateSize({ width: this._width }), this._height && !e.height && t.updateSize({ height: this._height }), t.hostElement.classList.add(ZR), this._isDisposed = !1 } top(t = "") { return this._bottomOffset = "", this._topOffset = t, this._alignItems = "flex-start", this } left(t = "") { return this._rightOffset = "", this._leftOffset = t, this._justifyContent = "flex-start", this } bottom(t = "") { return this._topOffset = "", this._bottomOffset = t, this._alignItems = "flex-end", this } right(t = "") { return this._leftOffset = "", this._rightOffset = t, this._justifyContent = "flex-end", this } width(t = "") { return this._overlayRef ? this._overlayRef.updateSize({ width: t }) : this._width = t, this } height(t = "") { return this._overlayRef ? this._overlayRef.updateSize({ height: t }) : this._height = t, this } centerHorizontally(t = "") { return this.left(t), this._justifyContent = "center", this } centerVertically(t = "") { return this.top(t), this._alignItems = "center", this } apply() { if (!this._overlayRef || !this._overlayRef.hasAttached()) return; const t = this._overlayRef.overlayElement.style, e = this._overlayRef.hostElement.style, i = this._overlayRef.getConfig(), { width: n, height: s, maxWidth: r, maxHeight: o } = i, a = !("100%" !== n && "100vw" !== n || r && "100%" !== r && "100vw" !== r), l = !("100%" !== s && "100vh" !== s || o && "100%" !== o && "100vh" !== o); t.position = this._cssPosition, t.marginLeft = a ? "0" : this._leftOffset, t.marginTop = l ? "0" : this._topOffset, t.marginBottom = this._bottomOffset, t.marginRight = this._rightOffset, a ? e.justifyContent = "flex-start" : "center" === this._justifyContent ? e.justifyContent = "center" : "rtl" === this._overlayRef.getConfig().direction ? "flex-start" === this._justifyContent ? e.justifyContent = "flex-end" : "flex-end" === this._justifyContent && (e.justifyContent = "flex-start") : e.justifyContent = this._justifyContent, e.alignItems = l ? "flex-start" : this._alignItems } dispose() { if (this._isDisposed || !this._overlayRef) return; const t = this._overlayRef.overlayElement.style, e = this._overlayRef.hostElement, i = e.style; e.classList.remove(ZR), i.justifyContent = i.alignItems = t.marginTop = t.marginBottom = t.marginLeft = t.marginRight = t.position = "", this._overlayRef = null, this._isDisposed = !0 } } let YR = (() => { class t { constructor(t, e, i, n) { this._viewportRuler = t, this._document = e, this._platform = i, this._overlayContainer = n } global() { return new KR } connectedTo(t, e, i) { return new GR(e, i, t, this._viewportRuler, this._document, this._platform, this._overlayContainer) } flexibleConnectedTo(t) { return new $R(t, this._viewportRuler, this._document, this._platform, this._overlayContainer) } } return t.\u0275fac = function (e) { return new (e || t)(hn(dy), hn(vc), hn(ty), hn(VR)) }, t.\u0275prov = dt({ factory: function () { return new t(hn(dy), hn(vc), hn(ty), hn(VR)) }, token: t, providedIn: "root" }), t })(), QR = 0, XR = (() => { class t { constructor(t, e, i, n, s, r, o, a, l, c, h) { this.scrollStrategies = t, this._overlayContainer = e, this._componentFactoryResolver = i, this._positionBuilder = n, this._keyboardDispatcher = s, this._injector = r, this._ngZone = o, this._document = a, this._directionality = l, this._location = c, this._outsideClickDispatcher = h } create(t) { const e = this._createHostElement(), i = this._createPaneElement(e), n = this._createPortalOutlet(i), s = new MR(t); return s.direction = s.direction || this._directionality.value, new BR(n, e, i, s, this._ngZone, this._keyboardDispatcher, this._document, this._location, this._outsideClickDispatcher) } position() { return this._positionBuilder } _createPaneElement(t) { const e = this._document.createElement("div"); return e.id = "cdk-overlay-" + QR++, e.classList.add("cdk-overlay-pane"), t.appendChild(e), e } _createHostElement() { const t = this._document.createElement("div"); return this._overlayContainer.getContainerElement().appendChild(t), t } _createPortalOutlet(t) { return this._appRef || (this._appRef = this._injector.get(oc)), new xR(t, this._componentFactoryResolver, this._appRef, this._injector, this._document) } } return t.\u0275fac = function (e) { return new (e || t)(hn(RR), hn(VR), hn(Wo), hn(YR), hn(NR), hn(Pr), hn(Vl), hn(vc), hn(cy), hn(Mc), hn(jR)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); const JR = { provide: new Wi("cdk-connected-overlay-scroll-strategy"), deps: [XR], useFactory: function (t) { return () => t.scrollStrategies.reposition() } }; let tM = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Gt({ type: t }), t.\u0275inj = pt({ providers: [XR, JR], imports: [[hy, kR, fy], fy] }), t })(); const eM = new ea("12.2.13"), iM = new ea("12.2.13"), nM = new Wi("mat-sanity-checks", { providedIn: "root", factory: function () { return !0 } }); let sM, rM = (() => { class t { constructor(t, e, i) { this._hasDoneGlobalChecks = !1, this._document = i, t._applyBodyHighContrastModeCssClasses(), this._sanityChecks = e, this._hasDoneGlobalChecks || (this._checkDoctypeIsDefined(), this._checkThemeIsPresent(), this._checkCdkVersionMatch(), this._hasDoneGlobalChecks = !0) } _checkIsEnabled(t) { return !(!Jl() || ay()) && ("boolean" == typeof this._sanityChecks ? this._sanityChecks : !!this._sanityChecks[t]) } _checkDoctypeIsDefined() { this._checkIsEnabled("doctype") && !this._document.doctype && console.warn("Current document does not have a doctype. This may cause some Angular Material components not to behave as expected.") } _checkThemeIsPresent() { if (!this._checkIsEnabled("theme") || !this._document.body || "function" != typeof getComputedStyle) return; const t = this._document.createElement("div"); t.classList.add("mat-theme-loaded-marker"), this._document.body.appendChild(t); const e = getComputedStyle(t); e && "none" !== e.display && console.warn("Could not find Angular Material core theme. Most Material components may not work as expected. For more info refer to the theming guide: https://material.angular.io/guide/theming"), this._document.body.removeChild(t) } _checkCdkVersionMatch() { this._checkIsEnabled("version") && iM.full !== eM.full && console.warn("The Angular Material version (" + iM.full + ") does not match the Angular CDK version (" + eM.full + ").\nPlease ensure the versions of these two packages exactly match.") } } return t.\u0275fac = function (e) { return new (e || t)(hn(Iy), hn(nM, 8), hn(vc)) }, t.\u0275mod = Gt({ type: t }), t.\u0275inj = pt({ imports: [[hy], hy] }), t })(); try { sM = "undefined" != typeof Intl } catch (SM) { sM = !1 } function oM(t, e) { } class aM { constructor() { this.role = "dialog", this.panelClass = "", this.hasBackdrop = !0, this.backdropClass = "", this.disableClose = !1, this.width = "", this.height = "", this.maxWidth = "80vw", this.data = null, this.ariaDescribedBy = null, this.ariaLabelledBy = null, this.ariaLabel = null, this.autoFocus = !0, this.restoreFocus = !0, this.closeOnNavigation = !0 } } const lM = { dialogContainer: AD("dialogContainer", [ID("void, exit", MD({ opacity: 0, transform: "scale(0.7)" })), ID("enter", MD({ transform: "none" })), LD("* => enter", OD("150ms cubic-bezier(0, 0, 0.2, 1)", MD({ transform: "none", opacity: 1 }))), LD("* => void, * => exit", OD("75ms cubic-bezier(0.4, 0.0, 0.2, 1)", MD({ opacity: 0 })))]) }; let cM = (() => { class t extends wR { constructor(t, e, i, n, s, r) { super(), this._elementRef = t, this._focusTrapFactory = e, this._changeDetectorRef = i, this._config = s, this._focusMonitor = r, this._animationStateChanged = new Ja, this._elementFocusedBeforeDialogWasOpened = null, this._closeInteractionType = null, this.attachDomPortal = t => (this._portalOutlet.hasAttached(), this._portalOutlet.attachDomPortal(t)), this._ariaLabelledBy = s.ariaLabelledBy || null, this._document = n } _initializeWithAttachedContent() { this._setupFocusTrap(), this._capturePreviouslyFocusedElement(), this._focusDialogContainer() } attachComponentPortal(t) { return this._portalOutlet.hasAttached(), this._portalOutlet.attachComponentPortal(t) } attachTemplatePortal(t) { return this._portalOutlet.hasAttached(), this._portalOutlet.attachTemplatePortal(t) } _recaptureFocus() { this._containsFocus() || (!this._config.autoFocus || !this._focusTrap.focusInitialElement()) && this._elementRef.nativeElement.focus() } _trapFocus() { this._config.autoFocus ? this._focusTrap.focusInitialElementWhenReady() : this._containsFocus() || this._elementRef.nativeElement.focus() } _restoreFocus() { const t = this._elementFocusedBeforeDialogWasOpened; if (this._config.restoreFocus && t && "function" == typeof t.focus) { const e = ry(), i = this._elementRef.nativeElement; e && e !== this._document.body && e !== i && !i.contains(e) || (this._focusMonitor ? (this._focusMonitor.focusVia(t, this._closeInteractionType), this._closeInteractionType = null) : t.focus()) } this._focusTrap && this._focusTrap.destroy() } _setupFocusTrap() { this._focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement) } _capturePreviouslyFocusedElement() { this._document && (this._elementFocusedBeforeDialogWasOpened = ry()) } _focusDialogContainer() { this._elementRef.nativeElement.focus && this._elementRef.nativeElement.focus() } _containsFocus() { const t = this._elementRef.nativeElement, e = ry(); return t === e || t.contains(e) } } return t.\u0275fac = function (e) { return new (e || t)(Ur(Ko), Ur(wy), Ur(wa), Ur(vc, 8), Ur(aM), Ur(Ay)) }, t.\u0275dir = Kt({ type: t, viewQuery: function (t, e) { if (1 & t && function (t, e, i) { const n = Ae(); n.firstCreatePass && (gl(n, new sl(t, 7, void 0), -1), n.staticViewQueries = !0), fl(n, De(), 7) }(SR), 2 & t) { let t; ul(t = pl()) && (e._portalOutlet = t.first) } }, features: [Ar] }), t })(), hM = (() => { class t extends cM { constructor() { super(...arguments), this._state = "enter" } _onAnimationDone({ toState: t, totalTime: e }) { "enter" === t ? (this._trapFocus(), this._animationStateChanged.next({ state: "opened", totalTime: e })) : "exit" === t && (this._restoreFocus(), this._animationStateChanged.next({ state: "closed", totalTime: e })) } _onAnimationStart({ toState: t, totalTime: e }) { "enter" === t ? this._animationStateChanged.next({ state: "opening", totalTime: e }) : "exit" !== t && "void" !== t || this._animationStateChanged.next({ state: "closing", totalTime: e }) } _startExitAnimation() { this._state = "exit", this._changeDetectorRef.markForCheck() } } return t.\u0275fac = function () { let e; return function (i) { return (e || (e = Hi(t)))(i || t) } }(), t.\u0275cmp = $t({ type: t, selectors: [["mat-dialog-container"]], hostAttrs: ["tabindex", "-1", "aria-modal", "true", 1, "mat-dialog-container"], hostVars: 6, hostBindings: function (t, e) { 1 & t && to("@dialogContainer.start", function (t) { return e._onAnimationStart(t) })("@dialogContainer.done", function (t) { return e._onAnimationDone(t) }), 2 & t && (Co("id", e._id), Hr("role", e._config.role)("aria-labelledby", e._config.ariaLabel ? null : e._ariaLabelledBy)("aria-label", e._config.ariaLabel)("aria-describedby", e._config.ariaDescribedBy || null), Eo("@dialogContainer", e._state)) }, features: [Ar], decls: 1, vars: 0, consts: [["cdkPortalOutlet", ""]], template: function (t, e) { 1 & t && zr(0, oM, 0, 0, "ng-template", 0) }, directives: [SR], styles: [".mat-dialog-container{display:block;padding:24px;border-radius:4px;box-sizing:border-box;overflow:auto;outline:0;width:100%;height:100%;min-height:inherit;max-height:inherit}.cdk-high-contrast-active .mat-dialog-container{outline:solid 1px}.mat-dialog-content{display:block;margin:0 -24px;padding:0 24px;max-height:65vh;overflow:auto;-webkit-overflow-scrolling:touch}.mat-dialog-title{margin:0 0 20px;display:block}.mat-dialog-actions{padding:8px 0;display:flex;flex-wrap:wrap;min-height:52px;align-items:center;box-sizing:content-box;margin-bottom:-24px}.mat-dialog-actions[align=end]{justify-content:flex-end}.mat-dialog-actions[align=center]{justify-content:center}.mat-dialog-actions .mat-button-base+.mat-button-base,.mat-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:8px}[dir=rtl] .mat-dialog-actions .mat-button-base+.mat-button-base,[dir=rtl] .mat-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:0;margin-right:8px}\n"], encapsulation: 2, data: { animation: [lM.dialogContainer] } }), t })(), uM = 0; class dM { constructor(t, e, i = "mat-dialog-" + uM++) { this._overlayRef = t, this._containerInstance = e, this.id = i, this.disableClose = this._containerInstance._config.disableClose, this._afterOpened = new S, this._afterClosed = new S, this._beforeClosed = new S, this._state = 0, e._id = i, e._animationStateChanged.pipe(Jh(t => "opened" === t.state), qh(1)).subscribe(() => { this._afterOpened.next(), this._afterOpened.complete() }), e._animationStateChanged.pipe(Jh(t => "closed" === t.state), qh(1)).subscribe(() => { clearTimeout(this._closeFallbackTimeout), this._finishDialogClose() }), t.detachments().subscribe(() => { this._beforeClosed.next(this._result), this._beforeClosed.complete(), this._afterClosed.next(this._result), this._afterClosed.complete(), this.componentInstance = null, this._overlayRef.dispose() }), t.keydownEvents().pipe(Jh(t => 27 === t.keyCode && !this.disableClose && !function (t, ...e) { return e.length ? e.some(e => t[e]) : t.altKey || t.shiftKey || t.ctrlKey || t.metaKey }(t))).subscribe(t => { t.preventDefault(), pM(this, "keyboard") }), t.backdropClick().subscribe(() => { this.disableClose ? this._containerInstance._recaptureFocus() : pM(this, "mouse") }) } close(t) { this._result = t, this._containerInstance._animationStateChanged.pipe(Jh(t => "closing" === t.state), qh(1)).subscribe(e => { this._beforeClosed.next(t), this._beforeClosed.complete(), this._overlayRef.detachBackdrop(), this._closeFallbackTimeout = setTimeout(() => this._finishDialogClose(), e.totalTime + 100) }), this._state = 1, this._containerInstance._startExitAnimation() } afterOpened() { return this._afterOpened } afterClosed() { return this._afterClosed } beforeClosed() { return this._beforeClosed } backdropClick() { return this._overlayRef.backdropClick() } keydownEvents() { return this._overlayRef.keydownEvents() } updatePosition(t) { let e = this._getPositionStrategy(); return t && (t.left || t.right) ? t.left ? e.left(t.left) : e.right(t.right) : e.centerHorizontally(), t && (t.top || t.bottom) ? t.top ? e.top(t.top) : e.bottom(t.bottom) : e.centerVertically(), this._overlayRef.updatePosition(), this } updateSize(t = "", e = "") { return this._overlayRef.updateSize({ width: t, height: e }), this._overlayRef.updatePosition(), this } addPanelClass(t) { return this._overlayRef.addPanelClass(t), this } removePanelClass(t) { return this._overlayRef.removePanelClass(t), this } getState() { return this._state } _finishDialogClose() { this._state = 2, this._overlayRef.dispose() } _getPositionStrategy() { return this._overlayRef.getConfig().positionStrategy } } function pM(t, e, i) { return void 0 !== t._containerInstance && (t._containerInstance._closeInteractionType = e), t.close(i) } const fM = new Wi("MatDialogData"), gM = new Wi("mat-dialog-default-options"), mM = new Wi("mat-dialog-scroll-strategy"), _M = { provide: mM, deps: [XR], useFactory: function (t) { return () => t.scrollStrategies.block() } }; let vM = (() => { class t { constructor(t, e, i, n, s, r, o, a, l) { this._overlay = t, this._injector = e, this._defaultOptions = i, this._parentDialog = n, this._overlayContainer = s, this._dialogRefConstructor = o, this._dialogContainerType = a, this._dialogDataToken = l, this._openDialogsAtThisLevel = [], this._afterAllClosedAtThisLevel = new S, this._afterOpenedAtThisLevel = new S, this._ariaHiddenElements = new Map, this.afterAllClosed = Hh(() => this.openDialogs.length ? this._getAfterAllClosed() : this._getAfterAllClosed().pipe(Kh(void 0))), this._scrollStrategy = r } get openDialogs() { return this._parentDialog ? this._parentDialog.openDialogs : this._openDialogsAtThisLevel } get afterOpened() { return this._parentDialog ? this._parentDialog.afterOpened : this._afterOpenedAtThisLevel } _getAfterAllClosed() { const t = this._parentDialog; return t ? t._getAfterAllClosed() : this._afterAllClosedAtThisLevel } open(t, e) { (e = function (t, e) { return Object.assign(Object.assign({}, e), t) }(e, this._defaultOptions || new aM)).id && this.getDialogById(e.id); const i = this._createOverlay(e), n = this._attachDialogContainer(i, e), s = this._attachDialogContent(t, n, i, e); return this.openDialogs.length || this._hideNonDialogContentFromAssistiveTechnology(), this.openDialogs.push(s), s.afterClosed().subscribe(() => this._removeOpenDialog(s)), this.afterOpened.next(s), n._initializeWithAttachedContent(), s } closeAll() { this._closeDialogs(this.openDialogs) } getDialogById(t) { return this.openDialogs.find(e => e.id === t) } ngOnDestroy() { this._closeDialogs(this._openDialogsAtThisLevel), this._afterAllClosedAtThisLevel.complete(), this._afterOpenedAtThisLevel.complete() } _createOverlay(t) { const e = this._getOverlayConfig(t); return this._overlay.create(e) } _getOverlayConfig(t) { const e = new MR({ positionStrategy: this._overlay.position().global(), scrollStrategy: t.scrollStrategy || this._scrollStrategy(), panelClass: t.panelClass, hasBackdrop: t.hasBackdrop, direction: t.direction, minWidth: t.minWidth, minHeight: t.minHeight, maxWidth: t.maxWidth, maxHeight: t.maxHeight, disposeOnNavigation: t.closeOnNavigation }); return t.backdropClass && (e.backdropClass = t.backdropClass), e } _attachDialogContainer(t, e) { const i = Pr.create({ parent: e && e.viewContainerRef && e.viewContainerRef.injector || this._injector, providers: [{ provide: aM, useValue: e }] }), n = new vR(this._dialogContainerType, e.viewContainerRef, i, e.componentFactoryResolver); return t.attach(n).instance } _attachDialogContent(t, e, i, n) { const s = new this._dialogRefConstructor(i, e, n.id); if (t instanceof Ea) e.attachTemplatePortal(new yR(t, null, { $implicit: n.data, dialogRef: s })); else { const i = this._createInjector(n, s, e), r = e.attachComponentPortal(new vR(t, n.viewContainerRef, i)); s.componentInstance = r.instance } return s.updateSize(n.width, n.height).updatePosition(n.position), s } _createInjector(t, e, i) { const n = t && t.viewContainerRef && t.viewContainerRef.injector, s = [{ provide: this._dialogContainerType, useValue: i }, { provide: this._dialogDataToken, useValue: t.data }, { provide: this._dialogRefConstructor, useValue: e }]; return !t.direction || n && n.get(cy, null, wt.Optional) || s.push({ provide: cy, useValue: { value: t.direction, change: Dh() } }), Pr.create({ parent: n || this._injector, providers: s }) } _removeOpenDialog(t) { const e = this.openDialogs.indexOf(t); e > -1 && (this.openDialogs.splice(e, 1), this.openDialogs.length || (this._ariaHiddenElements.forEach((t, e) => { t ? e.setAttribute("aria-hidden", t) : e.removeAttribute("aria-hidden") }), this._ariaHiddenElements.clear(), this._getAfterAllClosed().next())) } _hideNonDialogContentFromAssistiveTechnology() { const t = this._overlayContainer.getContainerElement(); if (t.parentElement) { const e = t.parentElement.children; for (let i = e.length - 1; i > -1; i--) { let n = e[i]; n === t || "SCRIPT" === n.nodeName || "STYLE" === n.nodeName || n.hasAttribute("aria-live") || (this._ariaHiddenElements.set(n, n.getAttribute("aria-hidden")), n.setAttribute("aria-hidden", "true")) } } } _closeDialogs(t) { let e = t.length; for (; e--;)t[e].close() } } return t.\u0275fac = function (e) { return new (e || t)(Ur(XR), Ur(Pr), Ur(void 0), Ur(void 0), Ur(VR), Ur(void 0), Ur(Gi), Ur(Gi), Ur(Wi)) }, t.\u0275dir = Kt({ type: t }), t })(), yM = (() => { class t extends vM { constructor(t, e, i, n, s, r, o) { super(t, e, n, r, o, s, dM, hM, fM) } } return t.\u0275fac = function (e) { return new (e || t)(hn(XR), hn(Pr), hn(Mc, 8), hn(gM, 8), hn(mM), hn(t, 12), hn(VR)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), bM = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Gt({ type: t }), t.\u0275inj = pt({ providers: [yM, _M], imports: [[tM, kR, rM], rM] }), t })(); var wM = function () { function t() { } return t.forRoot = function () { return { ngModule: t } }, t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Gt({ type: t }), t.\u0275inj = pt({ imports: [[Gc]] }), t }(); let xM = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Gt({ type: t, bootstrap: [TD] }), t.\u0275inj = pt({ providers: [mR, vv], imports: [[Ph, ED, fR, Yg, Qg, Mm, bM, Ob, wM]] }), t })(); (function () { if (Xl) throw new Error("Cannot enable prod mode after platform setup."); Ql = !1 })(), Eh().bootstrapModule(xM).catch(t => console.error(t)) } }, t => { "use strict"; t(t.s = 823) }]);